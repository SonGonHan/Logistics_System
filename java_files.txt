=== backend/shared-library/src/main/java/com/logistics/shared/validation/PasswordValidator.java ===
package com.logistics.shared.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PasswordValidator implements ConstraintValidator<Password, String> {

    // Минимум 8 символов, >=1 строчная, >=1 заглавная, >=1 цифра, >=1 спецсимвол
    private static final String REGEX =
            "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$";

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return false;
        }
        return value.matches(REGEX);
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/validation/Phone.java ===
package com.logistics.shared.validation;


import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = PhoneValidator.class)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Phone {

    String message() default "Неверный формат телефона";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}



=== backend/shared-library/src/main/java/com/logistics/shared/validation/PhoneValidator.java ===
package com.logistics.shared.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PhoneValidator implements ConstraintValidator<Phone, String> {


    private static final String REGEX =
            "^(?:\\+7|7)\\d{10}$" +              // Россия
                    "|^(?:\\+375|375)\\d{9}$" +         // Беларусь
                    "|^(?:\\+77|77)\\d{9}$";            // Казахстан

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isBlank()) {
            return false;
        }
        String normalized = value.replaceAll("[\\s\\-()]", "");
        return normalized.matches(REGEX);
    }
}




=== backend/shared-library/src/main/java/com/logistics/shared/validation/Password.java ===
package com.logistics.shared.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = PasswordValidator.class)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Password {

    String message() default
            "Пароль должен содержать минимум 8 символов, " +
                    "включая цифру, заглавную и строчную букву и спецсимвол";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}




=== backend/shared-library/src/main/java/com/logistics/shared/SharedLibraryConfiguration.java ===
package com.logistics.shared;

import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

//@SpringBootConfiguration
@Configuration
@EntityScan("com.logistics.shared")
@EnableJpaRepositories("com.logistics.shared")
public class SharedLibraryConfiguration {

}


=== backend/shared-library/src/main/java/com/logistics/shared/OpenApiConfig.java ===
package com.logistics.shared;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Базовая конфигурация OpenAPI для всех микросервисов логистической системы.
 *
 * Предоставляет:
 * - Единый формат документации
 - Bearer JWT аутентификация
 - Контактную информацию
 *
 * Использование: import в главном классе каждого сервиса.
 *
 */

// * @see UserAuthServiceApplication

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Logistics System API")
                        .version("1.0.0")
                        .description("REST API для системы логистики и управления доставкой")
                        .contact(new Contact()
                                .name("Logistics Development Team")
                                .email("dev@logistics.com")
                                .url("https://logistics.com")))
                .addSecurityItem(new SecurityRequirement().addList("Bearer JWT"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("Bearer JWT",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")
                                        .description("JWT access token для аутентификации. Вставьте токен без 'Bearer ' префикса.")));
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionTypeMapper.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import org.springframework.stereotype.Component;

@Component
public class AuditActionTypeMapper {

    public AuditActionType toDomain(AuditActionTypeEntity entity) {
        return AuditActionType.builder()
                .id(entity.getId())
                .actionName(entity.getActionName())
                .category(entity.getCategory())
                .description(entity.getDescription())
                .build();
    }

    public AuditActionTypeEntity toEntity(AuditActionType domain) {
        return AuditActionTypeEntity.builder()
                .id(domain.getId())
                .actionName(domain.getActionName())
                .category(domain.getCategory())
                .description(domain.getDescription())
                .build();
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionJpaRepository.java ===
package com.logistics.shared.audit_action.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface AuditActionJpaRepository extends JpaRepository<AuditActionTypeEntity, Integer> {

    Optional<AuditActionTypeEntity> findByCategory(String category);

    Optional<AuditActionTypeEntity> findByActionName(String actionName);
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionTypeEntity.java ===
package com.logistics.shared.audit_action.persistence;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(
        name = "audit_action_types",
        schema = "shared_data",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "action_name")
        },
        indexes = {
//                @Index(columnList = "action_name", name = "audit_action_types_action_name_key")
        }
)
public class AuditActionTypeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "audit_action_type_seq")
    @SequenceGenerator(
            name = "audit_action_type_seq",
            sequenceName = "audit_action_types_action_type_id_seq",
            schema = "shared_data",
            allocationSize = 1
    )
    @Column(name = "action_type_id")
    private Short id;

    @Column(name = "action_name", nullable = false)
    private String actionName;

    @Column(name = "category", nullable = false)
    private String category;

    @Column(name = "description")
    private String description;

}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/domain/AuditActionType.java ===
package com.logistics.shared.audit_action.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AuditActionType {

    private short id;

    private String actionName;

    private String category;

    private String description;
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/AuditActionTypeService.java ===
package com.logistics.shared.audit_action;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@RequiredArgsConstructor
public class AuditActionTypeService {

    private final AuditActionJpaRepository repo;
    private final AuditActionTypeMapper mapper;

    public Optional<AuditActionType> getActionTypeById(Integer id) {
        return repo.findById(id).map(mapper::toDomain);
    }

    public Optional<AuditActionType> getActionTypeActionName(String actionName) {
        return repo.findByActionName(actionName).map(mapper::toDomain);
    }

    public Optional<AuditActionType> getActionTypeByCategory(String category) {
        return repo.findByCategory(category).map(mapper::toDomain);
    }

}


=== backend/shared-library/src/test/java/com/logistics/shared/IntegrationTest.java ===
package com.logistics.shared;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
@ActiveProfiles("test")
public @interface IntegrationTest {
}



=== backend/shared-library/src/test/java/com/logistics/shared/TestApplication.java ===
package com.logistics.shared;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@Import(SharedLibraryConfiguration.class)
public class TestApplication {

}


=== backend/shared-library/src/test/java/com/logistics/shared/validation/PhoneValidatorTest.java ===
package com.logistics.shared.validation;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("PhoneValidator: юнит‑тесты")
class PhoneValidatorTest {

    private final PhoneValidator validator = new PhoneValidator();

    @Test
    @DisplayName("Должен принимать корректные номера РФ/РБ/КЗ")
    void shouldAcceptValidPhones() {
        assertThat(validator.isValid("79991234567", null)).isTrue(); // РФ
        assertThat(validator.isValid("+7 (999) 123-45-67", null)).isTrue(); // РФ с форматированием
        assertThat(validator.isValid("+375291234567", null)).isTrue(); // Беларусь
        assertThat(validator.isValid("375291234567", null)).isTrue();  // Беларусь без плюса
        assertThat(validator.isValid("+77011234567", null)).isTrue();  // Казахстан
        assertThat(validator.isValid("77011234567", null)).isTrue();   // Казахстан без плюса
    }

    @Test
    @DisplayName("Должен отклонять некорректные номера")
    void shouldRejectInvalidPhones() {
        assertThat(validator.isValid("123", null)).isFalse();
        assertThat(validator.isValid("abcdefghijk", null)).isFalse();
        assertThat(validator.isValid("+1 999 123 45 67", null)).isFalse(); // не наш регион
        assertThat(validator.isValid("+7999123456", null)).isFalse();      // мало цифр
        assertThat(validator.isValid("+799912345678", null)).isFalse();    // много цифр
    }

}



=== backend/shared-library/src/test/java/com/logistics/shared/validation/PasswordValidatorTest.java ===
package com.logistics.shared.validation;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("PasswordValidator: юнит‑тесты")
class PasswordValidatorTest {

    private final PasswordValidator validator = new PasswordValidator();

    @Test
    @DisplayName("Должен принимать достаточно сложные пароли")
    void shouldAcceptStrongPasswords() {
        assertThat(validator.isValid("Password123!", null)).isTrue();
        assertThat(validator.isValid("Qwerty1@", null)).isTrue();
    }

    @Test
    @DisplayName("Должен отклонять слабые пароли")
    void shouldRejectWeakPasswords() {
        assertThat(validator.isValid("short", null)).isFalse();          // короткий
        assertThat(validator.isValid("password", null)).isFalse();      // без цифр/символов
        assertThat(validator.isValid("password1", null)).isFalse();     // без спецсимвола
        assertThat(validator.isValid("PASSWORD1!", null)).isFalse();    // без строчных
        assertThat(validator.isValid("password1!", null)).isFalse();    // без заглавных
    }

    @Test
    @DisplayName("Должен отклонять null")
    void shouldRejectNull() {
        assertThat(validator.isValid(null, null)).isFalse();
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/SharedLibraryApplicationTests.java ===
package com.logistics.shared;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@SpringBootTest
@ActiveProfiles("test")
@DisplayName("Тесты загрузки контекста для Shared Library")
class SharedLibraryApplicationTests {

    @Test
    @DisplayName("Должен успешно загрузить контекст Spring")
    void contextLoads() {
        // Этот тест проверяет, что все бины и конфигурации загружаются без ошибок
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/AuditActionTypeServiceTest.java ===
package com.logistics.shared.audit_action;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("Тесты для AuditActionTypeService")
class AuditActionTypeServiceTest {

    @Mock
    private AuditActionJpaRepository repo;
    @Mock
    private AuditActionTypeMapper mapper;
    @InjectMocks
    private AuditActionTypeService service;

    private AuditActionTypeEntity testEntity;
    private AuditActionType testDomain;

    @BeforeEach
    void setUp() {
        testEntity = AuditActionTypeEntity.builder().id((short) 1).actionName("USER_LOGIN").category("AUTHENTICATION").description("User logged in").build();
        testDomain = AuditActionType.builder().id((short) 1).actionName("USER_LOGIN").category("AUTHENTICATION").description("User logged in").build();
    }

    @Test
    @DisplayName("Должен вернуть ActionType по ID")
    void shouldGetActionTypeById() {
        when(repo.findById(anyInt())).thenReturn(Optional.of(testEntity));
        when(mapper.toDomain(any(AuditActionTypeEntity.class))).thenReturn(testDomain);

        Optional<AuditActionType> result = service.getActionTypeById(1);

        assertThat(result).isPresent();
        assertThat(result.get().getId()).isEqualTo((short) 1);
        verify(repo, times(1)).findById(1);
    }
}




=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/persistence/AuditActionTypeMapperTest.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("Тесты для AuditActionTypeMapper")
class AuditActionTypeMapperTest {

    private AuditActionTypeMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new AuditActionTypeMapper();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        AuditActionTypeEntity entity = AuditActionTypeEntity.builder()
                .id((short) 1)
                .actionName("USER_LOGIN")
                .category("AUTHENTICATION")
                .description("Пользователь вошел в систему")
                .build();

        // When
        AuditActionType domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo((short) 1);
        assertThat(domain.getActionName()).isEqualTo("USER_LOGIN");
        assertThat(domain.getCategory()).isEqualTo("AUTHENTICATION");
        assertThat(domain.getDescription()).isEqualTo("Пользователь вошел в систему");
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        AuditActionType domain = AuditActionType.builder()
                .id((short) 2)
                .actionName("USER_LOGOUT")
                .category("AUTHENTICATION")
                .description("Пользователь вышел из системы")
                .build();

        // When
        AuditActionTypeEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo((short) 2);
        assertThat(entity.getActionName()).isEqualTo("USER_LOGOUT");
        assertThat(entity.getCategory()).isEqualTo("AUTHENTICATION");
        assertThat(entity.getDescription()).isEqualTo("Пользователь вышел из системы");
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/persistence/AuditActionJpaRepositoryIntegrationTest.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.IntegrationTest;
import com.logistics.shared.TestApplication;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("Интеграционные тесты для AuditActionJpaRepository")
//@Disabled("Mockito не поддерживает Java 25 полностью. Нужно обновить версию Mockito.")
class AuditActionJpaRepositoryIntegrationTest {

    @Autowired
    private AuditActionJpaRepository repository;

    @Test
    @DisplayName("Должен сохранить и найти AuditActionType по ID")
    void shouldSaveAndFindById() {
        // Given
        // Создаем сущность, которую собираемся сохранить
        AuditActionTypeEntity entityToSave = AuditActionTypeEntity.builder()
                .actionName("ORDER_CREATED")
                .category("ORDER_MANAGEMENT")
                .description("Заказ создан")
                .build();

        // Сохраняем и, что КЛЮЧЕВОЕ, получаем обратно экземпляр с ID
        AuditActionTypeEntity savedEntity = repository.save(entityToSave);

        // When
        // Ищем в базе по ID, полученному от сохраненной сущности
        Optional<AuditActionTypeEntity> found = repository.findById(Integer.valueOf(savedEntity.getId()));

        // Then
        assertThat(found).isPresent(); // Проверяем, что сущность нашлась
        assertThat(found.get().getActionName()).isEqualTo("ORDER_CREATED"); // Проверяем ее содержимое
        assertThat(found.get().getId()).isEqualTo(savedEntity.getId());
    }

}



=== backend/db-migration/src/main/java/com/logistics/db/DbMigrationApplication.java ===
package com.logistics.db;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication(
		exclude = HibernateJpaAutoConfiguration.class
)
public class DbMigrationApplication {
	private static final Logger log = LoggerFactory.getLogger(DbMigrationApplication.class);

	public static void main(String[] args) {
		try {
			log.info("========== Начало инициализации БД ==========");
			ConfigurableApplicationContext context =
					SpringApplication.run(DbMigrationApplication.class, args);

			log.info("✓ Миграции БД выполнены успешно");
			log.info("========== Завершение работы миграций ==========");

			// Закрыть контекст и завершить приложение
			context.close();
			System.exit(0);

		} catch (Exception e) {
			log.error("✗ Ошибка при выполнении миграций БД", e);
			System.exit(1);
		}
	}

}



=== backend/db-migration/src/main/java/com/logistics/db/FlywayConfig.java ===
package com.logistics.db;

import org.flywaydb.core.Flyway;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
@EnableConfigurationProperties
@ConditionalOnProperty(
        name = "app.db-migration.enabled",
        havingValue = "true",
        matchIfMissing = true
)
public class FlywayConfig {

    @Bean
    public Flyway flyway(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .locations("classpath:db/migration")
                .baselineOnMigrate(true)
                .validateOnMigrate(true)
                .cleanDisabled(true)  // Отключить очистку в production
                .load();

        flyway.migrate();
        return flyway;
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/UserAuthServiceApplication.java ===
package com.logistics.userauth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@ComponentScan(basePackages = {
        "com.logistics.userauth",
        "com.logistics.shared"
})
@EnableJpaRepositories(basePackages = "com.logistics.userauth.**.persistence")
@EntityScan(basePackages = "com.logistics.userauth.**.persistence")
@Import(com.logistics.shared.OpenApiConfig.class)
public class UserAuthServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserAuthServiceApplication.class, args);
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/app/out/AuditLogRepository.java ===
package com.logistics.userauth.audit.application.out;


import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.domain.User;

import java.util.List;
import java.util.Optional;

public interface AuditLogRepository {
    void save(AuditLog auditLog);

    void delete(AuditLog auditLog);

    List<AuditLog> findByUser(User user);

    Optional<AuditLog> findByActionType(AuditActionType actionType);

    Optional<AuditLog> findByActorIdentifier(String actorIdentifier);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/domain/AuditLog.java ===
package com.logistics.userauth.audit.domain;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.user.domain.User;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AuditLog {

    private long id;

    private User user;

    private AuditActionType actionType;

    private String tableName;

    private long recordId;

    private String actorIdentifier;

    private Map<String, Object> newValues;

    private LocalDateTime performedAt;

    private Inet ipAddress;
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/AuditLogControllerMapper.java ===
package com.logistics.userauth.audit.adapter.in;

import com.logistics.userauth.audit.adapter.in.dto.AuditLogDTO;
import com.logistics.userauth.audit.domain.AuditLog;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class AuditLogControllerMapper {

    private final AuditActionTypeControllerMapper actionTypeMapper;

    public AuditLogDTO toDTO(AuditLog domain) {
        return AuditLogDTO.builder()
                .user(domain.getUser())
                .actionTypeDTO(actionTypeMapper.toDTO(domain.getActionType()))
                .tableName(domain.getTableName())
                .recordId(domain.getRecordId())
                .actorIdentifier(domain.getActorIdentifier())
                .performedAt(domain.getPerformedAt())
                .newValues(domain.getNewValues())
                .build();
    }

    public AuditLog toDomain(AuditLogDTO dto) {
        return AuditLog.builder()
                .user(dto.user())
                .actionType(actionTypeMapper.toDomain(dto.actionTypeDTO()))
                .tableName(dto.tableName())
                .recordId(dto.recordId())
                .actorIdentifier(dto.actorIdentifier())
                .performedAt(dto.performedAt())
                .newValues(dto.newValues())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/AuditActionTypeControllerMapper.java ===
package com.logistics.userauth.audit.adapter.in;

import com.logistics.shared.audit_action.AuditActionTypeService;
import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.audit.adapter.in.dto.AuditActionTypeDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class AuditActionTypeControllerMapper {

    private final AuditActionTypeService service;

    public AuditActionTypeDTO toDTO(AuditActionType domain) {
        return AuditActionTypeDTO.builder()
                .actionType(domain.getActionName())
                .description(domain.getDescription())
                .category(domain.getCategory())
                .build();
    }

    public AuditActionType toDomain(AuditActionTypeDTO dto) {
        return AuditActionType.builder()
                .id(service.getActionTypeActionName(dto.actionType()).get().getId())
                .actionName(dto.actionType())
                .category(dto.category())
                .description(dto.description())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/dto/AuditActionTypeDTO.java ===
package com.logistics.userauth.audit.adapter.in.dto;

import lombok.Builder;

@Builder
public record AuditActionTypeDTO (String actionType, String category, String description) {

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/dto/AuditLogDTO.java ===
package com.logistics.userauth.audit.adapter.in.dto;

import com.logistics.userauth.user.domain.User;
import lombok.Builder;

import java.time.LocalDateTime;
import java.util.Map;

@Builder
public record AuditLogDTO (
        User user,
        AuditActionTypeDTO actionTypeDTO,
        String tableName,
        long recordId,
        String actorIdentifier,
        Map<String, Object> newValues,
        LocalDateTime performedAt
) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogJpaRepository.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
interface AuditLogJpaRepository extends JpaRepository<AuditLogEntity, Long> {

    List<AuditLogEntity> findByUser(UserEntity user);

    Optional<AuditLogEntity> findByActionType(AuditActionTypeEntity actionType);

    Optional<AuditLogEntity> findByActorIdentifier(String actorIdentifier);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceMapper.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class AuditLogPersistenceMapper {

    private final AuditActionTypeMapper actionTypeMapper;
    private final UserPersistenceMapper userMapper;

    public AuditLogEntity toEntity(AuditLog domain) {
        return AuditLogEntity.builder()
                .id(domain.getId())
                .user(userMapper.toEntity(domain.getUser()))
                .actionType(actionTypeMapper.toEntity(domain.getActionType()))
                .actorIdentifier(domain.getActorIdentifier())
                .ipAddress(domain.getIpAddress())
                .newValues(domain.getNewValues())
                .performedAt(domain.getPerformedAt())
                .tableName(domain.getTableName())
                .recordId(domain.getRecordId())
                .build();
    }

    public AuditLog toDomain(AuditLogEntity entity) {
        return AuditLog.builder()
                .id(entity.getId())
                .user(userMapper.toDomain(entity.getUser()))
                .actionType(actionTypeMapper.toDomain(entity.getActionType()))
                .actorIdentifier(entity.getActorIdentifier())
                .ipAddress(entity.getIpAddress())
                .newValues(entity.getNewValues())
                .performedAt(entity.getPerformedAt())
                .tableName(entity.getTableName())
                .recordId(entity.getRecordId())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceAdapter.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.application.out.AuditLogRepository;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Component
@RequiredArgsConstructor
public class AuditLogPersistenceAdapter implements AuditLogRepository {

    private final AuditLogJpaRepository jpaRepo;
    private final AuditLogPersistenceMapper auditLogMapper;
    private final UserPersistenceMapper userMapper;
    private final AuditActionTypeMapper auditActionTypeMapper;

    @Override
    public void save(AuditLog auditLog) {
        AuditLogEntity auditLogEntity = auditLogMapper.toEntity(auditLog);
        jpaRepo.save(auditLogEntity);
    }

    @Override
    public void delete(AuditLog auditLog) {
        AuditLogEntity auditLogEntity = auditLogMapper.toEntity(auditLog);
        jpaRepo.delete(auditLogEntity);
    }

    @Override
    public List<AuditLog> findByUser(User user) {
        return jpaRepo.findByUser(userMapper.toEntity(user)).stream().map(auditLogMapper::toDomain).toList();
    }

    @Override
    public Optional<AuditLog> findByActionType(AuditActionType actionType) {
        return jpaRepo.findByActionType(auditActionTypeMapper.toEntity(actionType)).map(auditLogMapper::toDomain);
    }

    @Override
    public Optional<AuditLog> findByActorIdentifier(String actorIdentifier) {
        return jpaRepo.findByActorIdentifier(actorIdentifier).map(auditLogMapper::toDomain);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogEntity.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import io.hypersistence.utils.hibernate.type.basic.PostgreSQLInetType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.annotations.Type;
import org.hibernate.type.SqlTypes;
import org.springframework.data.annotation.CreatedDate;

import java.time.LocalDateTime;
import java.util.Map;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(
        name = "audit_logs",
        schema = "user_management"
//        ,
//        indexes = {
//                @Index(columnList = "user_id", name = "idx_audit_logs_user_id"),
//                @Index(columnList = "action_type_id", name = "idx_audit_logs_action_type_id"),
//                @Index(columnList = "table_name, record_id", name = "idx_audit_logs_record"),
//                @Index(columnList = "performed_at", name = "idx_audit_logs_performed_at")
//        }
)
@Builder
public class AuditLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "audit_logs_seq")
    @SequenceGenerator(
            name = "audit_logs_seq",
            sequenceName = "audit_logs_audit_log_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "audit_log_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private UserEntity user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "action_type_id")
    private AuditActionTypeEntity actionType;

    @Column(name = "table_name")
    private String tableName;

    @Column(name = "record_id")
    private Long recordId;

    @Column(name = "actor_identifier")
    private String actorIdentifier;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "new_values", columnDefinition = "jsonb")
    private Map<String, Object> newValues;

    @CreatedDate
    @Column(name = "performed_at")
    private LocalDateTime performedAt;

    @Column(name = "ip_address", columnDefinition = "inet")
    @Type(PostgreSQLInetType.class)
    private Inet ipAddress;
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/application/port/out/UserRepository.java ===
package com.logistics.userauth.user.application.port.out;

import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;

import java.util.Optional;

public interface UserRepository {
    User save(User user);

    void delete(User user);

    Optional<User> findById(Long id);

    Optional<User> findByPhone(String phone);

    Optional<User> findByEmail(String email);

    Optional<User> findByRole(UserRole role);

    Optional<User> findByFacilityId(long id);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/UserRole.java ===
package com.logistics.userauth.user.domain;

public enum UserRole {
    UNREGISTERED_CONTACT,
    CLIENT,
    PVZ_OPERATOR, PVZ_ADMIN,
    COURIER, DRIVER,
    DISPATCHER,
    WAREHOUSE_OPERATOR, WAREHOUSE_ADMIN,
    HR, ACCOUNTANT, SYSTEM_ADMIN,
    SYSTEM
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/User.java ===
package com.logistics.userauth.user.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    private Long id;

    private String email;

    private String phone;

    private String passwordHash;

    private String firstName;

    private String lastName;

    private String middleName;

    private UserRole role;

    private Long facilityId;

    private LocalDateTime createdTime;

    private LocalDateTime lastAccessedTime;

    private UserStatus status;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/UserStatus.java ===
package com.logistics.userauth.user.domain;

public enum UserStatus {
    ACTIVE,
    ON_DELETE // При установке такого статуса, на следующий день аккаунт удаляется (установка может быть по собственному желанию, может при увольнении)
}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/SignUpRequest.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.shared.validation.Password;
import com.logistics.shared.validation.Phone;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;

/**
 * Запрос для регистрации нового пользователя.
 *
 * Валидация:
 * - email: Должен быть в формате email
 * - phone: Формат +7XXXXXXXXXX (Россия), +375XXXXXXXXX (Беларусь), +77XXXXXXXXX (Казахстан)
 * - password: Минимум 8 символов, включая цифру, заглавную и строчную букву и спецсимвол
 * - firstName, lastName: Не пусты
 *
 * Пример:
 * {
 *   "email": "john@example.com",
 *   "phone": "+79991234567",
 *   "password": "Password123!",
 *   "firstName": "Иван",
 *   "lastName": "Иванов",
 *   "middleName": "Иванович"
 * }
 */
@Builder
public record SignUpRequest(
        @Email
        String email,

        @NotNull
        @Phone
        String phone,

        @Password
        String password,

        @NotBlank
        String firstName,

        @NotBlank
        String lastName,

        String middleName
) {}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/UserDTO.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.userauth.user.domain.UserRole;
import lombok.Builder;

@Builder
public record UserDTO (String phone,
                       String firstName,
                       String lastName,
                       String middleName,
                       UserRole role){

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/SignInRequest.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.shared.validation.Password;
import com.logistics.shared.validation.Phone;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;

/**
 * Запрос для авторизации пользователя.
 *
 * Валидация:
 * - phone: Обязателен, формат +7/375/77...
 * - password: Обязателен, сложный пароль
 * - email: Опциональный альтернативный способ входа
 *
 * Пример:
 * {
 *   "phone": "+79991234567",
 *   "password": "Password123!"
 * }
 */
@Builder
public record SignInRequest (
        @NotNull
        @Phone
        String phone,

        @Email
        String email,

        @Password
        String password
) { }


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/FacilityDTO.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import lombok.Builder;

@Builder
public record FacilityDTO (String name, String address) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/UserControllerMapper.java ===
package com.logistics.userauth.user.adapter.in;

import com.logistics.userauth.user.adapter.in.web.dto.UserDTO;
import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
public class UserControllerMapper {
    public static UserDTO toDTO(User user) {
        return UserDTO.builder()
                .phone(user.getPhone())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .middleName(user.getMiddleName())
                .role(user.getRole())
                .build();
    }

    public static User toUser(UserDTO userDTO) {
        return User.builder()
                .phone(userDTO.phone())
                .firstName(userDTO.firstName())
                .lastName(userDTO.lastName())
                .middleName(userDTO.middleName())
                .role(userDTO.role())
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceMapper.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.time.LocalDateTime;

@Component
public class UserPersistenceMapper {

    public UserEntity toEntity(User domain) {
        return UserEntity.builder()
                .id(domain.getId())
                .email(domain.getEmail())
                .phone(domain.getPhone())
                .passwordHash(domain.getPasswordHash())
                .firstName(domain.getFirstName())
                .lastName(domain.getLastName())
                .middleName(domain.getMiddleName())
                .role(domain.getRole())
                .facilityId(domain.getFacilityId())
                .status(domain.getStatus())
                .createdAt(domain.getCreatedTime())
                .lastAccessedAt(domain.getLastAccessedTime())
                .build();
    }

    public User toDomain(UserEntity entity) {
        return User.builder()
                .id(entity.getId())
                .email(entity.getEmail())
                .phone(entity.getPhone())
                .passwordHash(entity.getPasswordHash())
                .firstName(entity.getFirstName())
                .lastName(entity.getLastName())
                .middleName(entity.getMiddleName())
                .role(entity.getRole())
                .facilityId(entity.getFacilityId())
                .status(entity.getStatus())
                .createdTime(entity.getCreatedAt())
                .lastAccessedTime(entity.getLastAccessedAt())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceAdapter.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@RequiredArgsConstructor
@Component
public class UserPersistenceAdapter implements UserRepository {

    private final UserJpaRepository jpaRepo;
    private final UserPersistenceMapper mapper;

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        var saved = jpaRepo.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public void delete(User user) {
        UserEntity entity = mapper.toEntity(user);
        jpaRepo.delete(entity);
    }

    @Override
    public Optional<User> findById(Long id) {
        return jpaRepo.findById(id).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByPhone(String phone) {
        return jpaRepo.findByPhone(phone).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByEmail(String email) {
        return jpaRepo.findByEmail(email).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByRole(UserRole role) {
        return jpaRepo.findByRole(role).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByFacilityId(long id) {
        return jpaRepo.findByFacilityId(id).map(mapper::toDomain);
    }


}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserEntity.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;

import java.time.Instant;
import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(
        name = "users",
        schema = "user_management",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "phone")
        },
        indexes = {
                @Index(columnList = "email", name = "idx_users_email"),
                @Index(columnList = "phone", name = "idx_users_phone"),
                @Index(columnList = "role_name", name = "idx_users_role_name"),
                @Index(columnList = "last_accessed_at", name = "idx_users_last_accessed"),
                @Index(columnList = "facility_id", name = "idx_users_facility_id")
        }
)
@Builder
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_seq")
    @SequenceGenerator(
            name = "users_seq",
            sequenceName = "users_user_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "user_id")
    private Long id;

    @Column(name = "email")
    @Email
    private String email;

    @Column(name = "phone", nullable = false)
    private String phone;

    @Column(name = "password_hash")
    private String passwordHash;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Column(name = "middle_name")
    private String middleName;

    @Enumerated(EnumType.STRING)
    @Column(name = "role_name", nullable = false)
    private UserRole role;

    @Column(name = "facility_id")
    private Long facilityId;

    @Enumerated(EnumType.STRING)
    @Column(name = "user_status")
    private UserStatus status;

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "last_accessed_at")
    private LocalDateTime lastAccessedAt;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserJpaRepository.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.UserRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserJpaRepository extends JpaRepository<UserEntity, Long> {

    Optional<UserEntity> findByEmail(String email);

    Optional<UserEntity> findByPhone(String phone);

    Optional<UserEntity> findByRole(UserRole role);

    Optional<UserEntity> findByFacilityId(long id);

}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/infrastructure/LogisticsUserDetails.java ===
package com.logistics.userauth.user.infrastructure;

import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;

@RequiredArgsConstructor
public class LogisticsUserDetails implements UserDetails {

    private final User user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority("ROLE_" + user.getRole().name()));
    }

    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }

    @Override
    public String getUsername() {
        return user.getPhone();
    }

    public Long getId() {
        return user.getId();
    }

    @Override
    public boolean isAccountNonExpired() { return true; }
    @Override
    public boolean isAccountNonLocked() { return true; }
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    @Override
    public boolean isEnabled() { return true; }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/infrastructure/LogisticsUserDetailsService.java ===
package com.logistics.userauth.user.infrastructure;

import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class LogisticsUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String phone) throws UsernameNotFoundException {
        User user = userRepository.findByPhone(phone)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + phone));
        return new LogisticsUserDetails(user);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/web/GlobalExceptionHandler.java ===
package com.logistics.userauth.common.web;

import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * Глобальный обработчик исключений для всех REST endpoints.
 *
 * Обеспечивает единообразный формат ошибок для всех API endpoints:
 * {
 *   "error": "ERROR_CODE",
 *   "message": "Human-readable message",
 *   "fields": { "fieldName": "error message" }  // только для VALIDATION_FAILED
 * }
 *
 * Обработка исключений:
 * - BadCredentialsException → 401 INVALID_CREDENTIALS
 * - DataIntegrityViolationException → 409 CONFLICT
 * - MethodArgumentNotValidException → 400 VALIDATION_FAILED
 * - InvalidRefreshTokenException → 401 INVALID_REFRESH_TOKEN
 * - Все остальные Exception → 500 INTERNAL_SERVER_ERROR
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Обработка ошибок аутентификации (неверные учетные данные).
     *
     * @param ex BadCredentialsException
     * @return ResponseEntity с кодом 401
     */
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<Map<String, Object>> handleBadCredentials(BadCredentialsException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "INVALID_CREDENTIALS");
        body.put("message", "Неверный телефон или пароль");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);
    }

    /**
     * Обработка ошибок целостности данных (duplicate keys, constraint violations).
     *
     * @param ex DataIntegrityViolationException
     * @return ResponseEntity с кодом 409
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<Map<String, Object>> handleDataIntegrity(DataIntegrityViolationException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "CONFLICT");
        body.put("message", "Пользователь с таким телефоном или email уже существует");
        return ResponseEntity.status(HttpStatus.CONFLICT).body(body);
    }

    /**
     * Обработка ошибок валидации входных параметров.
     *
     * @param ex MethodArgumentNotValidException
     * @return ResponseEntity с кодом 400 и деталями ошибок по полям
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> fieldErrors = new HashMap<>();
        for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) {
            fieldErrors.put(fieldError.getField(), fieldError.getDefaultMessage());
        }

        Map<String, Object> body = new HashMap<>();
        body.put("error", "VALIDATION_FAILED");
        body.put("fields", fieldErrors);
        return ResponseEntity.badRequest().body(body);
    }

    /**
     * Обработка ошибок невалидного refresh token.
     *
     * @param ex InvalidRefreshTokenException
     * @return ResponseEntity с кодом 401
     */
    @ExceptionHandler(InvalidRefreshTokenException.class)
    public ResponseEntity<Map<String, Object>> handleInvalidRefreshToken(InvalidRefreshTokenException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "INVALID_REFRESH_TOKEN");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/LogoutOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

@Operation(
        summary = "Выход из системы",
        description = "Отзывает (revoke) refresh token, делая его неиспользуемым",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(responseCode = "204", description = "Успешный выход"),
        @ApiResponse(responseCode = "401", description = "Refresh token невалиден")
})
public @interface LogoutOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/SignInOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

@Operation(
        summary = "Авторизация пользователя",
        description = "Проверяет учетные данные пользователя (телефон/пароль) и выдает JWT access token и refresh token",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "Успешная авторизация",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "401",
                description = "Неверные учетные данные (телефон или пароль)",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Ошибка валидации входных данных"
        )
})
public @interface SignInOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/RefreshOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

@Operation(
        summary = "Обновление access токена",
        description = "Использует refresh token для выдачи нового access token и нового refresh token (token rotation)",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "Новые токены успешно выданы"
        ),
        @ApiResponse(
                responseCode = "401",
                description = "Refresh token невалиден, истек или был отозван"
        )
})
public @interface RefreshOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/SignUpOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

@Operation(
        summary = "Регистрация нового пользователя",
        description = "Создает новый аккаунт пользователя с ролью CLIENT и выдает JWT tokens",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "201",
                description = "Пользователь успешно зарегистрирован"
        ),
        @ApiResponse(
                responseCode = "409",
                description = "Пользователь с таким телефоном или email уже существует"
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Ошибка валидации входных данных"
        )
})
public @interface SignUpOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RegisterUserService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RegisterUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class RegisterUserService implements RegisterUserUseCase {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @Override
    public JwtAuthenticationResponse register(RegisterUserCommand command) {
        var user = User.builder()
                .email(command.email())
                .phone(command.phone())
                .passwordHash(passwordEncoder.encode(command.rawPassword()))
                .firstName(command.firstName())
                .lastName(command.lastName())
                .middleName(command.middleName())
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        var saved = userRepository.save(user);

        var accessToken = tokenGenerator.generateAccessToken(saved);

        var refreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(saved.getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(accessToken, refreshToken);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RefreshAccessTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RefreshAccessTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

/**
 * Сервис для обновления access токена с использованием refresh токена.
 *
 * Реализует паттерн Token Rotation:
 * 1. Принимает старый refresh token
 * 2. Проверяет его валидность (не истек, не отозван)
 * 3. Помечает старый refresh token как отозванный
 * 4. Выдает новый access token и новый refresh token
 *
 * Это повышает безопасность: если refresh token будет скомпрометирован,
 * злоумышленник сможет его использовать только один раз.
 */
@Service
@RequiredArgsConstructor
public class RefreshAccessTokenService implements RefreshAccessTokenUseCase {

    private final UserSessionRepository repository;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    /**
     * Обновляет access токен на основе refresh токена.
     *
     * @param command Команда содержит:
     *                - refreshToken: старый refresh token
     *                - ipAddress: IP-адрес клиента
     *                - userAgent: браузер клиента
     *
     * @return JwtAuthenticationResponse с новыми access и refresh токенами
     *
     * @throws InvalidRefreshTokenException если:
     *         - Токен не найден в БД
     *         - Токен был отозван
     *         - Токен истек (expiresAt < now)
     */
    @Override
    @Transactional
    public JwtAuthenticationResponse refresh(RefreshAccessTokenCommand command) {
        var session = repository.findByRefreshToken(command.refreshToken())
                .orElseThrow(() -> new InvalidRefreshTokenException("Invalid refresh token"));

        validate(session);

        String newAccessToken = tokenGenerator.generateAccessToken(session.getUser());

        session.setRevoked(true);
        repository.save(session);

        String newRefreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(session.getUser().getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(newAccessToken, newRefreshToken);
    }

    /**
     * Валидирует refresh token перед использованием.
     *
     * @param session Сессия пользователя
     * @throws InvalidRefreshTokenException если токен отозван или истек
     */
    private static void validate(UserSession session) {
        if (session.isRevoked()) {
            throw new InvalidRefreshTokenException("Refresh token is revoked");
        }

        if (session.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidRefreshTokenException("Refresh token is expired");
        }
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/AuthenticateUserService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.AuthenticateUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.application.port.out.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthenticateUserService implements AuthenticateUserUseCase {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @Override
    public JwtAuthenticationResponse authenticate(AuthenticateUserCommand command) {
        var user = userRepository.findByPhone(command.phone())
                .orElseThrow(() -> new BadCredentialsException("Invalid credentials"));

        if (!passwordEncoder.matches(command.password(), user.getPasswordHash())) {
            throw new BadCredentialsException("Invalid credentials");
        }

        var accessToken = tokenGenerator.generateAccessToken(user);

        var refreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(user.getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(accessToken, refreshToken);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RevokeRefreshTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.port.in.RevokeRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
/**
 * Сервис для отзыва (revoke) refresh токенов.
 *
 * Отзыв токена делает его непригодным для дальнейшего использования.
 * Используется при logout и других операциях завершения сессии.
 *
 * При попытке использовать отозванный токен для обновления access token
 * будет выброшено исключение InvalidRefreshTokenException.
 */
@Service
@RequiredArgsConstructor
public class RevokeRefreshTokenService implements RevokeRefreshTokenUseCase {

    private final UserSessionRepository repository;

    /**
     * Отзывает refresh token, делая его неиспользуемым.
     *
     * @param command Команда содержит refreshToken для отзыва
     *
     * @throws InvalidRefreshTokenException если токен не найден в БД
     */
    @Override
    public void revoke(RevokeRefreshTokenCommand command) {
        var session = repository.findByRefreshToken(command.refreshToken()).orElseThrow(() -> new InvalidRefreshTokenException("Invalid refresh token"));
        session.setRevoked(true);
        repository.save(session);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/InternalCreateRefreshTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.application.port.out.UserRepository;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Внутренний сервис для создания refresh токенов.
 *
 * Отмечен как "Internal" (внутренний) потому что:
 * - Не должен вызваться напрямую из контроллеров
 * - Используется другими use cases (Register, Authenticate, Refresh)
 * - Инкапсулирует логику создания и сохранения сессии
 *
 * Каждый refresh token уникален и привязан к:
 * - Конкретному пользователю
 * - Конкретному устройству (IP + User-Agent)
 * - Определенному времени истечения (TTL из конфигурации)
 */
@Service
@RequiredArgsConstructor
public class InternalCreateRefreshTokenService implements InternalCreateRefreshTokenUseCase {

    private final UserSessionRepository sessionRepository;
    private final UserRepository userRepository;

    @Value("${app.jwt.refresh-expiration}")
    private long refreshTokenTtlSeconds;

    /**
     * Создает новый refresh token для пользователя.
     *
     * @param command Команда содержит:
     *                - userId: ID пользователя
     *                - ipAddress: IP-адрес клиента
     *                - userAgent: User-Agent браузера
     *
     * @return UUID строка, которая служит refresh токеном
     *
     * @throws RuntimeException если пользователь с таким ID не найден
     *
     * @see UserSession для деталей сохраненной сессии
     */
    @Override
    public String create(CreateRefreshTokenCommand command) {
        var user = userRepository.findById(command.userId()).orElseThrow(() ->  new RuntimeException("User not found"));

        String refreshToken = UUID.randomUUID().toString();

        var session = UserSession.builder()
                .user(user)
                .refreshToken(refreshToken)
                .expiresAt(LocalDateTime.now().plusSeconds(refreshTokenTtlSeconds))
                .createdAt(LocalDateTime.now())
                .ipAddress(command.ipAddress() != null ? new Inet(command.ipAddress()): null)
                .userAgent(command.userAgent())
                .revoked(false)
                .build();

        sessionRepository.save(session);
        return refreshToken;
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RegisterUserUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;

public interface RegisterUserUseCase {
    JwtAuthenticationResponse register(RegisterUserCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/AuthenticateUserUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;

public interface AuthenticateUserUseCase {
    JwtAuthenticationResponse authenticate(AuthenticateUserCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RevokeRefreshTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;

public interface RevokeRefreshTokenUseCase {
    void revoke(RevokeRefreshTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/InternalCreateRefreshTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;

public interface InternalCreateRefreshTokenUseCase {
    String create(CreateRefreshTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RefreshAccessTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;

public interface RefreshAccessTokenUseCase {
    JwtAuthenticationResponse refresh(RefreshAccessTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/CreateRefreshTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import lombok.Builder;

@Builder
public record CreateRefreshTokenCommand(
        Long userId,
        String ipAddress,
        String userAgent
){
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RegisterUserCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import lombok.Builder;

@Builder
public record RegisterUserCommand(
        String email,
        String phone,
        String rawPassword,
        String firstName,
        String lastName,
        String middleName,
        String ipAddress,
        String userAgent
) { }



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RefreshAccessTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import lombok.Builder;

@Builder
public record RefreshAccessTokenCommand (
        String refreshToken,
        String ipAddress,
        String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/AuthenticateUserCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import lombok.Builder;

@Builder
public record AuthenticateUserCommand (
        String phone,
        String password,
        String ipAddress,
        String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RevokeRefreshTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import lombok.Builder;

@Builder
public record RevokeRefreshTokenCommand(String refreshToken) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/out/TokenGeneratorPort.java ===
package com.logistics.userauth.auth.jwt.application.port.out;

import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

public interface TokenGeneratorPort {
    String generateAccessToken(User user);
    boolean isTokenValid(String token);
    Long extractUserId(String token);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/exception/InvalidRefreshTokenException.java ===
package com.logistics.userauth.auth.jwt.application.exception;

import com.logistics.userauth.auth.jwt.application.usecase.RefreshAccessTokenService;
import com.logistics.userauth.common.web.GlobalExceptionHandler;

/**
 * Исключение выбрасываемое когда refresh token невалиден или не может быть использован.
 *
 * Случаи когда выбрасывается:
 * 1. Token not found: Токен отсутствует в БД
 * 2. Token expired: Токен истек (current time > expiresAt)
 * 3. Token revoked: Токен был явно отозван (revoked = true)
 * 4. Token rotated: Токен был заменен на новый (pattern token rotation)
 *
 * HTTP ответ: 401 Unauthorized
 *
 * Обработка: @ExceptionHandler в GlobalExceptionHandler возвращает
 * {
 *   "error": "INVALID_REFRESH_TOKEN",
 *   "message": "..."
 * }
 *
 * @see GlobalExceptionHandler для обработки этого исключения
 * @see RefreshAccessTokenService где выбрасывается
 */
public class InvalidRefreshTokenException extends RuntimeException {
    /**
     * Создает новое исключение с сообщением об ошибке.
     *
     * @param message Человеко-читаемое описание причины (будет возвращено клиенту)
     */
    public InvalidRefreshTokenException(String message) {
        super(message);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/security/JwtAuthenticationFilter.java ===
package com.logistics.userauth.auth.jwt.adapter.in.security;

import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.jwt.infrastructure.security.SecurityConfiguration;
import com.logistics.userauth.user.application.port.out.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * Фильтр для аутентификации запросов на основе JWT токенов.
 *
 * Применяется ко ВСЕМ запросам кроме /auth/** endpoints.
 *
 * Процесс:
 * 1. Читает header Authorization
 * 2. Извлекает Bearer токен
 * 3. Валидирует токен через JwtTokenProvider
 * 4. Извлекает userId из токена
 * 5. Загружает пользователя из БД
 * 6. Создает Authentication объект и устанавливает в SecurityContext
 * 7. Передает запрос дальше по цепочке
 *
 * Если токен невалиден:
 * - Запрос передается дальше БЕЗ аутентификации
 * - Spring Security вернет 403 Forbidden для защищенных ресурсов
 *
 * Интеграция:
 * @see SecurityConfiguration где регистрируется этот фильтр
 * @see JwtTokenProvider для валидации токенов
 */
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    public static final String HEADER_NAME = "Authorization";
    public static final String BEARER_PREFIX = "Bearer ";

    private final TokenGeneratorPort tokenGenerator;
    private final UserRepository userRepository;

    /**
     * Выполняет фильтрацию и аутентификацию.
     *
     * @param request HTTP запрос
     * @param response HTTP ответ
     * @param filterChain Цепочка фильтров
     */
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String authHeader = request.getHeader(HEADER_NAME);

        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(BEARER_PREFIX.length());

        if (!tokenGenerator.isTokenValid(token)) {
            filterChain.doFilter(request, response);
            return;
        }

        var userId = tokenGenerator.extractUserId(token);
        if (userId != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            var userOpt = userRepository.findById(userId);
            if (userOpt.isPresent()) {
                var user = userOpt.get();
                var authorities = List.of(new SimpleGrantedAuthority(user.getRole().name()));
                var authToken = new UsernamePasswordAuthenticationToken(
                                user, null, authorities
                );

                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Исключает /auth/** endpoints из обработки этого фильтра.
     *
     * @param request HTTP запрос
     * @return true если запрос НЕ должен быть обработан этим фильтром
     */
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/auth/");
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/dto/JwtAuthenticationResponse.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web.dto;

import lombok.Builder;

/**
 * Ответ с JWT токенами после успешной аутентификации или регистрации.
 *
 * Содержит:
 * - accessToken: JWT токен для доступа к защищенным ресурсам (TTL: 15-60 минут)
 * - refreshToken: Токен для получения нового accessToken без повторной аутентификации (TTL: 7-30 дней)
 *
 * Пример:
 * {
 *   "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNjk3NTAwMzIzfQ.xxxx",
 *   "refreshToken": "550e8400-e29b-41d4-a716-446655440000"
 * }
 *
 * Использование:
 * 1. accessToken используется в header: Authorization: Bearer {accessToken}
 * 2. refreshToken хранится безопасно на клиенте (при истечении accessToken)
 */
@Builder
public record JwtAuthenticationResponse (String accessToken, String refreshToken) {
}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/dto/RefreshTokenRequest.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web.dto;

/**
 * Запрос для обновления access token или выхода из системы.
 *
 * Используется для:
 * 1. POST /auth/refresh - получить новый access token
 * 2. POST /auth/logout - отозвать (invalidate) текущую сессию
 *
 * Пример:
 * {
 *   "refreshToken": "550e8400-e29b-41d4-a716-446655440000"
 * }
 */
public record RefreshTokenRequest(String refreshToken) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/AuthController.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.auth.jwt.application.port.in.AuthenticateUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RefreshAccessTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RegisterUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RevokeRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.common.api.LogoutOperation;
import com.logistics.userauth.common.api.RefreshOperation;
import com.logistics.userauth.common.api.SignInOperation;
import com.logistics.userauth.common.api.SignUpOperation;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
@Tag(
        name = "Аутентификация",
        description = "REST API endpoints для регистрации, логина, refresh токенов и выхода из системы"
)
public class AuthController {
    private final AuthenticateUserUseCase authenticateUserUseCase;
    private final RegisterUserUseCase registerUserUseCase;
    private final RefreshAccessTokenUseCase refreshAccessTokenUseCase;
    private final RevokeRefreshTokenUseCase revokeRefreshTokenUseCase;

    @PostMapping("/sign-in")
    @SignInOperation
    public ResponseEntity<JwtAuthenticationResponse> signIn(
            @Valid @RequestBody SignInRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = AuthenticateUserCommand.builder()
                .phone(request.phone())
                .password(request.password())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();
        return ResponseEntity.ok(authenticateUserUseCase.authenticate(command));
    }

    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    @SignUpOperation
    public ResponseEntity<JwtAuthenticationResponse> signUp(
            @Valid @RequestBody SignUpRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = RegisterUserCommand.builder()
                .email(request.email())
                .phone(request.phone())
                .rawPassword(request.password())
                .firstName(request.firstName())
                .lastName(request.lastName())
                .middleName(request.middleName())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();

        var response = registerUserUseCase.register(command);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PostMapping("/logout")
    @LogoutOperation
    public ResponseEntity<Void> logout(@Valid @RequestBody RefreshTokenRequest request) {
        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken(request.refreshToken())
                .build();

        revokeRefreshTokenUseCase.revoke(command);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/refresh")
    @RefreshOperation
    public ResponseEntity<JwtAuthenticationResponse> refresh(
            @Valid @RequestBody RefreshTokenRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = RefreshAccessTokenCommand.builder()
                .refreshToken(request.refreshToken())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();

        return ResponseEntity.ok(refreshAccessTokenUseCase.refresh(command));
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/out/JwtTokenProvider.java ===
package com.logistics.userauth.auth.jwt.adapter.out;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.domain.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Date;

/**
 * Провайдер для генерации и валидации JWT access токенов.
 *
 * Использует HS256 (HMAC SHA256) алгоритм подписания.
 *
 * Структура JWT:
 * - Header: { "alg": "HS256" }
 * - Payload: { "sub": "userId", "iat": timestamp, "exp": timestamp, "phone": "...", "role": "..." }
 * - Signature: HMAC(secret, header.payload)
 *
 * Конфигурация в application.yml:
 * app:
 *   jwt:
 *     secret: "your-secret-key-change-in-production"
 *     expiration: 3600  # 1 час в секундах
 *
 * @see JwtAuthenticationFilter для проверки токена в каждом запросе
 */
@Component
@RequiredArgsConstructor
public class JwtTokenProvider implements TokenGeneratorPort {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private long accessTokenTtlSeconds;

    /**
     * Генерирует новый JWT access token для пользователя.
     *
     * @param user Пользователь, для которого создается токен
     * @return Подписанный JWT токен в виде строки
     */
    @Override
    public String generateAccessToken(User user) {
        Instant now = Instant.now();
        Instant expiry = now.plusSeconds(accessTokenTtlSeconds);

        return Jwts.builder()
                .subject(user.getId().toString())
                .issuedAt(Date.from(now))
                .expiration(Date.from(expiry))
                .claim("phone", user.getPhone())
                .claim("role", user.getRole().name())
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
    }

    /**
     * Проверяет валидность JWT токена.
     *
     * @param token JWT токен для проверки
     * @return true если токен валиден и не истек
     */
    @Override
    public boolean isTokenValid(String token) {
        try {
            parseClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException ex) {
            return false;
        }
    }

    /**
     * Извлекает ID пользователя из JWT токена.
     *
     * @param token JWT токен
     * @return ID пользователя (значение "sub" claim)
     */
    @Override
    public Long extractUserId(String token) {
        Claims claims = parseClaims(token);
        String sub = claims.getSubject();
        return Long.valueOf(sub);
    }



    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    private Claims parseClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/infrastructure/security/SecurityConfiguration.java ===
package com.logistics.userauth.auth.jwt.infrastructure.security;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.user.infrastructure.LogisticsUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Конфигурация Spring Security для JWT-based аутентификации.
 *
 * Особенности:
 * - Stateless сессии (не используются cookies и sessions)
 * - CSRF отключен (для REST API с JWT не требуется)
 * - JWT фильтр регистрируется в цепочке безопасности
 * - /auth/** endpoints открыты для всех
 * - Остальные endpoints требуют валидный JWT токен
 *
 * Архитектура:
 * 1. JwtAuthenticationFilter → извлекает и валидирует токен
 * 2. AuthenticationProvider → аутентифицирует user/password при логине
 * 3. SecurityFilterChain → определяет какие endpoint защищены
 *
 * @see JwtAuthenticationFilter для деталей обработки JWT
 * @see LogisticsUserDetailsService для загрузки пользователя из БД
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    private final LogisticsUserDetailsService userDetailsService;

    /**
     * Определяет цепочку фильтров безопасности.
     *
     * @param http HttpSecurity для конфигурации
     * @return SecurityFilterChain
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                // REST + JWT => CSRF обычно отключаем
                .csrf(csrf -> csrf.disable())

                // Сессии нам не нужны, работаем stateless
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // Настройки авторизации по URL
                .authorizeHttpRequests(auth -> auth
                        // эндпоинты авторизации/регистрации — без токена
                        .requestMatchers("/auth/**").permitAll()
                        // при необходимости добавь swagger / actuator и т.п.
                        //.requestMatchers("/v3/api-docs/**", "/swagger-ui/**").permitAll()
                        // всё остальное — только с валидным JWT
                        .requestMatchers(
                                "/v3/api-docs/**",
                                "/swagger-ui/**",
                                "/swagger-ui.html",
                                "/swagger-ui/index.html",
                                "/webjars/**"
                        ).permitAll()
//
//                        // на всякий случай, если матчер у вас учитывает context-path
//                        .requestMatchers(
//                                "/api/v1/v3/api-docs/**",
//                                "/api/v1/swagger-ui/**",
//                                "/api/v1/swagger-ui.html",
//                                "/api/v1/webjars/**"
//                        ).permitAll()
                        .anyRequest().authenticated()

                )

                // Указываем, как аутентифицировать username/password (используется при логине)
                .authenticationProvider(authenticationProvider())

                // Регистрируем наш JWT-фильтр ПЕРЕД стандартным UsernamePasswordAuthenticationFilter
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    /**
     * Провайдер аутентификации для username/password при логине.
     *
     * @return AuthenticationProvider
     */
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
            throws Exception {
        return config.getAuthenticationManager();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/application/ports/out/UserSessionRepository.java ===
package com.logistics.userauth.auth.session.application.port.out;

import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.domain.User;

import java.util.Optional;

public interface UserSessionRepository {
    Optional<UserSession> findByUser(User user);

    Optional<UserSession> findByRefreshToken(String refreshToken);

    void save(UserSession userSession);

    void delete(UserSession userSession);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/domain/UserSession.java ===
package com.logistics.userauth.auth.session.domain;

import com.logistics.userauth.auth.session.adapter.out.persistence.UserSessionEntity;
import com.logistics.userauth.user.domain.User;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.*;

import java.time.LocalDateTime;

/**
 * Доменная модель для сессии пользователя.
 *
 * Представляет активную сессию пользователя с привязанным refresh токеном.
 *
 * Жизненный цикл сессии:
 * 1. СОЗДАНИЕ: При регистрации или логине создается новая сессия с refresh токеном
 * 2. ИСПОЛЬЗОВАНИЕ: Клиент использует refresh токен для получения новых access токенов
 * 3. ROTATION: При каждом использовании старый refresh токен помечается как revoked
 * 4. ИСТЕЧЕНИЕ: По истечении TTL сессия удаляется из БД (очистка кроном)
 *
 * Безопасность:
 * - Refresh token уникален для каждой сессии
 * - Привязан к IP-адресу и User-Agent для дополнительной защиты
 * - Может быть явно отозван пользователем (logout)
 * - Имеет ограниченное время жизни (TTL)
 *
 * @see UserSessionEntity JPA представление в БД
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserSession {

    private long id;

    /** Пользователь, которому принадлежит сессия */
    private User user;

    /** UUID токен для обновления access token */
    private String refreshToken;

    /** Время создания сессии */
    private LocalDateTime createdAt;

    /** Время истечения сессии (обычно +7 дней от создания) */
    private LocalDateTime expiresAt;

    /** IP-адрес клиента для аудита и безопасности */
    private Inet ipAddress;

    /** User-Agent браузера для идентификации устройства */
    private String userAgent;

    /** Флаг отзыва: true = токен больше не может быть использован */
    private boolean revoked;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/UserSessionControllerMapper.java ===
package com.logistics.userauth.auth.session.adapter.in;

import com.logistics.userauth.auth.session.adapter.in.dto.UserSessionDTO;
import com.logistics.userauth.auth.session.domain.UserSession;
import org.springframework.stereotype.Component;

@Component
public class UserSessionControllerMapper {

    public UserSession toUserSession(UserSessionDTO userSessionDTO) {
        return UserSession.builder()
                .createdAt(userSessionDTO.createdAt())
                .ipAddress(userSessionDTO.ipAddress())
                .userAgent(userSessionDTO.userAgent())
                .expiresAt(userSessionDTO.expiresAt())
                .build();
    }

    public UserSessionDTO toUserSessionDTO(UserSession userSession) {
        return UserSessionDTO.builder()
                .createdAt(userSession.getCreatedAt())
                .ipAddress(userSession.getIpAddress())
                .userAgent(userSession.getUserAgent())
                .expiresAt(userSession.getExpiresAt())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/dto/UserSessionDTO.java ===
package com.logistics.userauth.auth.session.adapter.in.dto;


import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Builder
public record UserSessionDTO (LocalDateTime createdAt,
                              LocalDateTime expiresAt,
                              Inet ipAddress,
                              String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionEntity.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import io.hypersistence.utils.hibernate.type.basic.PostgreSQLInetType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.Type;
import org.springframework.data.annotation.CreatedDate;

import java.time.LocalDateTime;
/**
 * JPA Entity для хранения сессий пользователей и их refresh токенов.
 *
 * Таблица: user_management.user_sessions
 *
 * Основные поля:
 * - sessionId: Уникальный ID сессии (первичный ключ)
 * - userId: Внешний ключ на таблицу users
 * - refreshToken: UUID токен для обновления access token
 * - expiresAt: Время истечения refresh token (обычно 7-30 дней)
 * - createdAt: Время создания сессии
 * - revoked: Флаг отзыва (true = токен больше не валиден)
 * - ipAddress: IP-адрес клиента (для аудита)
 * - userAgent: User-Agent браузера (для аудита)
 *
 * Индексы:
 * - idx_user_sessions_user_id: для быстрого поиска сессий пользователя
 * - idx_user_sessions_expires_at: для очистки истекших сессий
 *
 * Уникальные ограничения:
 * - refresh_token должен быть уникален (один токен = одна сессия)
 *
 * @see UserSession доменная модель
 * @see UserSessionPersistenceMapper преобразование Entity ↔ Domain
 */
@Entity
@Table(
        name = "user_sessions",
        schema = "user_management",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "refresh_token")
        },
        indexes = {
                @Index(columnList = "user_id", name = "idx_user_sessions_user_id"),
                @Index(columnList = "expires_at", name = "idx_user_sessions_expires_at")
        }
)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserSessionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_sessions_seq")
    @SequenceGenerator(
            name = "user_sessions_seq",
            sequenceName = "user_sessions_session_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "session_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "refresh_token", nullable = false)
    private String refreshToken;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "revoked", nullable = false)
    private boolean revoked = false;

    @Column(name = "ip_address", columnDefinition = "inet")
    @Type(PostgreSQLInetType.class)
    private Inet ipAddress;

    @Column(name = "user_agent")
    private String userAgent; // Браузер

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionPersistenceMapper.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class UserSessionPersistenceMapper {

    private final UserPersistenceMapper upMapper;

    public UserSession toDomain(UserSessionEntity entity) {
        return UserSession.builder()
                .id(entity.getId())
                .user(upMapper.toDomain(entity.getUser()))
                .refreshToken(entity.getRefreshToken())
                .expiresAt(entity.getExpiresAt())
                .ipAddress(entity.getIpAddress())
                .revoked(entity.isRevoked())
                .userAgent(entity.getUserAgent())
                .createdAt(entity.getCreatedAt())
                .build();
    }

    public UserSessionEntity toEntity(UserSession domain) {
        return UserSessionEntity.builder()
                .id(domain.getId())
                .user(upMapper.toEntity(domain.getUser()))
                .refreshToken(domain.getRefreshToken())
                .createdAt(domain.getCreatedAt())
                .expiresAt(domain.getExpiresAt())
                .revoked(domain.isRevoked())
                .ipAddress(domain.getIpAddress())
                .userAgent(domain.getUserAgent())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionPersistenceAdapter.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
@RequiredArgsConstructor
public class UserSessionPersistenceAdapter implements UserSessionRepository {

    private final UserSessionJpaRepository jpaRepo;
    private final UserSessionPersistenceMapper mapper;

    @Override
    public Optional<UserSession> findByUser(User user) {
        return jpaRepo.findByUser(user).map(mapper::toDomain);
    }

    @Override
    public Optional<UserSession> findByRefreshToken(String refreshToken) {
        return jpaRepo.findByRefreshToken(refreshToken).map(mapper::toDomain);
    }

    @Override
    public void save(UserSession userSession) {
        UserSessionEntity entity = mapper.toEntity(userSession);
        jpaRepo.save(entity);
    }

    @Override
    public void delete(UserSession userSession) {
        UserSessionEntity entity = mapper.toEntity(userSession);
        jpaRepo.delete(entity);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionJpaRepository.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.user.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserSessionJpaRepository extends JpaRepository<UserSessionEntity, Long> {
    Optional<UserSessionEntity> findByUser(User user);

    Optional<UserSessionEntity> findByRefreshToken(String refreshToken);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/package-info.java ===
/**
 * Компоненты аутентификации и авторизации на основе JWT.
 *
 * <h3>Процесс аутентификации:</h3>
 * <ol>
 *   <li>Пользователь отправляет телефон/email + пароль</li>
 *   <li>Система валидирует данные через {@link com.logistics.userauth.auth.jwt.application.usecase.AuthenticateUserService}</li>
 *   <li>Генерируются access (15 мин) и refresh (7 дней) токены</li>
 *   <li>Refresh токен сохраняется в Redis с привязкой к IP/User-Agent</li>
 * </ol>
 *
 * <h3>Основные компоненты:</h3>
 * <table border="1">
 *   <tr><th>Компонент</th><th>Назначение</th></tr>
 *   <tr><td>JwtTokenProvider</td><td>Генерация и валидация токенов</td></tr>
 *   <tr><td>JwtAuthenticationFilter</td><td>Spring Security фильтр</td></tr>
 *   <tr><td>SignInService</td><td>Use case регистрации</td></tr>
 * </table>
 *
 * @since 1.0.0
 */
package com.logistics.userauth.auth;


=== backend/user-auth-service/src/test/java/com/logistics/userauth/UserAuthServiceApplicationTests.java ===
package com.logistics.userauth;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@IntegrationTest
@DisplayName("UserAuth Service: тесты загрузки контекста")
class UserAuthServiceApplicationTests {

    @Test
    @DisplayName("Должен успешно загрузить контекст приложения")
    void contextLoads() {
        // Проверяет, что все модули корректно интегрируются
    }
}


=== backend/user-auth-service/src/test/java/com/logistics/userauth/IntegrationTest.java ===
package com.logistics.userauth;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.junit.jupiter.Testcontainers;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@ActiveProfiles("test")
public @interface IntegrationTest {
}




=== backend/user-auth-service/src/test/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceMapperTest.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@DisplayName("AuditLogPersistenceMapper: юнит-тесты")
class AuditLogPersistenceMapperTest {

    @Mock
    private AuditActionTypeMapper actionTypeMapper;

    @Mock
    private UserPersistenceMapper userMapper;

    @InjectMocks
    private AuditLogPersistenceMapper mapper;

    private User testUser;
    private UserEntity testUserEntity;
    private AuditActionType testActionType;
    private AuditActionTypeEntity testActionTypeEntity;

    @BeforeEach
    void setUp() {
        testUser = User.builder().id(1L).firstName("Test").lastName("User").role(UserRole.CLIENT).build();
        testUserEntity = UserEntity.builder().id(1L).firstName("Test").lastName("User").role(UserRole.CLIENT).build();
        testActionType = AuditActionType.builder().id((short) 1).actionName("USER_LOGIN").build();
        testActionTypeEntity = AuditActionTypeEntity.builder().id((short) 1).actionName("USER_LOGIN").build();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("status", "active");
        AuditLog domain = AuditLog.builder()
                .id(1L)
                .user(testUser)
                .actionType(testActionType)
                .tableName("users")
                .newValues(newValues)
                .build();
        when(userMapper.toEntity(any(User.class))).thenReturn(testUserEntity);
        when(actionTypeMapper.toEntity(any(AuditActionType.class))).thenReturn(testActionTypeEntity);

        // When
        AuditLogEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo(1L);
        assertThat(entity.getUser()).isEqualTo(testUserEntity);
        assertThat(entity.getActionType()).isEqualTo(testActionTypeEntity);
        assertThat(entity.getNewValues()).containsEntry("status", "active");
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("role", "COURIER");
        AuditLogEntity entity = AuditLogEntity.builder()
                .id(2L)
                .user(testUserEntity)
                .actionType(testActionTypeEntity)
                .tableName("users")
                .recordId(100L)
                .newValues(newValues)
                .build();
        when(userMapper.toDomain(any(UserEntity.class))).thenReturn(testUser);
        when(actionTypeMapper.toDomain(any(AuditActionTypeEntity.class))).thenReturn(testActionType);

        // When
        AuditLog domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo(2L);
        assertThat(domain.getUser()).isEqualTo(testUser);
        assertThat(domain.getActionType()).isEqualTo(testActionType);
        assertThat(domain.getNewValues()).containsEntry("role", "COURIER");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserJpaRepository;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("AuditLogJpaRepository: интеграционные тесты")
class AuditLogJpaRepositoryIntegrationTest {
    @Autowired
    private AuditLogJpaRepository repository;

    @Autowired
    private UserJpaRepository userRepository;

    @Autowired
    private AuditActionJpaRepository actionTypeRepository;

    private UserEntity testUser;
    private AuditActionTypeEntity testActionType;

    @BeforeEach
    void setUp() {
        // Создаём тестового пользователя
        testUser = UserEntity.builder()
                .phone("+79991111111")
                .firstName("Test")
                .lastName("User")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        testUser = userRepository.save(testUser);

        // Создаём тип действия
        testActionType = AuditActionTypeEntity.builder()
                .actionName("TEST_ACTION")
                .category("TEST")
                .description("Test action")
                .build();

        testActionType = actionTypeRepository.save(testActionType);
    }

    @Test
    @Transactional
    @DisplayName("Должен сохранить и найти лог аудита по пользователю")
    void shouldSaveAndFindByUser() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("field", "value");

        Inet in = new Inet("192.168.1.1");

        AuditLogEntity auditLog = AuditLogEntity.builder()
                .user(testUser)
                .actionType(testActionType)
                .tableName("test_table")
                .recordId(1L)
                .actorIdentifier("test@example.com")
                .newValues(newValues)
                .performedAt(LocalDateTime.now())
                .ipAddress(in)
                .build();

        // When
        repository.save(auditLog);

        // Then
        List<AuditLogEntity> found = repository.findByUser(testUser);

        assertThat(found).isNotEmpty();
        assertThat(found.get(0).getActionType()).isEqualTo(testActionType);
        assertThat(found.get(0).getTableName()).isEqualTo("test_table");
        assertThat(found.get(0).getRecordId()).isEqualTo(1L);
        assertThat(found.get(0).getActorIdentifier()).isEqualTo("test@example.com");
        assertThat(found.get(0).getNewValues()).isEqualTo(newValues);
        assertThat(found.get(0).getIpAddress()).isEqualTo(in);
    }

    @Test
    @DisplayName("Должен сохранить лог аудита с корректными данными")
    void shouldSaveAuditLogWithCorrectData() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("status", "COMPLETED");
        newValues.put("amount", 1500.50);

        Inet in = new Inet("192.168.1.1");

        AuditLogEntity auditLog = AuditLogEntity.builder()
                .user(testUser)
                .actionType(testActionType)
                .tableName("orders")
                .recordId(999L)
                .actorIdentifier("admin@example.com")
                .newValues(newValues)
                .performedAt(LocalDateTime.now())
                .ipAddress(in)
                .build();

        // When
        AuditLogEntity saved = repository.save(auditLog);

        // Then
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getNewValues()).containsEntry("status", "COMPLETED");
        assertThat(saved.getNewValues()).containsEntry("amount", 1500.50);
    }
}


=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceAdapterIntegrationTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@Transactional
@DisplayName("UserPersistenceAdapter: интеграционные тесты")
class UserPersistenceAdapterIntegrationTest {

    @Autowired
    private UserPersistenceAdapter adapter;

    @Test
    @DisplayName("Должен сохранить и получить пользователя")
    void shouldSaveAndRetrieveUser() {
        // Given
        User user = User.builder()
                .email("adapter@test.com")
                .phone("+79993333333")
                .passwordHash("hashed123")
                .firstName("Adapter")
                .lastName("Test")
                .role(UserRole.DISPATCHER)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        // When
        adapter.save(user);

        // Then
        Optional<User> found = adapter.findByEmail("adapter@test.com");
        assertThat(found).isPresent();
        assertThat(found.get().getPhone()).isEqualTo("+79993333333");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("UserJpaRepository: интеграционные тесты")
class UserJpaRepositoryIntegrationTest {

    @Autowired
    private UserJpaRepository repository;

    @Test
    @DisplayName("Должен сохранить и найти User по ID")
    void shouldSaveAndFindById() {
        // Given
        UserEntity entity = UserEntity.builder()
                .email("test@example.com")
                .phone("1234567890")
                .passwordHash("hashedpassword")
                .firstName("John")
                .lastName("Doe")
                .role(UserRole.CLIENT)
                .build();

        UserEntity savedEntity = repository.save(entity);

        // When
        Optional<UserEntity> found = repository.findById(savedEntity.getId());

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getEmail()).isEqualTo("test@example.com");
        assertThat(found.get().getId()).isEqualTo(savedEntity.getId());
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceMapperTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.time.LocalDateTime;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("UserPersistenceMapper: юнит-тесты")
class UserPersistenceMapperTest {

    private UserPersistenceMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new UserPersistenceMapper();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        User domain = User.builder()
                .id(1L)
                .email("test@example.com")
                .phone("+79991234567")
                .passwordHash("hashedPassword123")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .facilityId(100L)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        // When
        UserEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo(1L);
        assertThat(entity.getEmail()).isEqualTo("test@example.com");
        assertThat(entity.getRole()).isEqualTo(UserRole.CLIENT);
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        UserEntity entity = UserEntity.builder()
                .id(2L)
                .email("courier@example.com")
                .phone("+79997654321")
                .passwordHash("hashedPassword456")
                .firstName("Петр")
                .lastName("Петров")
                .role(UserRole.COURIER)
                .facilityId(200L)
                .status(UserStatus.ACTIVE)
                .createdAt(LocalDateTime.now())
                .lastAccessedAt(LocalDateTime.now())
                .build();

        // When
        User domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo(2L);
        assertThat(domain.getEmail()).isEqualTo("courier@example.com");
        assertThat(domain.getRole()).isEqualTo(UserRole.COURIER);
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/common/web/GlobalExceptionHandlerTest.java ===
package com.logistics.userauth.common.web;

import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;

import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("GlobalExceptionHandler: обработка типичных ошибок")
class GlobalExceptionHandlerTest {

    private final GlobalExceptionHandler handler = new GlobalExceptionHandler();

    @Test
    @DisplayName("Должен возвращать 401 и INVALID_CREDENTIALS при BadCredentialsException")
    void shouldHandleBadCredentials() {
        BadCredentialsException ex = new BadCredentialsException("Invalid credentials");

        ResponseEntity<Map<String, Object>> response = handler.handleBadCredentials(ex);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("INVALID_CREDENTIALS");
        assertThat(response.getBody().get("message")).isEqualTo("Неверный телефон или пароль");
    }

    @Test
    @DisplayName("Должен возвращать 409 и CONFLICT при DataIntegrityViolationException")
    void shouldHandleDataIntegrityViolation() {
        DataIntegrityViolationException ex =
                new DataIntegrityViolationException("duplicate key value violates unique constraint");

        ResponseEntity<Map<String, Object>> response = handler.handleDataIntegrity(ex);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CONFLICT);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("CONFLICT");
        assertThat(response.getBody().get("message"))
                .isEqualTo("Пользователь с таким телефоном или email уже существует");
    }

    @Test
    @DisplayName("Должен возвращать 400 и VALIDATION_FAILED при ошибках Bean Validation")
    void shouldHandleValidationErrors() throws Exception {
        // имитируем DTO с ошибкой в поле "phone"
        class DummyDto {
            @SuppressWarnings("unused")
            private String phone;
        }

        DummyDto target = new DummyDto();
        BeanPropertyBindingResult bindingResult =
                new BeanPropertyBindingResult(target, "dummyDto");
        bindingResult.addError(new FieldError("dummyDto", "phone",
                "Неверный формат телефона"));

        MethodArgumentNotValidException ex =
                new MethodArgumentNotValidException(null, bindingResult);

        ResponseEntity<Map<String, Object>> response = handler.handleValidation(ex);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("VALIDATION_FAILED");

        @SuppressWarnings("unchecked")
        Map<String, String> fields = (Map<String, String>) response.getBody().get("fields");
        assertThat(fields).containsEntry("phone", "Неверный формат телефона");
    }

    @Test
    @DisplayName("Должен обработать InvalidRefreshTokenException и вернуть 401")
    void shouldHandleInvalidRefreshToken() {
        // Given
        var exception = new InvalidRefreshTokenException("Invalid refresh token");

        // When
        ResponseEntity<Map<String, Object>> response =
                handler.handleInvalidRefreshToken(exception);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("INVALID_REFRESH_TOKEN");
        assertThat(response.getBody().get("message")).isEqualTo("Invalid refresh token");
    }

    @Test
    @DisplayName("Должен обработать InvalidRefreshTokenException с сообщением об истечении срока")
    void shouldHandleExpiredRefreshToken() {
        // Given
        var exception = new InvalidRefreshTokenException("Refresh token has expired");

        // When
        ResponseEntity<Map<String, Object>> response =
                handler.handleInvalidRefreshToken(exception);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("INVALID_REFRESH_TOKEN");
        assertThat(response.getBody().get("message")).isEqualTo("Refresh token has expired");
    }

    @Test
    @DisplayName("Должен обработать InvalidRefreshTokenException с сообщением об отзыве")
    void shouldHandleRevokedRefreshToken() {
        // Given
        var exception = new InvalidRefreshTokenException("Refresh token has been revoked");

        // When
        ResponseEntity<Map<String, Object>> response =
                handler.handleInvalidRefreshToken(exception);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().get("error")).isEqualTo("INVALID_REFRESH_TOKEN");
        assertThat(response.getBody().get("message")).isEqualTo("Refresh token has been revoked");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RevokeRefreshTokenServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RevokeRefreshTokenService: юнит-тесты")
class RevokeRefreshTokenServiceTest {

    @Mock
    private UserSessionRepository repository;

    @InjectMocks
    private RevokeRefreshTokenService service;

    @Test
    @DisplayName("Должен отозвать валидный refresh токен")
    void shouldRevokeValidRefreshToken() {
        // Given
        var session = UserSession.builder()
                .id(1L)
                .refreshToken("valid-token")
                .revoked(false)
                .build();

        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken("valid-token")
                .build();

        when(repository.findByRefreshToken("valid-token"))
                .thenReturn(Optional.of(session));

        // When
        service.revoke(command);

        // Then
        verify(repository).save(argThat(s -> s.isRevoked()));
    }

    @Test
    @DisplayName("Должен выбросить исключение для несуществующего токена")
    void shouldThrowExceptionForNonExistentToken() {
        // Given
        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken("non-existent-token")
                .build();

        when(repository.findByRefreshToken("non-existent-token"))
                .thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.revoke(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid refresh token");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RefreshAccessTokenServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RefreshAccessTokenService: юнит-тесты")
class RefreshAccessTokenServiceTest {

    @Mock
    private UserSessionRepository repository;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private RefreshAccessTokenService service;

    @Test
    @DisplayName("Должен обновить токены для валидного refresh токена")
    void shouldRefreshTokensForValidRefreshToken() {
        // Given
        var user = User.builder()
                .id(1L)
                .phone("79991234567")
                .role(UserRole.CLIENT)
                .build();

        var session = UserSession.builder()
                .id(1L)
                .user(user)
                .refreshToken("old-refresh-token")
                .expiresAt(LocalDateTime.now().plusDays(1))
                .revoked(false)
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("old-refresh-token")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(repository.findByRefreshToken("old-refresh-token"))
                .thenReturn(Optional.of(session));
        when(tokenGenerator.generateAccessToken(user))
                .thenReturn("new-access-token");
        when(createRefreshTokenUseCase.create(any()))
                .thenReturn("new-refresh-token");

        // When
        var response = service.refresh(command);

        // Then
        assertThat(response.accessToken()).isEqualTo("new-access-token");
        assertThat(response.refreshToken()).isEqualTo("new-refresh-token");

        // Проверяем, что старая сессия отозвана
        verify(repository).save(argThat(s -> s.isRevoked()));

        // Проверяем, что создан новый refresh токен
        verify(createRefreshTokenUseCase).create(any());
    }

    @Test
    @DisplayName("Должен выбросить исключение для невалидного refresh токена")
    void shouldThrowExceptionForInvalidRefreshToken() {
        // Given
        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("invalid-token")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(repository.findByRefreshToken("invalid-token"))
                .thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid refresh token");
    }

    @Test
    @DisplayName("Должен выбросить исключение для отозванного токена")
    void shouldThrowExceptionForRevokedToken() {
        // Given
        var session = UserSession.builder()
                .refreshToken("revoked-token")
                .revoked(true)
                .expiresAt(LocalDateTime.now().plusDays(1))
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("revoked-token")
                .build();

        when(repository.findByRefreshToken("revoked-token"))
                .thenReturn(Optional.of(session));

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("revoked");
    }

    @Test
    @DisplayName("Должен выбросить исключение для истекшего токена")
    void shouldThrowExceptionForExpiredToken() {
        // Given
        var session = UserSession.builder()
                .refreshToken("expired-token")
                .revoked(false)
                .expiresAt(LocalDateTime.now().minusDays(1)) // Истёк вчера
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("expired-token")
                .build();

        when(repository.findByRefreshToken("expired-token"))
                .thenReturn(Optional.of(session));

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("expired");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/InternalCreateRefreshTokenServiceTest.java ===
// backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/InternalCreateRefreshTokenServiceTest.java
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("InternalCreateRefreshTokenService: юнит-тесты")
class InternalCreateRefreshTokenServiceTest {

    @Mock
    private UserSessionRepository sessionRepository;

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private InternalCreateRefreshTokenService service;

    @Test
    @DisplayName("Должен создать refresh токен для валидного пользователя")
    void shouldCreateRefreshTokenForValidUser() {
        // Given
        ReflectionTestUtils.setField(service, "refreshTokenTtlSeconds", 604800L);

        var user = User.builder()
                .id(1L)
                .phone("79991234567")
                .role(UserRole.CLIENT)
                .build();

        var command = CreateRefreshTokenCommand.builder()
                .userId(1L)
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        // When
        String refreshToken = service.create(command);

        // Then
        assertThat(refreshToken).isNotNull();
        assertThat(refreshToken).isNotEmpty();

        // Проверяем, что сессия сохранена
        ArgumentCaptor<UserSession> sessionCaptor = ArgumentCaptor.forClass(UserSession.class);
        verify(sessionRepository).save(sessionCaptor.capture());

        UserSession savedSession = sessionCaptor.getValue();
        assertThat(savedSession.getUser()).isEqualTo(user);
        assertThat(savedSession.getRefreshToken()).isEqualTo(refreshToken);
        assertThat(savedSession.isRevoked()).isFalse();
        assertThat(savedSession.getExpiresAt()).isAfter(LocalDateTime.now());
    }

    @Test
    @DisplayName("Должен выбросить исключение, если пользователь не найден")
    void shouldThrowExceptionWhenUserNotFound() {
        // Given
        var command = CreateRefreshTokenCommand.builder()
                .userId(999L)
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(userRepository.findById(999L)).thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.create(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("User not found");
    }

    @Test
    @DisplayName("Должен создать токен с IP и User-Agent")
    void shouldCreateTokenWithIpAndUserAgent() {
        // Given
        ReflectionTestUtils.setField(service, "refreshTokenTtlSeconds", 604800L);

        var user = User.builder().id(1L).build();
        var command = CreateRefreshTokenCommand.builder()
                .userId(1L)
                .ipAddress("10.0.0.1")
                .userAgent("Chrome/120")
                .build();

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        // When
        service.create(command);

        // Then
        ArgumentCaptor<UserSession> captor = ArgumentCaptor.forClass(UserSession.class);
        verify(sessionRepository).save(captor.capture());

        UserSession session = captor.getValue();
        assertThat(session.getIpAddress()).isNotNull();
        assertThat(session.getUserAgent()).isEqualTo("Chrome/120");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/AuthenticateUserServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@DisplayName("AuthenticateUserService: юнит-тесты")
public class AuthenticateUserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private AuthenticateUserService service;

    private User buildUser() {
        return User.builder()
                .id(1L)
                .email("test@example.com")
                .phone("79991234567")
                .passwordHash("HASH")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }

    @Test
    @DisplayName("Должен аутентифицировать пользователя и вернуть JWT")
    void shouldAuthenticateUserAndReturnJwt() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79991234567")
                .password("Password123!")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        var user = buildUser();

        when(userRepository.findByPhone("79991234567")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("Password123!", "HASH")).thenReturn(true);
        when(tokenGenerator.generateAccessToken(any(User.class))).thenReturn("jwt-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");
        // when
        JwtAuthenticationResponse response = service.authenticate(command);

        // then
        assertThat(response).isNotNull();
        assertThat(response.accessToken()).isEqualTo("jwt-token");
        assertThat(response.refreshToken()).isEqualTo("refresh-token");

        verify(createRefreshTokenUseCase).create(any());
    }

    @Test
    @DisplayName("Должен бросить BadCredentialsException при неверном пароле")
    void shouldThrowWhenPasswordInvalid() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79991234567")
                .password("wrong")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        var user = buildUser();

        when(userRepository.findByPhone("79991234567")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("wrong", "HASH")).thenReturn(false);

        // then
        assertThatThrownBy(() -> service.authenticate(command))
                .isInstanceOf(BadCredentialsException.class);
    }

    @Test
    @DisplayName("Должен бросить BadCredentialsException, если пользователь не найден")
    void shouldThrowWhenUserNotFound() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79990000000")
                .password("Password123!")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        when(userRepository.findByPhone("79990000000")).thenReturn(Optional.empty());

        // then
        assertThatThrownBy(() -> service.authenticate(command))
                .isInstanceOf(BadCredentialsException.class);
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RegisterUserServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RegisterUserService: юнит-тесты")
public class RegisterUserServiceTest {


    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private RegisterUserService service;

    @Test
    @DisplayName("Должен зарегистрировать пользователя и вернуть JWT-токен")
    void shouldRegisterUserAndReturnJwt() {
        // given
        var command = RegisterUserCommand.builder()
                .email("test@example.com")
                .phone("79991234567")
                .rawPassword("rawPass")
                .firstName("Ivan")
                .lastName("Ivanov")
                .middleName("Ivanovich")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        var savedUser = User.builder()
                .id(1L)
                .email(command.email())
                .phone(command.phone())
                .passwordHash("encodedPass")
                .firstName(command.firstName())
                .lastName(command.lastName())
                .middleName(command.middleName())
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        when(passwordEncoder.encode("rawPass")).thenReturn("encodedPass");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        when(tokenGenerator.generateAccessToken(savedUser)).thenReturn("access-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");
        // when
        var response = service.register(command);

        // then
        assertThat(response.accessToken()).isEqualTo("access-token");
        assertThat(response.refreshToken()).isEqualTo("refresh-token");

        verify(userRepository).save(any(User.class));
        verify(tokenGenerator).generateAccessToken(savedUser);
        verify(createRefreshTokenUseCase).create(any());
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/JwtTokenProviderTest.java ===
package com.logistics.userauth.auth.jwt.application;


import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

@DisplayName("JwtTokenProvider: юнит‑тесты")
public class JwtTokenProviderTest {

    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setUp() {
        jwtTokenProvider = new JwtTokenProvider();
        TestReflection.setField(jwtTokenProvider, "secret", "test-secret-key-test-secret-key-123456");
        TestReflection.setField(jwtTokenProvider, "accessTokenTtlSeconds", 3600_000L);
    }

    private User buildUser() {
        return User.builder()
                .id(42L)
                .email("test@example.com")
                .phone("79991234567")
                .passwordHash("HASH")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }

    @Test
    @DisplayName("Должен генерировать и валидировать JWT и извлекать userId")
    void shouldGenerateAndValidateToken() {
        User user = buildUser();

        String token = jwtTokenProvider.generateAccessToken(user);

        assertThat(token).isNotBlank();
        assertThat(jwtTokenProvider.isTokenValid(token)).isTrue();

        Long userId = jwtTokenProvider.extractUserId(token);
        assertThat(userId).isEqualTo(42L);
    }

    /**
     * Вспомогательный класс для установки приватных полей через reflection,
     * чтобы не тянуть Spring в юнит‑тест.
     */
    static class TestReflection {
        static void setField(Object target, String fieldName, Object value) {
            try {
                var field = target.getClass().getDeclaredField(fieldName);
                field.setAccessible(true);
                field.set(target, value);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/adapter/in/web/AuthControllerIntegrationTest.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

import static org.hamcrest.Matchers.notNullValue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@IntegrationTest
@AutoConfigureMockMvc
@DisplayName("AuthController: интеграционные тесты")
class AuthControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("Регистрация и логин должны работать сквозным сценарием")
    void shouldRegisterAndLogin() throws Exception {
        // 1) Регистрация
        String signUpJson = """
            {
              "email": "test@example.com",
              "phone": "79991234567",
              "password": "Password123!",
              "firstName": "Иван",
              "lastName": "Иванов",
              "middleName": "Иванович"
            }
            """;

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(signUpJson))
                .andExpect(status().isCreated());

        // 2) Логин
        String signInJson = """
            {
              "phone": "79991234567",
              "password": "Password123!"
            }
            """;

        mockMvc.perform(post("/auth/sign-in")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(signInJson))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").exists())
        ;
    }

    @Test
    @DisplayName("Должен зарегистрировать пользователя и вернуть токены")
    void shouldRegisterUserAndReturnTokens() throws Exception {
        // Given
        var signUpRequest = new SignUpRequest(
                "newuser@example.com",
                "79991234567",
                "Password123!",
                "John",
                "Doe",
                "Smith"
        );

        // When & Then
        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен авторизовать пользователя и вернуть токены")
    void shouldAuthenticateUserAndReturnTokens() throws Exception {
        // Given - сначала регистрируем
        var signUpRequest = new SignUpRequest(
                "logintest@example.com",
                "79997654321",
                "Password123!",
                "Jane",
                "Doe",
                "Smith"
        );

        mockMvc.perform(post("/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(signUpRequest)));

        // When - логинимся
        var signInRequest = new SignInRequest(
                "79997654321",
                null,
                "Password123!"
        );

        // Then
        mockMvc.perform(post("/auth/sign-in")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signInRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен обновить access токен с помощью refresh токена")
    void shouldRefreshAccessToken() throws Exception {
        // Given - регистрируем и получаем токены
        var signUpRequest = new SignUpRequest(
                "refreshtest@example.com",
                "79995555555",
                "Password123!",
                "Refresh",
                "Test",
                "User"
        );

        MvcResult registerResult = mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andReturn();

        String responseBody = registerResult.getResponse().getContentAsString();
        var authResponse = objectMapper.readTree(responseBody);
        String refreshToken = authResponse.get("refreshToken").asText();

        // When - обновляем токен
        var refreshRequest = new RefreshTokenRequest(refreshToken);

        // Then
        mockMvc.perform(post("/auth/refresh")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(refreshRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен отозвать refresh токен при logout")
    void shouldRevokeRefreshTokenOnLogout() throws Exception {
        // Given - регистрируем
        var signUpRequest = new SignUpRequest(
                "logouttest@example.com",
                "79996666666",
                "Password123!",
                "Logout",
                "Test",
                "User"
        );

        MvcResult registerResult = mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andReturn();

        String responseBody = registerResult.getResponse().getContentAsString();
        var authResponse = objectMapper.readTree(responseBody);
        String refreshToken = authResponse.get("refreshToken").asText();

        // When - делаем logout
        var logoutRequest = new RefreshTokenRequest(refreshToken);

        mockMvc.perform(post("/auth/logout")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(logoutRequest)))
                .andExpect(status().isNoContent());

        // Then - пытаемся использовать отозванный токен
        mockMvc.perform(post("/auth/refresh")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(logoutRequest)))
                .andExpect(status().isUnauthorized()); // Должна быть ошибка
    }

    @Test
    @DisplayName("Должен вернуть ошибку для невалидного refresh токена")
    void shouldReturnErrorForInvalidRefreshToken() throws Exception {
        // Given
        var refreshRequest = new RefreshTokenRequest("invalid-token-123");

        // Then
        mockMvc.perform(post("/auth/refresh")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(refreshRequest)))
                .andExpect(status().isUnauthorized());
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserJpaRepository;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("UserSessionJpaRepository: интеграционные тесты")
class UserSessionJpaRepositoryIntegrationTest {

    @Autowired
    private UserSessionJpaRepository repository;

    @Autowired
    private UserJpaRepository userRepository;

    private UserEntity testUser;

    @BeforeEach
    void setUp() {
        // Создаём и сохраняем тестового пользователя
        testUser = UserEntity.builder()
                .phone("+79992222222")
                .firstName("Session")
                .lastName("User")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        testUser = userRepository.save(testUser);
    }

    @Test
    @Transactional
    @DisplayName("Должен сохранить и найти сессию по токену")
    void shouldSaveAndFindByRefreshToken() {

        Inet in = new Inet("192.168.1.10");
        // Given
        UserSessionEntity session = UserSessionEntity.builder()
                .user(testUser)
                .refreshToken("unique-token-12345")
                .expiresAt(LocalDateTime.now().plusHours(2))
                .createdAt(LocalDateTime.now())
                .ipAddress(in)
                .userAgent("Mozilla/5.0")
                .build();

        // When
        repository.save(session);

        // Then
        Optional<UserSessionEntity> found = repository.findByRefreshToken("unique-token-12345");

        assertThat(found).isPresent();
        assertThat(found.get().getUser()).isEqualTo(testUser);
        assertThat(found.get().getIpAddress()).isEqualTo(in);
        assertThat(found.get().getUserAgent()).isEqualTo("Mozilla/5.0");
    }

    @Test
    @Transactional
    @DisplayName("Должен вернуть пустой Optional для несуществующего токена")
    void shouldReturnEmptyForNonExistentToken() {
        // When
        Optional<UserSessionEntity> found = repository.findByRefreshToken("non-existent-token");

        // Then
        assertThat(found).isEmpty();
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/validation/PasswordValidator.java ===
package com.logistics.shared.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

/**
 * Валидатор для аннотации {@link Password}.
 *
 * <h2>Реализованные проверки</h2>
 * <ol>
 *   <li>Проверка на null</li>
 *   <li>Проверка длины (минимум 8 символов)</li>
 *   <li>Проверка на наличие заглавной буквы (?=.*[A-Z])</li>
 *   <li>Проверка на наличие строчной буквы (?=.*[a-z])</li>
 *   <li>Проверка на наличие цифры (?=.*\\\\d)</li>
 *   <li>Проверка на наличие спецсимвола (?=.*[^\\\\w\\\\s])</li>
 * </ol>
 *
 * <h2>Regex</h2>
 * ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[^\\\\w\\\\s]).{8,}$
 *
 * Использует positive lookahead assertions для проверки всех условий.
 *
 * <h2>Примеры</h2>
 * <pre>
 * PasswordValidator validator = new PasswordValidator();
 *
 * validator.isValid(\"Password123!\", null);  // true
 * validator.isValid(\"password123!\", null);  // false (нет заглавной)
 * validator.isValid(\"Password123\", null);   // false (нет спецсимвола)
 * validator.isValid(\"Pass1!\", null);        // false (меньше 8 символов)
 * validator.isValid(null, null);             // false
 * </pre>
 *
 * @implements ConstraintValidator<Password, String>
 */
public class PasswordValidator implements ConstraintValidator<Password, String> {

    // Минимум 8 символов, >=1 строчная, >=1 заглавная, >=1 цифра, >=1 спецсимвол
    private static final String REGEX =
            "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$";

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return false;
        }
        return value.matches(REGEX);
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/validation/Phone.java ===
package com.logistics.shared.validation;


import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Аннотация для валидации телефонных номеров.
 *
 * <h2>Поддерживаемые форматы</h2>
 * <ul>
 *   <li>Россия: +7XXXXXXXXXX, 8XXXXXXXXXX, +7 (XXX) XXX-XX-XX</li>
 *   <li>Беларусь: +375XXXXXXXXX, 376XXXXXXXXX</li>
 *   <li>Казахстан: +77XXXXXXXXX, 78XXXXXXXXX</li>
 * </ul>
 *
 * <h2>Примеры использования</h2>
 * <pre>
 * \\@Phone
 * private String phone;
 *
 * \\@Phone(message = \"Неверный номер телефона\")
 * String phone;
 * </pre>
 *
 * <h2>Примеры валидных номеров</h2>
 * - 79991234567 (Россия)
 * - +7 (999) 123-45-67 (Россия с форматированием)
 * - +375291234567 (Беларусь)
 * - 77011234567 (Казахстан)
 *
 * <h2>Примеры невалидных номеров</h2>
 * - 123 (слишком короткий)
 * - +1 999 123 4567 (неподдерживаемая страна)
 * - 79991234 (неполный номер)
 *
 * @see PhoneValidator для реализации валидации
 */
@Documented
@Constraint(validatedBy = PhoneValidator.class)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Phone {

    String message() default "Неверный формат телефона";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}



=== backend/shared-library/src/main/java/com/logistics/shared/validation/PhoneValidator.java ===
package com.logistics.shared.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;


/**
 * Валидатор для аннотации {@link Phone}.
 *
 * <h2>Алгоритм валидации</h2>
 * <ol>
 *   <li>Проверяет, что значение не null и не пусто</li>
 *   <li>Удаляет пробелы, дефисы и скобки</li>
 *   <li>Сверяет нормализованный номер с регулярным выражением</li>
 *   <li>Возвращает true если совпадает, false в противном случае</li>
 * </ol>
 *
 * <h2>Regex парттерны</h2>
 * - Россия: ^(?:\\\\+7|7)\\\\d{10}$ (11-12 цифр)
 * - Беларусь: ^(?:\\\\+375|375)\\\\d{9}$ (12-13 цифр)
 * - Казахстан: ^(?:\\\\+77|77)\\\\d{9}$ (11-12 цифр)
 *
 * <h2>Примеры</h2>
 * <pre>
 * PhoneValidator validator = new PhoneValidator();
 *
 * validator.isValid(\"79991234567\", null);      // true (Россия)
 * validator.isValid(\"+7 (999) 123-45-67\", null); // true (Россия форматированный)
 * validator.isValid(\"+375291234567\", null);    // true (Беларусь)
 * validator.isValid(\"123\", null);              // false (слишком короткий)
 * validator.isValid(null, null);                // false (null)
 * </pre>
 *
 * @implements ConstraintValidator<Phone, String>
 */
public class PhoneValidator implements ConstraintValidator<Phone, String> {


    private static final String REGEX =
            "^(?:\\+7|8)\\d{10}$" +              // Россия
                    "|^(?:\\+375|376)\\d{9}$" +         // Беларусь
                    "|^(?:\\+77|78)\\d{9}$";            // Казахстан

    /**
     * Валидирует телефонный номер.
     *
     * @param value Телефонный номер для валидации
     * @param context Контекст валидации
     * @return true если номер валиден, false в противном случае
     */
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isBlank()) {
            return false;
        }
        String normalized = value.replaceAll("[\\s\\-()]", "");
        return normalized.matches(REGEX);
    }
}




=== backend/shared-library/src/main/java/com/logistics/shared/validation/package-info.java ===
/**
 * Пакет с кастомными аннотациями и валидаторами для доменных моделей.
 *
 * Реализует интеграцию с Jakarta Bean Validation (ранее javax.validation).
 *
 * Доступные валидаторы:
 * <ul>
 *   <li><b>@Phone</b> - Номер телефона (РФ: +7..., Беларусь: +375..., Казахстан: +77...)</li>
 *   <li><b>@Password</b> - Сложный пароль (8+ символов, буквы, цифры, спецсимволы)</li>
 * </ul>
 *
 * Пример использования:
 * <pre>{@code
 * @Data
 * public class User {
 *     @Email
 *     private String email;
 *
 *     @Phone
 *     private String phone;
 *
 *     @Password
 *     private String password;
 * }
 *
 * // Валидация автоматическая при @Valid
 * @PostMapping("/register")
 * public void register(@Valid @RequestBody SignUpRequest request) { }
 * }</pre>
 *
 * @see jakarta.validation.Constraint
 * @see jakarta.validation.ConstraintValidator
 */
package com.logistics.shared.validation;


=== backend/shared-library/src/main/java/com/logistics/shared/validation/Password.java ===
package com.logistics.shared.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Аннотация для валидации сложности пароля.
 *
 * <h2>Требования к паролю</h2>
 * <ul>
 *   <li>Минимум 8 символов</li>
 *   <li>Минимум одна заглавная буква (A-Z)</li>
 *   <li>Минимум одна строчная буква (a-z)</li>
 *   <li>Минимум одна цифра (0-9)</li>
 *   <li>Минимум один спецсимвол (!@#$%^&*)</li>
 * </ul>
 *
 * <h2>Примеры использования</h2>
 * <pre>
 * //@Password
 * private String password;
 *
 * //@Password(message = \"Пароль слишком слабый\")
 * String password;
 * </pre>
 *
 * <h2>Примеры валидных паролей</h2>
 * <ul>
 *   <li>Password123!</li>
 *   <li>Qwerty1@</li>
 *   <li>MyP@ssw0rd</li>
 *   <li>Admin#2025!</li>
 * </ul>
 *
 * <h2>Примеры невалидных паролей</h2>
 * <ul>
 *   <li>password123 (нет заглавной и спецсимвола)</li>
 *   <li>Password! (нет цифр)</li>
 *   <li>Pass1! (меньше 8 символов)</li>
 *   <li>PASSWORD123! (нет строчных)</li>
 * </ul>
 *
 * @see PasswordValidator для реализации валидации
 */
@Documented
@Constraint(validatedBy = PasswordValidator.class)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Password {

    String message() default
            "Пароль должен содержать минимум 8 символов, " +
                    "включая цифру, заглавную и строчную букву и спецсимвол";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}




=== backend/shared-library/src/main/java/com/logistics/shared/SharedLibraryConfiguration.java ===
package com.logistics.shared;

import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

/**
 * Конфигурация Spring для shared-library модуля.
 *
 * <h2>Назначение</h2>
 * Регистрирует бины и конфигурирует компоненты shared-library,
 * которые будут использоваться другими микросервисами.
 *
 * <h2>Использование в других сервисах</h2>
 * <pre>
 * \\@SpringBootApplication
 * \\@ComponentScan(basePackages = {
 *     \"com.myservice\",
 *     \"com.logistics.shared\"
 * })
 * \\@EnableJpaRepositories(basePackages = \"com.logistics.shared\")
 * public class MyServiceApplication { }
 * </pre>
 *
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@Configuration
@EntityScan("com.logistics.shared")
@EnableJpaRepositories("com.logistics.shared")
public class SharedLibraryConfiguration {

}


=== backend/shared-library/src/main/java/com/logistics/shared/OpenApiConfig.java ===
package com.logistics.shared;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Конфигурация OpenAPI/Swagger для всех микросервисов.
 *
 * <h2>Назначение</h2>
 * Предоставляет единую конфигурацию документации API для всех сервисов.
 * Каждый микросервис импортирует эту конфигурацию через @Import,
 * чтобы иметь единообразный вид Swagger UI.
 *
 * <h2>Использование</h2>
 * <pre>
 * \\@SpringBootApplication
 * \\@Import(OpenApiConfig.class)
 * public class UserAuthServiceApplication { }
 * </pre>
 *
 * После импорта Swagger UI будет доступен по:
 * http://localhost:8080/api/v1/swagger-ui.html
 *
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Logistics System API")
                        .version("1.0.0")
                        .description("REST API для системы логистики и управления доставкой")
                        .contact(new Contact()
                                .name("Logistics Development Team")
                                .email("dev@logistics.com")
                                .url("https://logistics.com")))
                .addSecurityItem(new SecurityRequirement().addList("Bearer JWT"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("Bearer JWT",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")
                                        .description("JWT access token для аутентификации. Вставьте токен без 'Bearer ' префикса.")));
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/package-info.java ===
/**
 * Общая библиотека для всех микросервисов логистической системы.
 *
 * Содержит переиспользуемые компоненты:
 * <ul>
 *   <li><b>validation</b> - Кастомные аннотации для валидации (@Phone, @Password)</li>
 *   <li><b>audit_action</b> - Типизация и управление типами аудиторских действий</li>
 *   <li><b>redis</b> - Общие настройки Redis</li>
 * </ul>
 *
 * Как использовать в другом микросервисе:
 * <pre>{@code
 * <dependency>
 *     <groupId>com.logistics</groupId>
 *     <artifactId>shared-library</artifactId>
 *     <version>1.0.0</version>
 * </dependency>
 *
 * // В главном классе:
 * @ComponentScan(basePackages = {"com.logistics.myservice", "com.logistics.shared"})
 * @EntityScan(basePackages = {"com.logistics.myservice", "com.logistics.shared"})
 * @EnableJpaRepositories(basePackages = {"com.logistics.myservice", "com.logistics.shared"})
 * }</pre>
 */
package com.logistics.shared;


=== backend/shared-library/src/main/java/com/logistics/shared/redis/service/RateLimiterService.java ===
package com.logistics.shared.redis.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Duration;

/**
 * Rate limiting через Redis для защиты от брутфорса.
 */
@Service
@RequiredArgsConstructor
public class RateLimiterService {

    private final RedisService redisService;

    /**
     * Проверяет, не превышен ли лимит запросов.
     *
     * @param identifier Уникальный идентификатор (IP, userId, phone)
     * @param maxAttempts Максимум попыток
     * @param window Временное окно
     * @return true если лимит превышен
     */
    public boolean isRateLimited(String identifier, int maxAttempts, Duration window) {
        String key = "rate-limit:" + identifier;
        Long attempts = redisService.incrementWithTtl(key, window);
        return attempts != null && attempts > maxAttempts;
    }

    /**
     * Сбросить счетчик попыток.
     */
    public void reset(String identifier) {
        redisService.delete("rate-limit:" + identifier);
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/redis/service/package-info.java ===
/**
 * Утилиты для работы с Redis
 * Содержит:
 * <ul>
 *   <li><b>RedisService</b> - Утилита для взаимодействия с Redis</li>
 * </ul>
 */
package com.logistics.shared.redis.service;


=== backend/shared-library/src/main/java/com/logistics/shared/redis/service/RedisService.java ===
package com.logistics.shared.redis.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

/**
 * Удобный сервис для работы с Redis.
 * Предоставляет упрощенные методы для частых операций.
 */
@Service
@RequiredArgsConstructor
public class RedisService {

    private final RedisTemplate<String, Object> redisTemplate;

    /**
     * Сохранить значение с TTL.
     */
    public void set(String key, Object value, Duration ttl) {
        redisTemplate.opsForValue().set(key, value, ttl);
    }

    /**
     * Получить значение.
     */
    public <T> Optional<T> get(String key, Class<T> type) {
        Object value = redisTemplate.opsForValue().get(key);
        return Optional.ofNullable(type.cast(value));
    }

    /**
     * Удалить ключ.
     */
    public boolean delete(String key) {
        return Boolean.TRUE.equals(redisTemplate.delete(key));
    }

    /**
     * Проверить существование ключа.
     */
    public boolean exists(String key) {
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }

    /**
     * Получить оставшееся время жизни ключа.
     */
    public Optional<Long> getTtl(String key, TimeUnit unit) {
        Long ttl = redisTemplate.getExpire(key, unit);
        return ttl != null && ttl >= 0 ? Optional.of(ttl) : Optional.empty();
    }

    /**
     * Инкрементировать счетчик.
     */
    public Long increment(String key) {
        return redisTemplate.opsForValue().increment(key);
    }

    /**
     * Инкрементировать с установкой TTL при первом создании.
     */
    public Long incrementWithTtl(String key, Duration ttl) {
        Long value = redisTemplate.opsForValue().increment(key);
        if (value != null && value == 1) {
            redisTemplate.expire(key, ttl);
        }
        return value;
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/redis/package-info.java ===
/**
 * Пакет c настройками Redis и утилитами для работы с ним
 */
package com.logistics.shared.redis;


=== backend/shared-library/src/main/java/com/logistics/shared/redis/config/RedisProperties.java ===
package com.logistics.shared.redis.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * Дополнительные настройки Redis для Logistics System.
 */
@Data
@Component
@ConfigurationProperties(prefix = "logistics.redis")
public class RedisProperties {

    /**
     * Включить/выключить Redis для всего приложения.
     */
    private boolean enabled = true;

    /**
     * Префикс для всех ключей (например, "logistics:user-auth:")
     */
    private String keyPrefix = "logistics";

    /**
     * TTL по умолчанию для кэшей (в минутах)
     */
    private long defaultCacheTtlMinutes = 60;

    /**
     * Настройки для SMS кодов
     */
    private SmsCodeProperties smsCode = new SmsCodeProperties();

    @Data
    public static class SmsCodeProperties {
        private String keyPrefix = "sms:verification:";
        private long ttlMinutes = 5;
        private int maxAttempts = 3;
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/redis/config/RedisConfig.java ===
package com.logistics.shared.redis.config;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.databind.jsontype.PolymorphicTypeValidator;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Общая конфигурация Redis для всех микросервисов.
 *
 * <h2>Использование</h2>
 * Добавьте аннотацию @EnableSharedRedis в главный класс приложения:
 * <pre>
 * {@code
 * @SpringBootApplication
 * @EnableSharedRedis
 * public class UserAuthServiceApplication {
 *     public static void main(String[] args) {
 *         SpringApplication.run(UserAuthServiceApplication.class, args);
 *     }
 * }
 * }
 * </pre>
 */
@Configuration
@EnableCaching
@ConditionalOnProperty(name = "logistics.redis.enabled", havingValue = "true", matchIfMissing = true)
public class RedisConfig {

    /**
     * RedisTemplate для работы с объектами (JSON сериализация).
     * Используется для кэширования сложных объектов, хранения SMS кодов и т.д.
     */

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory,
                                                       ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        StringRedisSerializer keySerializer = new StringRedisSerializer();

        // ВАЖНО: отдельный ObjectMapper для Redis, чтобы не ломать HTTP JSON
        ObjectMapper redisMapper = objectMapper.copy();

        PolymorphicTypeValidator ptv = BasicPolymorphicTypeValidator.builder()
                .allowIfSubType("com.logistics.")   // ваши доменные классы
                .allowIfSubType("java.time.")       // LocalDateTime и т.п.
                .allowIfSubType("java.util.")       // Map/List, если где-то нужно
                .build();

        redisMapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);

        GenericJackson2JsonRedisSerializer valueSerializer = new GenericJackson2JsonRedisSerializer(redisMapper);

        template.setKeySerializer(keySerializer);
        template.setHashKeySerializer(keySerializer);
        template.setValueSerializer(valueSerializer);
        template.setHashValueSerializer(valueSerializer);

        template.afterPropertiesSet();
        return template;
    }

    /**
     * StringRedisTemplate для работы с простыми строковыми значениями.
     * Используется для rate limiting, счетчиков и простых флагов.
     */
    @Bean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/redis/config/package-info.java ===
/**
 * Настройки Redis
 * Содержит:
 * <ul>
 *   <li><b>RedisConfig</b> - Общая конфигурация Redis</li>
 *   <li><b>RedisProperties</b> - Дополнительные настройки Redis</li>
 * </ul>
 */
package com.logistics.shared.redis.config;


=== backend/shared-library/src/main/java/com/logistics/shared/redis/EnableRedis.java ===
package com.logistics.shared.redis;

import com.logistics.shared.redis.config.RedisConfig;
import com.logistics.shared.redis.config.RedisProperties;
import org.springframework.context.annotation.Import;

import java.lang.annotation.*;

/**
 * Подключает общую конфигурацию Redis из shared-library.
 *
 * <h2>Использование:</h2>
 * <pre>
 * {@code
 * @SpringBootApplication
 * @EnableSharedRedis
 * public class UserAuthServiceApplication {
 *     // ...
 * }
 * }
 * </pre>
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({RedisConfig.class, RedisProperties.class})
public @interface EnableRedis {
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionTypeMapper.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import org.springframework.stereotype.Component;

/**
 * MapStruct-подобный маппер для преобразования между Domain и Entity.
 *
 * <h2>Назначение</h2>
 * Конвертирует между двумя представлениями одного объекта:
 * - AuditActionType (доменная модель, не привязана к БД)
 * - AuditActionTypeEntity (JPA entity, привязана к БД)
 *
 * @see AuditActionType для доменной модели
 * @see AuditActionTypeEntity для JPA entity
 */
@Component
public class AuditActionTypeMapper {

    public AuditActionType toDomain(AuditActionTypeEntity entity) {
        return AuditActionType.builder()
                .id(entity.getId())
                .actionName(entity.getActionName())
                .category(entity.getCategory())
                .description(entity.getDescription())
                .build();
    }

    public AuditActionTypeEntity toEntity(AuditActionType domain) {
        return AuditActionTypeEntity.builder()
                .id(domain.getId())
                .actionName(domain.getActionName())
                .category(domain.getCategory())
                .description(domain.getDescription())
                .build();
    }
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionJpaRepository.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.audit_action.AuditActionTypeService;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * Spring Data JPA репозиторий для работы с типами аудит-действий.
 *
 * <h2>Примеры использования</h2>
 * <pre>
 * Optional<AuditActionTypeEntity> entity = repo.findById(1);
 * Optional<AuditActionTypeEntity> entity = repo.findByActionName(\"USER_LOGIN\");
 * </pre>
 *
 * @see AuditActionTypeEntity для сущности
 * @see AuditActionTypeService для бизнес-логики
 */
@Repository
public interface AuditActionJpaRepository extends JpaRepository<AuditActionTypeEntity, Integer> {

    Optional<AuditActionTypeEntity> findByCategory(String category);

    Optional<AuditActionTypeEntity> findByActionName(String actionName);
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/package-info.java ===
/**
 * Пакет инфраструктурного уровня для работы с типами аудиторских действий через JPA.
 *
 * Содержит:
 * <ul>
 *   <li><b>AuditActionTypeEntity</b> - JPA сущность для БД</li>
 *   <li><b>AuditActionJpaRepository</b> - Spring Data JPA репозиторий</li>
 *   <li><b>AuditActionTypeMapper</b> - Преобразование Entity ↔ Domain</li>
 * </ul>
 */
package com.logistics.shared.audit_action.persistence;


=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/persistence/AuditActionTypeEntity.java ===
package com.logistics.shared.audit_action.persistence;

import jakarta.persistence.*;
import lombok.*;

/**
 * JPA сущность для хранения типов аудит-действий в БД.
 *
 * <h2>Таблица в БД</h2>
 * Schema: shared_data
 * Table: audit_action_types
 *
 * @see AuditActionJpaRepository для работы с БД
 * @see AuditActionTypeMapper для преобразования Domain ↔ Entity
 */
@Entity
@Table(
        name = "audit_action_types",
        schema = "shared_data",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "action_name")
        },
        indexes = {
//                @Index(columnList = "action_name", name = "audit_action_types_action_name_key")
        }
)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AuditActionTypeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "audit_action_type_seq")
    @SequenceGenerator(
            name = "audit_action_type_seq",
            sequenceName = "audit_action_types_action_type_id_seq",
            schema = "shared_data",
            allocationSize = 1
    )
    @Column(name = "action_type_id")
    private Short id;

    @Column(name = "action_name", nullable = false)
    private String actionName;

    @Column(name = "category", nullable = false)
    private String category;

    @Column(name = "description")
    private String description;

}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/package-info.java ===
/**
 * Пакет управления типами аудиторских действий.
 *
 * Предоставляет сервис для получения типизированных описаний действий пользователей
 * (например, "USER_LOGIN", "ORDER_CREATED" и т.д.).
 *
 * Используется в других микросервисах для логирования:
 * <pre>{@code
 * @Component
 * public class OrderService {
 *     private final AuditActionTypeService auditService;
 *
 *     public void createOrder(...) {
 *         // Создаём заказ
 *         // ...
 *
 *         // Логируем действие
 *         var actionType = auditService.getActionTypeActionName("ORDER_CREATED");
 *         auditLog.save(AuditLog.builder()
 *             .actionType(actionType.get())
 *             .user(user)
 *             .build());
 *     }
 * }
 * }</pre>
 */
package com.logistics.shared.audit_action;


=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/domain/AuditActionType.java ===
package com.logistics.shared.audit_action.domain;

import lombok.*;

/**
 * Доменная сущность для типа аудит-действия.
 *
 * <h2>Назначение</h2>
 * Описывает категорию действия, которое можно залогировать в системе:
 * - USER_LOGIN (категория: AUTHENTICATION)
 * - ORDER_CREATED (категория: ORDER_MANAGEMENT)
 * - PROFILE_UPDATED (категория: USER_MANAGEMENT)
 *
 * <h2>Структура</h2>
 * - id: короткий уникальный идентификатор типа
 * - actionName: машиночитаемое имя (USER_LOGIN, ORDER_CREATED)
 * - category: категория для группировки (AUTHENTICATION, ORDER_MANAGEMENT)
 * - description: читаемое описание на русском
 *
 * <h2>Примеры</h2>
 * <pre>
 * AuditActionType userLogin = AuditActionType.builder()
 *   .id((short) 1)
 *   .actionName(\"USER_LOGIN\")
 *   .category(\"AUTHENTICATION\")
 *   .description(\"Пользователь вошел в систему\")
 *   .build();
 * </pre>
 *
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AuditActionType {

    private short id;

    private String actionName;

    private String category;

    private String description;
}



=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/domain/package-info.java ===
/**
 * Пакет доменной модели типов аудиторских действий.
 *
 * Описывает бизнес-представление типа действия, независимое от деталей хранения.
 *
 * Классы:
 * <ul>
 *   <li><b>AuditActionType</b> - Доменная модель (id, actionName, category, description)</li>
 * </ul>
 */
package com.logistics.shared.audit_action.domain;


=== backend/shared-library/src/main/java/com/logistics/shared/audit_action/AuditActionTypeService.java ===
package com.logistics.shared.audit_action;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Optional;

/**
 * Бизнес-сервис для работы с типами аудит-действий.
 *
 * <h2>Ответственность</h2>
 * Предоставляет различные способы поиска типов аудит-действий:
 * - По ID
 * - По имени действия (actionName)
 * - По категории
 *
 * @see AuditActionJpaRepository для работы с БД
 * @see AuditActionTypeMapper для преобразования Entity ↔ Domain
 */
@Service
@RequiredArgsConstructor
public class AuditActionTypeService {

    private final AuditActionJpaRepository repo;
    private final AuditActionTypeMapper mapper;

    public Optional<AuditActionType> getActionTypeById(Integer id) {
        return repo.findById(id).map(mapper::toDomain);
    }

    public Optional<AuditActionType> getActionTypeActionName(String actionName) {
        return repo.findByActionName(actionName).map(mapper::toDomain);
    }

    public Optional<AuditActionType> getActionTypeByCategory(String category) {
        return repo.findByCategory(category).map(mapper::toDomain);
    }

}


=== backend/shared-library/src/test/java/com/logistics/shared/IntegrationTest.java ===
package com.logistics.shared;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
@ActiveProfiles("test")
public @interface IntegrationTest {
}



=== backend/shared-library/src/test/java/com/logistics/shared/TestApplication.java ===
package com.logistics.shared;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Import;

@SpringBootApplication
@Import(SharedLibraryConfiguration.class)
public class TestApplication {

}


=== backend/shared-library/src/test/java/com/logistics/shared/validation/PhoneValidatorTest.java ===
package com.logistics.shared.validation;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("PhoneValidator: юнит‑тесты")
class PhoneValidatorTest {

    private final PhoneValidator validator = new PhoneValidator();

    @Test
    @DisplayName("Должен принимать корректные номера РФ/РБ/КЗ")
    void shouldAcceptValidPhones() {
        assertThat(validator.isValid("89991234567", null)).isTrue(); // РФ
        assertThat(validator.isValid("+7 (999) 123-45-67", null)).isTrue(); // РФ с форматированием
        assertThat(validator.isValid("+375291234567", null)).isTrue(); // Беларусь
        assertThat(validator.isValid("376291234567", null)).isTrue();  // Беларусь без плюса
        assertThat(validator.isValid("+77011234567", null)).isTrue();  // Казахстан
        assertThat(validator.isValid("78011234567", null)).isTrue();   // Казахстан без плюса
    }

    @Test
    @DisplayName("Должен отклонять некорректные номера")
    void shouldRejectInvalidPhones() {
        assertThat(validator.isValid("123", null)).isFalse();
        assertThat(validator.isValid("abcdefghijk", null)).isFalse();
        assertThat(validator.isValid("+1 999 123 45 67", null)).isFalse(); // не наш регион
        assertThat(validator.isValid("+7999123456", null)).isFalse();      // мало цифр
        assertThat(validator.isValid("+799912345678", null)).isFalse();    // много цифр
    }

}



=== backend/shared-library/src/test/java/com/logistics/shared/validation/PasswordValidatorTest.java ===
package com.logistics.shared.validation;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("PasswordValidator: юнит‑тесты")
class PasswordValidatorTest {

    private final PasswordValidator validator = new PasswordValidator();

    @Test
    @DisplayName("Должен принимать достаточно сложные пароли")
    void shouldAcceptStrongPasswords() {
        assertThat(validator.isValid("Password123!", null)).isTrue();
        assertThat(validator.isValid("Qwerty1@", null)).isTrue();
    }

    @Test
    @DisplayName("Должен отклонять слабые пароли")
    void shouldRejectWeakPasswords() {
        assertThat(validator.isValid("short", null)).isFalse();          // короткий
        assertThat(validator.isValid("password", null)).isFalse();      // без цифр/символов
        assertThat(validator.isValid("password1", null)).isFalse();     // без спецсимвола
        assertThat(validator.isValid("PASSWORD1!", null)).isFalse();    // без строчных
        assertThat(validator.isValid("password1!", null)).isFalse();    // без заглавных
    }

    @Test
    @DisplayName("Должен отклонять null")
    void shouldRejectNull() {
        assertThat(validator.isValid(null, null)).isFalse();
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/redis/service/RedisServiceTest.java ===
package com.logistics.shared.redis.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RedisService: тестирование операций с Redis")
class RedisServiceTest {

    @Mock
    private RedisTemplate<String, Object> redisTemplate;

    @Mock
    private ValueOperations<String, Object> valueOperations;

    private RedisService redisService;

    @BeforeEach
    void setUp() {
        redisService = new RedisService(redisTemplate);
    }

    @Test
    @DisplayName("Должен сохранить значение с TTL")
    void shouldSetValueWithTtl() {
        // Given
        String key = "test:key";
        String value = "test-value";
        Duration ttl = Duration.ofMinutes(5);
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);

        // When
        redisService.set(key, value, ttl);

        // Then
        verify(valueOperations).set(key, value, ttl);
    }

    @Test
    @DisplayName("Должен получить значение по ключу")
    void shouldGetValueByKey() {
        // Given
        String key = "test:key";
        String expectedValue = "test-value";
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        when(valueOperations.get(key)).thenReturn(expectedValue);

        // When
        Optional<String> result = redisService.get(key, String.class);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get()).isEqualTo(expectedValue);
        verify(valueOperations).get(key);
    }

    @Test
    @DisplayName("Должен вернуть пустой Optional если значение не найдено")
    void shouldReturnEmptyOptionalWhenValueNotFound() {
        // Given
        String key = "nonexistent:key";
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        when(valueOperations.get(key)).thenReturn(null);

        // When
        Optional<String> result = redisService.get(key, String.class);

        // Then
        assertThat(result).isEmpty();
    }

    @Test
    @DisplayName("Должен удалить значение по ключу")
    void shouldDeleteValueByKey() {
        // Given
        String key = "test:key";
        when(redisTemplate.delete(key)).thenReturn(true);

        // When
        boolean result = redisService.delete(key);

        // Then
        assertThat(result).isTrue();
        verify(redisTemplate).delete(key);
    }

    @Test
    @DisplayName("Должен проверить существование ключа")
    void shouldCheckIfKeyExists() {
        // Given
        String key = "test:key";
        when(redisTemplate.hasKey(key)).thenReturn(true);

        // When
        boolean result = redisService.exists(key);

        // Then
        assertThat(result).isTrue();
        verify(redisTemplate).hasKey(key);
    }

    @Test
    @DisplayName("Должен получить TTL ключа")
    void shouldGetTtl() {
        // Given
        String key = "test:key";
        when(redisTemplate.getExpire(key, TimeUnit.MINUTES)).thenReturn(5L);

        // When
        Optional<Long> result = redisService.getTtl(key, TimeUnit.MINUTES);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get()).isEqualTo(5L);
    }

    @Test
    @DisplayName("Должен инкрементировать значение")
    void shouldIncrementValue() {
        // Given
        String key = "counter:key";
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        when(valueOperations.increment(key)).thenReturn(1L);

        // When
        Long result = redisService.increment(key);

        // Then
        assertThat(result).isEqualTo(1L);
        verify(valueOperations).increment(key);
    }

    @Test
    @DisplayName("Должен инкрементировать значение с TTL")
    void shouldIncrementValueWithTtl() {
        // Given
        String key = "counter:key";
        Duration ttl = Duration.ofMinutes(5);
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        when(valueOperations.increment(key)).thenReturn(1L);
        when(redisTemplate.expire(key, ttl)).thenReturn(true);

        // When
        Long result = redisService.incrementWithTtl(key, ttl);

        // Then
        assertThat(result).isEqualTo(1L);
        verify(valueOperations).increment(key);
        verify(redisTemplate).expire(key, ttl);
    }

    @Test
    @DisplayName("Не должен устанавливать TTL при инкременте если значение null")
    void shouldNotSetTtlWhenIncrementReturnsNull() {
        // Given
        String key = "counter:key";
        Duration ttl = Duration.ofMinutes(5);
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        when(valueOperations.increment(key)).thenReturn(null);

        // When
        Long result = redisService.incrementWithTtl(key, ttl);

        // Then
        assertThat(result).isNull();
        verify(redisTemplate, never()).expire(anyString(), any(Duration.class));
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/redis/service/RateLimiterServiceTest.java ===
package com.logistics.shared.redis.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.Duration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RateLimiterService: тестирование ограничения частоты запросов")
class RateLimiterServiceTest {

    @Mock
    private RedisService redisService;

    private RateLimiterService rateLimiterService;

    @BeforeEach
    void setUp() {
        rateLimiterService = new RateLimiterService(redisService);
    }

    @Test
    @DisplayName("Должен разрешить первый запрос")
    void shouldAllowFirstRequest() {
        // Given
        String identifier = "user123";
        int maxAttempts = 3;
        Duration window = Duration.ofMinutes(1);
        when(redisService.incrementWithTtl(anyString(), any(Duration.class))).thenReturn(1L);

        // When
        boolean isLimited = rateLimiterService.isRateLimited(identifier, maxAttempts, window);

        // Then
        assertThat(isLimited).isFalse();
        verify(redisService).incrementWithTtl(eq("rate-limit:" + identifier), eq(window));
    }

    @Test
    @DisplayName("Должен разрешить запросы в пределах лимита")
    void shouldAllowRequestsWithinLimit() {
        // Given
        String identifier = "user123";
        int maxAttempts = 3;
        Duration window = Duration.ofMinutes(1);
        when(redisService.incrementWithTtl(anyString(), any(Duration.class))).thenReturn(2L);

        // When
        boolean isLimited = rateLimiterService.isRateLimited(identifier, maxAttempts, window);

        // Then
        assertThat(isLimited).isFalse();
    }

    @Test
    @DisplayName("Должен заблокировать запросы при превышении лимита")
    void shouldBlockRequestsWhenLimitExceeded() {
        // Given
        String identifier = "user123";
        int maxAttempts = 3;
        Duration window = Duration.ofMinutes(1);
        when(redisService.incrementWithTtl(anyString(), any(Duration.class))).thenReturn(4L);

        // When
        boolean isLimited = rateLimiterService.isRateLimited(identifier, maxAttempts, window);

        // Then
        assertThat(isLimited).isTrue();
    }

    @Test
    @DisplayName("Должен заблокировать при достижении точного лимита")
    void shouldBlockWhenExactlyAtLimit() {
        // Given
        String identifier = "user123";
        int maxAttempts = 1;
        Duration window = Duration.ofMinutes(1);
        when(redisService.incrementWithTtl(anyString(), any(Duration.class))).thenReturn(3L);

        // When
        boolean isLimited = rateLimiterService.isRateLimited(identifier, maxAttempts, window);

        // Then
        assertThat(isLimited).isTrue();
    }

    @Test
    @DisplayName("Должен обработать null ответ от Redis")
    void shouldHandleNullResponseFromRedis() {
        // Given
        String identifier = "user123";
        int maxAttempts = 3;
        Duration window = Duration.ofMinutes(1);
        when(redisService.incrementWithTtl(anyString(), any(Duration.class))).thenReturn(null);

        // When
        boolean isLimited = rateLimiterService.isRateLimited(identifier, maxAttempts, window);

        // Then
        assertThat(isLimited).isFalse();
    }

    @Test
    @DisplayName("Должен сбросить счетчик rate limit")
    void shouldResetRateLimit() {
        // Given
        String identifier = "user123";

        // When
        rateLimiterService.reset(identifier);

        // Then
        verify(redisService).delete("rate-limit:" + identifier);
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/SharedLibraryApplicationTests.java ===
package com.logistics.shared;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@SpringBootTest
@ActiveProfiles("test")
@DisplayName("Shared Library: загрузка контекста")
class SharedLibraryApplicationTests {

    @Test
    @DisplayName("Должен успешно загрузить контекст Spring")
    void contextLoads() {
        // Этот тест проверяет, что все бины и конфигурации загружаются без ошибок
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/AuditActionTypeServiceTest.java ===
package com.logistics.shared.audit_action;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("AuditActionTypeService: юнит-тесты")
class AuditActionTypeServiceTest {

    @Mock
    private AuditActionJpaRepository repo;
    @Mock
    private AuditActionTypeMapper mapper;
    @InjectMocks
    private AuditActionTypeService service;

    private AuditActionTypeEntity testEntity;
    private AuditActionType testDomain;

    @BeforeEach
    void setUp() {
        testEntity = AuditActionTypeEntity.builder().id((short) 1).actionName("USER_LOGIN").category("AUTHENTICATION").description("User logged in").build();
        testDomain = AuditActionType.builder().id((short) 1).actionName("USER_LOGIN").category("AUTHENTICATION").description("User logged in").build();
    }

    @Test
    @DisplayName("Должен вернуть ActionType по ID")
    void shouldGetActionTypeById() {
        when(repo.findById(anyInt())).thenReturn(Optional.of(testEntity));
        when(mapper.toDomain(any(AuditActionTypeEntity.class))).thenReturn(testDomain);

        Optional<AuditActionType> result = service.getActionTypeById(1);

        assertThat(result).isPresent();
        assertThat(result.get().getId()).isEqualTo((short) 1);
        verify(repo, times(1)).findById(1);
    }
}




=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/persistence/AuditActionTypeMapperTest.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("AuditActionTypeMapper: юнит-тесты")
class AuditActionTypeMapperTest {

    private AuditActionTypeMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new AuditActionTypeMapper();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        AuditActionTypeEntity entity = AuditActionTypeEntity.builder()
                .id((short) 1)
                .actionName("USER_LOGIN")
                .category("AUTHENTICATION")
                .description("Пользователь вошел в систему")
                .build();

        // When
        AuditActionType domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo((short) 1);
        assertThat(domain.getActionName()).isEqualTo("USER_LOGIN");
        assertThat(domain.getCategory()).isEqualTo("AUTHENTICATION");
        assertThat(domain.getDescription()).isEqualTo("Пользователь вошел в систему");
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        AuditActionType domain = AuditActionType.builder()
                .id((short) 2)
                .actionName("USER_LOGOUT")
                .category("AUTHENTICATION")
                .description("Пользователь вышел из системы")
                .build();

        // When
        AuditActionTypeEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo((short) 2);
        assertThat(entity.getActionName()).isEqualTo("USER_LOGOUT");
        assertThat(entity.getCategory()).isEqualTo("AUTHENTICATION");
        assertThat(entity.getDescription()).isEqualTo("Пользователь вышел из системы");
    }
}



=== backend/shared-library/src/test/java/com/logistics/shared/audit_action/persistence/AuditActionJpaRepositoryIntegrationTest.java ===
package com.logistics.shared.audit_action.persistence;

import com.logistics.shared.IntegrationTest;
import com.logistics.shared.TestApplication;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("AuditActionJpaRepository: интеграционные тесты")
class AuditActionJpaRepositoryIntegrationTest {

    @Autowired
    private AuditActionJpaRepository repository;

    @Test
    @DisplayName("Должен сохранить и найти AuditActionType по ID")
    void shouldSaveAndFindById() {
        // Given
        // Создаем сущность, которую собираемся сохранить
        AuditActionTypeEntity entityToSave = AuditActionTypeEntity.builder()
                .actionName("ORDER_CREATED")
                .category("ORDER_MANAGEMENT")
                .description("Заказ создан")
                .build();

        // Сохраняем и, что КЛЮЧЕВОЕ, получаем обратно экземпляр с ID
        AuditActionTypeEntity savedEntity = repository.save(entityToSave);

        // When
        // Ищем в базе по ID, полученному от сохраненной сущности
        Optional<AuditActionTypeEntity> found = repository.findById(Integer.valueOf(savedEntity.getId()));

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getActionName()).isEqualTo("ORDER_CREATED");
        assertThat(found.get().getId()).isEqualTo(savedEntity.getId());
    }

}



=== backend/db-migration/src/main/java/com/logistics/db/DbMigrationApplication.java ===
package com.logistics.db;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.context.ConfigurableApplicationContext;


/**
 * Точка входа приложения для инициализации и миграции базы данных.
 *
 * <h2>Назначение</h2>
 * <p>
 * Это специализированное Spring Boot приложение, которое:
 * </p>
 * <ul>
 *   <li>Запускается один раз при инициализации системы</li>
 *   <li>Применяет все ожидающие миграции Flyway</li>
 *   <li>Проверяет целостность схемы БД</li>
 *   <li>Логирует ход выполнения миграций</li>
 *   <li>Завершается после успешного выполнения миграций</li>
 * </ul>
 *
 * <h2>Процесс запуска</h2>
 * <ol>
 *   <li>Spring Boot загружает контекст</li>
 *   <li>Flyway сканирует папку classpath:db/migration</li>
 *   <li>Применяются все новые миграции в порядке версионирования</li>
 *   <li>В логах отображается статус выполнения</li>
 *   <li>Приложение завершает работу с кодом 0 (успех) или 1 (ошибка)</li>
 * </ol>
 *
 * <h2>Использование</h2>
 * <pre>
 * Запуск из Docker Compose:
 * docker-compose run --rm db-migration
 *
 * Или напрямую:
 * java -jar db-migration-1.0.0.jar
 * </pre>
 *
 * <h2>Структура файлов миграций</h2>
 * <pre>
 * backend/db-migration/src/main/resources/db/migration/
 * ├── V1__Initial_schema.sql
 * ├── V2__Add_users_table.sql
 * └── V3__Add_indexes.sql
 * </pre>
 *
 * <h2>Конфигурация</h2>
 * Читается из application.yml:
 * - spring.datasource.url - адрес БД
 * - spring.datasource.username - пользователь БД
 * - spring.datasource.password - пароль БД
 * - app.db-migration.enabled - включить/отключить миграции
 *
 * @see FlywayConfig для конфигурации Flyway
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@SpringBootApplication(
		exclude = HibernateJpaAutoConfiguration.class
)
public class DbMigrationApplication {
	private static final Logger log = LoggerFactory.getLogger(DbMigrationApplication.class);
	/**
	 * Главный метод приложения.
	 *
	 * Логирует начало и завершение миграций, обрабатывает ошибки.
	 *
	 * @param args Аргументы командной строки (игнорируются)
	 */
	public static void main(String[] args) {
		try {
			log.info("========== Начало инициализации БД ==========");
			ConfigurableApplicationContext context =
					SpringApplication.run(DbMigrationApplication.class, args);

			log.info("✓ Миграции БД выполнены успешно");
			log.info("========== Завершение работы миграций ==========");

			// Закрыть контекст и завершить приложение
			context.close();
			System.exit(0);

		} catch (Exception e) {
			log.error("✗ Ошибка при выполнении миграций БД", e);
			System.exit(1);
		}
	}

}



=== backend/db-migration/src/main/java/com/logistics/db/FlywayConfig.java ===
package com.logistics.db;

import org.flywaydb.core.Flyway;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

/**
 * Конфигурация Flyway для управления миграциями БД.
 *
 * <h2>Ответственность</h2>
 * Создает и настраивает бин Flyway, который:
 * - Сканирует миграции из classpath:db/migration
 * - Применяет новые миграции на старте приложения
 * - Валидирует целостность схемы
 * - Предотвращает случайное удаление БД (cleanDisabled: true)
 *
 * <h2>Параметры Flyway</h2>
 * <table border="1">
 *   <tr><th>Параметр</th><th>Значение</th><th>Описание</th></tr>
 *   <tr>
 *     <td>locations</td>
 *     <td>classpath:db/migration</td>
 *     <td>Папка с SQL файлами миграций</td>
 *   </tr>
 *   <tr>
 *     <td>baselineOnMigrate</td>
 *     <td>true</td>
 *     <td>Создать baseline для уже существующей БД</td>
 *   </tr>
 *   <tr>
 *     <td>validateOnMigrate</td>
 *     <td>true</td>
 *     <td>Проверить целостность применённых миграций</td>
 *   </tr>
 *   <tr>
 *     <td>cleanDisabled</td>
 *     <td>true</td>
 *     <td>КРИТИЧНО: защита от удаления БД в production</td>
 *   </tr>
 * </table>
 *
 * <h2>Пример SQL миграции</h2>
 * <pre>
 * File: V1__Create_users_table.sql
 *
 * CREATE SCHEMA IF NOT EXISTS user_management;
 *
 * CREATE TABLE user_management.users (
 *     user_id BIGSERIAL PRIMARY KEY,
 *     phone VARCHAR(20) UNIQUE NOT NULL,
 *     email VARCHAR(255),
 *     password_hash VARCHAR(255),
 *     first_name VARCHAR(100),
 *     last_name VARCHAR(100),
 *     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
 * );
 * </pre>
 *
 * <h2>Условное выполнение</h2>
 * Конфигурация применяется только если:
 * app.db-migration.enabled = true (или отсутствует - применяется по умолчанию)
 *
 * @see DbMigrationApplication для точки входа
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@Configuration
@EnableConfigurationProperties
@ConditionalOnProperty(
        name = "app.db-migration.enabled",
        havingValue = "true",
        matchIfMissing = true
)
public class FlywayConfig {

    /**
     * Создает и настраивает Flyway бин.
     *
     * @param dataSource Источник данных для подключения к БД
     * @return Настроенный и выполненный Flyway объект
     */
    @Bean
    public Flyway flyway(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .locations("classpath:db/migration")
                .baselineOnMigrate(true)
                .validateOnMigrate(true)
                .cleanDisabled(true)  // Отключить очистку в production
                .load();

        flyway.migrate();
        return flyway;
    }
}



=== backend/db-migration/src/main/java/com/logistics/db/package-info.java ===
/**
 * Микросервис инициализации и миграции базы данных.
 *
 * Отвечает за:
 * <ul>
 *   <li>Запуск и управление Flyway миграциями</li>
 *   <li>Инициализацию схем БД при старте приложения</li>
 *   <li>Валидацию целостности БД</li>
 * </ul>
 *
 * Запуск: {@code java -jar db-migration.jar}
 *
 * @see com.logistics.db.DbMigrationApplication
 * @see com.logistics.db.FlywayConfig
 */
package com.logistics.db;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/UserAuthServiceApplication.java ===
package com.logistics.userauth;

import com.logistics.shared.redis.EnableRedis;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
/**
 * Точка входа микросервиса аутентификации.
 *
 * <h2>Ответственность</h2>
 * - Инициализирует Spring Boot приложение
 * - Подключает shared-library компоненты
 * - Импортирует OpenAPI конфигурацию
 * - Импортирует Redis конфигурацию
 * - Сканирует все @Component, @Service, @Controller в com.logistics.userauth и com.logistics.shared
 *
 * <h2>Архитектура</h2>
 * Используется Clean Architecture (Hexagonal Architecture):
 * <pre>
 * adapter.in      - REST контроллеры, маппреры DTO
 * adapter.out     - JPA entities, репозитории, маппреры персистенса
 * application     - Use Cases, порты, команды
 * domain          - Доменные сущности (User, UserRole и т.д.)
 * infrastructure  - Spring Security, фильтры, конфигурация
 * common          - Глобальные exception handlers, утилиты
 * </pre>
 *
 * <h2>Конфигурация</h2>
 * Читается из application.yml:
 * - server.port: 8080 (или как настроено)
 * - server.servlet.context-path: /api/v1
 * - Credentials для БД (PostgreSQL)
 * - JWT конфигурация (secret, expiration)
 *
 * @author Logistics Team
 * @version 1.0.0
 * @since 2025-12-15
 */
@SpringBootApplication
@EnableRedis
@ComponentScan(basePackages = {
        "com.logistics.userauth",
        "com.logistics.shared"
})
@EnableJpaRepositories(basePackages = "com.logistics.userauth.**.persistence")
@EntityScan(basePackages = "com.logistics.userauth.**.persistence")
public class UserAuthServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserAuthServiceApplication.class, args);
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/usecase/SendVerificationCodeService.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.shared.redis.service.RateLimiterService;
import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.exception.SmsDeliveryException;
import com.logistics.userauth.sms.application.port.in.InternalSmsRateLimiterUseCase;
import com.logistics.userauth.sms.application.port.in.SendVerificationCodeUseCase;
import com.logistics.userauth.sms.application.port.in.command.InternalSmsRateLimiterCommand;
import com.logistics.userauth.sms.application.port.in.command.SendVerificationCodeCommand;
import com.logistics.userauth.sms.application.port.out.SendSmsPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.internal.util.stereotypes.Lazy;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.security.SecureRandom;
import java.time.Duration;
import java.time.LocalDateTime;

/**
 * Сервис для генерации и отправки SMS кодов верификации.
 *
 * <h2>Алгоритм работы</h2>
 * <ol>
 *   <li>Проверка rate limiting (опционально, если включено)</li>
 *   <li>Генерация криптографически стойкого кода</li>
 *   <li>Сохранение в Redis с TTL</li>
 *   <li>Отправка SMS через провайдер</li>
 *   <li>Логирование результата</li>
 * </ol>
 *
 * <h2>Безопасность</h2>
 * <ul>
 *   <li>Используется {@link SecureRandom} для генерации кодов</li>
 *   <li>Rate limiting защищает от спама</li>
 *   <li>Коды хранятся с TTL для автоматического удаления</li>
 * </ul>
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class SendVerificationCodeService implements SendVerificationCodeUseCase {

    private final SmsRepository smsRepository;
    private final SendSmsPort sendSmsPort;
    private final InternalSmsRateLimiterUseCase internalSmsRateLimiterUseCase;

    @Value("${app.sms.verification.code-length:6}")
    private int codeLength;

    @Value("${app.sms.verification.code-ttl-minutes:5}")
    private long codeTtlMinutes;

    private final SecureRandom secureRandom = new SecureRandom();

    /**
     * Отправляет SMS код на указанный номер.
     *
     * @param command Команда отправки кода (phone).
     * @throws RateLimitExceededException если не прошло 60 секунд с последней отправки
     * @throws SmsDeliveryException если провайдер не смог доставить SMS
     */
    @Override
    public void sendCode(SendVerificationCodeCommand command) {
        log.info("Sending verification code to phone: {}", command.phone());

        var smsRateLimiterCommand = new InternalSmsRateLimiterCommand(command.phone());

        internalSmsRateLimiterUseCase.checkRateLimiter(smsRateLimiterCommand);

//        ensureNoActiveCode(command.phone());

        var code = generateSecureCode();

        var verificationCode = SmsVerificationCode.builder()
                .phone(command.phone())
                .code(code)
                .expiresAt(LocalDateTime.now().plusMinutes(codeTtlMinutes))
                .attempts(0)
                .build();

        smsRepository.save(verificationCode, codeTtlMinutes);
        log.debug("Verification code saved to repository: phone={}", command.phone());

        var isSent = sendSmsPort.sendVerificationCode(command.phone(), code);

        if (!isSent) {
            log.error("Failed to send SMS to phone: {}", command.phone());
            throw new SmsDeliveryException(
                    "Не удалось отправить SMS. Попробуйте позже или обратитесь в поддержку."
            );
        }

        log.info("Verification code sent successfully: phone={}", command.phone());
    }

    /**
     * Генерирует криптографически стойкий код заданной длины.
     *
     * @return Строка из цифр (например, "123456")
     */
    private String generateSecureCode() {
        StringBuilder code = new StringBuilder();
        for (int i = 0; i < codeLength; i++) {
            code.append(secureRandom.nextInt(10));
        }
        log.debug("Generated verification code: {}", code);
        return code.toString();
    }



    /**
     * Проверяет нет ли существующего действительного кода.
     *
     * @param phone Номер телефона
     * @throws RateLimitExceededException если существующий код еще действителен
     */
    private void ensureNoActiveCode(String phone) {
        smsRepository.findByPhone(phone).ifPresent(existingCode -> {
            if (!existingCode.isExpired()) {
                long secondsRemaining = java.time.Duration.between(
                        LocalDateTime.now(),
                        existingCode.getExpiresAt()
                ).getSeconds();

                log.warn("Existing code not expired for phone: {}. Remaining {}s", phone, secondsRemaining);
                throw new RateLimitExceededException(
                        String.format("Существующий код еще действителен. Отправка нового возможна через %d сек.", secondsRemaining)
                );
            }
        });
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/usecase/InternalSmsRateLimiterService.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.shared.redis.service.RateLimiterService;
import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.port.in.InternalSmsRateLimiterUseCase;
import com.logistics.userauth.sms.application.port.in.command.InternalSmsRateLimiterCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.internal.util.stereotypes.Lazy;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Slf4j
@Service
@RequiredArgsConstructor
public class InternalSmsRateLimiterService implements InternalSmsRateLimiterUseCase {

    private final RateLimiterService rateLimiterService;

    @Value("${app.sms.verification.resend-cooldown-seconds}")
    private long resendCooldownSeconds;

    @Value("${app.sms.verification.max-attempts}")
    private int maxAttempts;

    /**
     * Проверяет rate limit для отправки SMS на указанный номер.
     *
     * <p>Использует {@link RateLimiterService} для ограничения частоты запросов.
     *
     * @param command Команда для проверки перегрузки (phone)
     * @throws RateLimitExceededException если лимит превышен
     */
    @Override
    public void checkRateLimiter(InternalSmsRateLimiterCommand command) {

        String identifier = "sms:send:" + command.phone();

        if (rateLimiterService.isRateLimited(identifier, maxAttempts, Duration.ofSeconds(resendCooldownSeconds))) {
            log.warn("Rate limit exceeded for phone: {}", command.phone());
            throw new RateLimitExceededException("Повторная отправка возможна через 60 секунд");
        }
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/usecase/package-info.java ===
/**
 * Use case-слой SMS верификации телефона.
 *
 * <h2>Назначение</h2>
 * Реализует бизнес-сценарии отправки кода и подтверждения телефона, включая ограничения
 * на повторную отправку и число попыток ввода кода.
 *
 * <h2>Ключевые сервисы</h2>
 * <ul>
 *   <li><b>SendVerificationCodeService</b> — генерация кода, сохранение с TTL и отправка через провайдера.</li>
 *   <li><b>VerifyPhoneService</b> — проверка кода, учет попыток, установка статуса “verified”.</li>
 *   <li><b>InternalSmsRateLimiterService</b> — rate limit на отправку SMS.</li>
 * </ul>
 *
 * <h2>Ошибки</h2>
 * <ul>
 *   <li>{@link com.logistics.userauth.sms.application.exception.RateLimitExceededException} — превышен лимит.</li>
 *   <li>{@link com.logistics.userauth.sms.application.exception.SmsDeliveryException} — ошибка отправки SMS.</li>
 *   <li>{@link com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException} — неверный/истекший код.</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.application.usecase.SendVerificationCodeService
 * @see com.logistics.userauth.sms.application.usecase.VerifyPhoneService
 * @see com.logistics.userauth.sms.application.usecase.InternalSmsRateLimiterService
 */
package com.logistics.userauth.sms.application.usecase;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/usecase/VerifyPhoneService.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException;
import com.logistics.userauth.sms.application.port.in.VerifyPhoneUseCase;
import com.logistics.userauth.sms.application.port.in.command.VerifyPhoneCommand;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Random;

/**
 * Сервис для верификации телефонов через SMS коды.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class VerifyPhoneService implements VerifyPhoneUseCase {

    private final SmsRepository repository;

    @Value("${app.sms.verification.max-attempts}")
    private int maxAttempts;

    @Value("${app.sms.verification.verified-status-ttl-minutes:10}")
    private long verifiedStatusTtlMinutes;


    /**
     * Проверяет введенный пользователем код.
     */
    @Override
    public void verify(VerifyPhoneCommand command) {
        log.info("Verifying phone: {}", command.phone());

        var storedCode = repository.findByPhone(command.phone())
                .orElseThrow(() -> new InvalidVerificationCodeException(
                        "Код не найден. Запросите новый код."
                ));

        if (storedCode.isExpired()) {
            repository.deleteVerificationCode(command.phone());
            log.warn("Verification code expired for phone: {}", command.phone());
            throw new InvalidVerificationCodeException(
                    "Срок действия кода истек. Запросите новый код."
            );
        }

        if (!storedCode.getCode().equals(command.code())) {
            int newAttempts = storedCode.getAttempts() + 1;

            repository.incrementAttempts(command.phone());

            if (newAttempts >= maxAttempts) {
                repository.deleteVerificationCode(command.phone());
                log.warn("Max attempts reached for phone: {}", command.phone());
                throw new InvalidVerificationCodeException("Неверный код. Превышено количество попыток.");
            }

            int remainingAttempts = maxAttempts - newAttempts;
            log.warn("Invalid code for phone: {}. Remaining attempts: {}", command.phone(), remainingAttempts);
            throw new InvalidVerificationCodeException(
                    String.format("Неверный код. Осталось попыток: %d", remainingAttempts)
            );
        }


        repository.deleteVerificationCode(command.phone());
        repository.markPhoneAsVerified(command.phone(), verifiedStatusTtlMinutes);

        log.info("Phone verified successfully: {}", command.phone());
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/VerifyPhoneUseCase.java ===
package com.logistics.userauth.sms.application.port.in;

import com.logistics.userauth.sms.application.port.in.command.VerifyPhoneCommand;

/**
 * Use Case для верификации телефона через SMS код.
 */
public interface VerifyPhoneUseCase {
    void verify(VerifyPhoneCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/SendVerificationCodeUseCase.java ===
package com.logistics.userauth.sms.application.port.in;

import com.logistics.userauth.sms.application.port.in.command.SendVerificationCodeCommand;

public interface SendVerificationCodeUseCase {
    void sendCode(SendVerificationCodeCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/package-info.java ===
/**
 * Входные порты (Inbound Ports) модуля SMS верификации.
 *
 * <h2>Назначение</h2>
 * <p>
 * Пакет содержит контракты (интерфейсы) use case-ов, которые вызываются из adapter.in (REST контроллеров).
 * Это позволяет отделить web/API слой от бизнес-логики.
 * </p>
 *
 * <h2>Контракты</h2>
 * <ul>
 *   <li>{@link com.logistics.userauth.sms.application.port.in.SendVerificationCodeUseCase}</li>
 *   <li>{@link com.logistics.userauth.sms.application.port.in.VerifyPhoneUseCase}</li>
 *   <li>{@link com.logistics.userauth.sms.application.port.in.InternalSmsRateLimiterUseCase}</li>
 * </ul>
 *
 * <h2>Входные данные</h2>
 * <p>
 * Команды для use case-ов вынесены в пакет {@code com.logistics.userauth.sms.application.port.in.command}.
 * </p>
 *
 * @author Logistics Team
 * @since 1.0.0
 */
package com.logistics.userauth.sms.application.port.in;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/InternalSmsRateLimiterUseCase.java ===
package com.logistics.userauth.sms.application.port.in;

import com.logistics.userauth.sms.application.port.in.command.InternalSmsRateLimiterCommand;

public interface InternalSmsRateLimiterUseCase {
    void checkRateLimiter(InternalSmsRateLimiterCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/command/SendVerificationCodeCommand.java ===
package com.logistics.userauth.sms.application.port.in.command;

public record SendVerificationCodeCommand(String phone) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/command/InternalSmsRateLimiterCommand.java ===
package com.logistics.userauth.sms.application.port.in.command;

public record InternalSmsRateLimiterCommand (String phone) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/command/package-info.java ===
package com.logistics.userauth.sms.application.port.in.command;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/in/command/VerifyPhoneCommand.java ===
package com.logistics.userauth.sms.application.port.in.command;

import lombok.Builder;

@Builder
public record VerifyPhoneCommand(
        String phone,
        String code
) {}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/package-info.java ===
package com.logistics.userauth.sms.application.port;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/out/SendSmsPort.java ===
package com.logistics.userauth.sms.application.port.out;

/**
 * Порт для отправки SMS через внешний провайдер.
 */
public interface SendSmsPort {
    boolean sendVerificationCode(String phone, String code);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/out/SmsRepository.java ===
package com.logistics.userauth.sms.application.port.out;

import com.logistics.userauth.sms.domain.SmsVerificationCode;

import java.util.Optional;

/**
 * Репозиторий для управления SMS верификацией.
 *
 * <p>Предоставляет операции для:</p>
 * <ul>
 *   <li>Хранения и получения кодов верификации (временное хранилище)</li>
 *   <li>Управления статусом верификации телефонов</li>
 * </ul>
 *
 * <p>Реализация определяет конкретное хранилище и механизмы.</p>
 *
 * @see com.logistics.userauth.sms.adapter.out.persistence.SmsRepositoryPersistenceAdapter
 */
public interface SmsRepository {
    /**
     * Сохраняет код верификации во временное хранилище.
     *
     * @param code код верификации с метаданными
     * @param ttlMinutes время жизни кода в минутах
     */
    void save(SmsVerificationCode code, long ttlMinutes);
    Optional<SmsVerificationCode> findByPhone(String phone);
    void deleteVerificationCode(String phone);
    void deleteVerificationStatus(String phone);
    void incrementAttempts(String phone);
    void markPhoneAsVerified(String phone, long ttlMinutes);
    boolean isPhoneVerified(String phone);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/port/out/package-info.java ===
/**
 * Выходные порты (Outbound Ports) модуля SMS верификации.
 *
 * <h2>Назначение</h2>
 * Определяет контракты для взаимодействия use case-слоя с внешней инфраструктурой:
 * отправка SMS и хранение кодов/статусов верификации.
 *
 * <h2>Контракты</h2>
 * <ul>
 *   <li><b>SendSmsPort</b> — отправка кода в SMS провайдер.</li>
 *   <li><b>SmsRepository</b> — операции хранения/получения кода, статуса и попыток.</li>
 * </ul>
 *
 * <h2>Реализации</h2>
 * <ul>
 *   <li><b>Provider adapters</b>: {@code com.logistics.userauth.sms.adapter.out.provider}</li>
 *   <li><b>Persistence adapters</b>: {@code com.logistics.userauth.sms.adapter.out.persistence}</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.application.port.out.SendSmsPort
 * @see com.logistics.userauth.sms.application.port.out.SmsRepository
 */
package com.logistics.userauth.sms.application.port.out;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/exception/RateLimitExceededException.java ===
package com.logistics.userauth.sms.application.exception;

/**
 * Исключение при превышении лимита запросов на отправку SMS.
 *
 * <h2>Когда выбрасывается</h2>
 * <ul>
 *   <li>Повторная отправка кода раньше, чем через 60 секунд</li>
 *   <li>Превышение дневного лимита отправок с одного IP</li>
 * </ul>
 *
 * <h2>HTTP статус</h2>
 * 429 Too Many Requests
 *
 * @see com.logistics.userauth.common.web.GlobalExceptionHandler
 */
public class RateLimitExceededException extends RuntimeException {

    public RateLimitExceededException(String message) {
        super(message);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/exception/InvalidVerificationCodeException.java ===
package com.logistics.userauth.sms.application.exception;


public class InvalidVerificationCodeException extends RuntimeException {
    public InvalidVerificationCodeException(String message) {
        super(message);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/exception/package-info.java ===
/**
 * Исключения SMS модуля.
 *
 * <h2>Исключения</h2>
 * <ul>
 *   <li><b>{@link com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException}</b> — 
 *       неверный код или истек срок действия</li>
 *   <li><b>{@link com.logistics.userauth.sms.application.exception.RateLimitExceededException}</b> — 
 *       превышен лимит запросов</li>
 *   <li><b>{@link com.logistics.userauth.sms.application.exception.SmsDeliveryException}</b> — 
 *       ошибка доставки SMS</li>
 * </ul>
 *
 * <h2>Обработка</h2>
 * Все исключения обрабатываются в {@link com.logistics.userauth.common.web.GlobalExceptionHandler}.
 *
 * @see com.logistics.userauth.common.web.GlobalExceptionHandler
 */
package com.logistics.userauth.sms.application.exception;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/exception/SmsDeliveryException.java ===
package com.logistics.userauth.sms.application.exception;

/**
 * Исключение при ошибке доставки SMS.
 *
 * <h2>Причины</h2>
 * <ul>
 *   <li>SMS провайдер недоступен (SMSC down)</li>
 *   <li>Недостаточно средств на балансе</li>
 *   <li>Неверный формат номера телефона</li>
 *   <li>Номер заблокирован оператором</li>
 * </ul>
 *
 * <h2>HTTP статус</h2>
 * 500 Internal Server Error или 503 Service Unavailable
 */
public class SmsDeliveryException extends RuntimeException {

    public SmsDeliveryException(String message) {
        super(message);
    }

    public SmsDeliveryException(String message, Throwable cause) {
        super(message, cause);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/application/package-info.java ===
package com.logistics.userauth.sms.application;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/package-info.java ===
/**
 *
 */
package com.logistics.userauth.sms;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/domain/package-info.java ===
package com.logistics.userauth.sms.domain;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/domain/SmsVerificationCode.java ===
package com.logistics.userauth.sms.domain;

import lombok.Builder;
import lombok.Data;

import java.time.LocalDateTime;

/**
 * Доменная модель для SMS кода верификации.
 */
@Data
@Builder
public class SmsVerificationCode {
    private String phone;
    private String code;
    private LocalDateTime expiresAt;
    private int attempts;

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/SmsController.java ===
package com.logistics.userauth.sms.adapter.in.web;

import com.logistics.userauth.common.api.SendVerificationCodeOperation;
import com.logistics.userauth.common.api.VerifyPhoneOperation;
import com.logistics.userauth.sms.adapter.in.web.dto.SendVerificationCodeRequest;
import com.logistics.userauth.sms.adapter.in.web.dto.VerifyPhoneRequest;
import com.logistics.userauth.sms.adapter.in.web.dto.VerifyPhoneResponse;
import com.logistics.userauth.sms.application.port.in.SendVerificationCodeUseCase;
import com.logistics.userauth.sms.application.port.in.VerifyPhoneUseCase;
import com.logistics.userauth.sms.application.port.in.command.SendVerificationCodeCommand;
import com.logistics.userauth.sms.application.port.in.command.VerifyPhoneCommand;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * REST контроллер для SMS верификации.
 *
 * <h2>Endpoints</h2>
 * <ul>
 *   <li>POST /api/v1/sms/send-verification-code — Отправка SMS кода</li>
 *   <li>POST /api/v1/sms/verify-phone — Проверка введенного кода</li>
 * </ul>
 *
 * <h2>Use Cases</h2>
 * <ul>
 *   <li>Верификация телефона при регистрации</li>
 *   <li>Двухфакторная аутентификация (2FA)</li>
 * </ul>
 *
 * <h2>Security</h2>
 * <ul>
 *   <li>Rate limiting (60 секунд между отправками) — реализовано в SendVerificationCodeService</li>
 *   <li>Максимум 3 попытки ввода кода — реализовано в VerifyPhoneService</li>
 * </ul>
 *
 * @see SendVerificationCodeUseCase
 * @see VerifyPhoneUseCase
 */
@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/sms")
@Tag(
        name = "SMS Верификация",
        description = "Endpoints для отправки и проверки SMS кодов верификации"
)
public class SmsController {

    private final SendVerificationCodeUseCase sendVerificationCodeUseCase;
    private final VerifyPhoneUseCase verifyPhoneUseCase;

    /**
     * POST /api/v1/sms/send-verification-code — запускает отправку SMS кода на телефон.
     * <p>
     * Принимает номер телефона и делегирует бизнес-логику в {@link SendVerificationCodeUseCase}.
     *
     * @param request DTO с номером телефона
     * @return 200 OK, если запрос успешно принят
     */
    @PostMapping("/send-verification-code")
    @SendVerificationCodeOperation
    public ResponseEntity<Void> sendVerificationCode(
            @Valid @RequestBody SendVerificationCodeRequest request
    ) {
        log.info("Sending verification code to phone: {}", request.phone());
        var command = new SendVerificationCodeCommand(request.phone());
        sendVerificationCodeUseCase.sendCode(command);
        return ResponseEntity.ok().build();
    }

    /**
     * POST /api/v1/sms/verify-phone — проверяет введённый SMS код.
     * <p>
     * Принимает телефон и код, делегирует проверку в {@link VerifyPhoneUseCase}.
     *
     * @param request DTO с телефоном и кодом
     * @return 200 OK с флагом успешной верификации
     */
    @PostMapping("/verify-phone")
    @VerifyPhoneOperation
    public ResponseEntity<VerifyPhoneResponse> verifyPhone(
            @Valid @RequestBody VerifyPhoneRequest request
    ) {
        log.info("Verifying phone: {}", request.phone());

        var command = VerifyPhoneCommand.builder()
                .phone(request.phone())
                .code(request.code())
                .build();

        verifyPhoneUseCase.verify(command);

        var response = VerifyPhoneResponse.builder()
                .phone(request.phone())
                .verified(true)
                .message("Телефон успешно верифицирован")
                .build();

        log.info("Phone verified successfully: {}", request.phone());
        return ResponseEntity.ok(response);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/package-info.java ===
package com.logistics.userauth.sms.adapter.in.web;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/dto/VerifyPhoneResponse.java ===
package com.logistics.userauth.sms.adapter.in.web.dto;

import lombok.Builder;

/**
 * DTO для запроса отправки SMS кода верификации.
 *
 *
 * <h2>Назначение</h2>
 * Используется при верификации телефона после регистрации для защиты от фейковых аккаунтов.
 *
 * <h2>Пример</h2>
 * <pre>
 * {
 *   "phone": "79991234567"
 * }
 * </pre>
 */
@Builder
public record VerifyPhoneResponse(
        String phone,
        boolean verified,
        String message
) {}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/dto/VerifyPhoneRequest.java ===
package com.logistics.userauth.sms.adapter.in.web.dto;

import com.logistics.shared.validation.Phone;
import com.logistics.userauth.sms.adapter.in.validation.SmsCode;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Builder;

/**
 * DTO для подтверждения номера телефона через SMS код.
 *
 * <h2>Назначение</h2>
 * Используется при верификации телефона после регистрации для защиты от фейковых аккаунтов.
 *
 * <h2>Пример</h2>
 * <pre>
 * {
 *   "phone": "79991234567",
 *   "code": "123456"
 * }
 * </pre>
 */
@Builder
public record VerifyPhoneRequest(
        @Phone
        String phone,

        @NotBlank(message = "Код подтверждения обязателен")
        @SmsCode
        String code
) {}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/dto/SendVerificationCodeRequest.java ===
package com.logistics.userauth.sms.adapter.in.web.dto;

import com.logistics.shared.validation.Phone;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;

/**
 * DTO для запроса отправки SMS кода верификации.
 *
 *
 * <h2>Назначение</h2>
 * Используется при верификации телефона после регистрации для защиты от фейковых аккаунтов.
 *
 * <h2>Пример</h2>
 * <pre>
 * {
 *   "phone": "79991234567"
 * }
 * </pre>
 */
@Builder
public record SendVerificationCodeRequest(
        @NotNull(message = "Номер телефона обязателен")
        @Phone
        String phone
) {}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/web/dto/package-info.java ===
/**
 * DTO слоя REST API для SMS верификации.
 *
 * <h2>Назначение</h2>
 * Содержит структуры данных запросов/ответов, используемые REST контроллерами SMS модуля.
 * DTO покрывают операции отправки кода и подтверждения телефона.
 *
 * <h2>DTO</h2>
 * <ul>
 *   <li><b>SendVerificationCodeRequest</b> — запрос на отправку кода (phone).</li>
 *   <li><b>VerifyPhoneRequest</b> — запрос на верификацию (phone + code).</li>
 * </ul>
 *
 * <h2>Валидация</h2>
 * <ul>
 *   <li>{@link com.logistics.shared.validation.Phone} — формат телефона.</li>
 *   <li>{@link com.logistics.userauth.sms.adapter.in.validation.SmsCode} — формат SMS кода.</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.adapter.in.web.dto.SendVerificationCodeRequest
 * @see com.logistics.userauth.sms.adapter.in.web.dto.VerifyPhoneRequest
 */
package com.logistics.userauth.sms.adapter.in.web.dto;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/validation/SmsCode.java ===
package com.logistics.userauth.sms.adapter.in.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;


/**
 * Аннотация валидации SMS-кода подтверждения.
 *
 * <h2>Назначение</h2>
 * Проверяет, что строка содержит только цифры и имеет длину, заданную в конфигурации приложения. 
 *
 * <h2>Конфигурация</h2>
 * Длина кода берётся из свойства {@code app.sms.verification.code-length}. 
 *
 * <h2>Требования к значению</h2>
 * <ul>
 *   <li>Значение не должно быть {@code null}.</li>
 *   <li>Значение не должно быть пустым или состоять только из пробелов.</li>
 *   <li>Значение должно содержать только цифры.</li>
 *   <li>Длина должна соответствовать {@code app.sms.verification.code-length}.</li>
 * </ul>
 *
 * <h2>Примеры</h2>
 * <pre>
 * &#64;SmsCode
 * private String code;
 * </pre>
 *
 * <h2>Примеры значений</h2>
 * Если {@code app.sms.verification.code-length = 6}: 
 * <ul>
 *   <li>Корректно: {@code "123456"}</li>
 *   <li>Некорректно: {@code "12345"}, {@code "1234567"}, {@code "12a456"}, {@code null}</li>
 * </ul>
 *
 * @see SmsCodeValidator
 */

@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SmsCodeValidator.class)
public @interface SmsCode {
    String message() default "Код должен содержать {codeLength} цифр";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/validation/SmsCodeValidator.java ===
package com.logistics.userauth.sms.adapter.in.validation;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.regex.Pattern;



/**
 * Валидатор для аннотации {@link SmsCode}.
 *
 * <h2>Назначение</h2>
 * Проверяет, что SMS-код:
 * <ol>
 *   <li>Не равен {@code null} и не является пустой строкой.</li>
 *   <li>Состоит только из цифр.</li>
 *   <li>Имеет длину, заданную в {@code app.sms.verification.code-length}.</li>
 * </ol>
 *
 * <h2>Regex</h2>
 * Используется регулярное выражение вида {@code ^\\d{N}$}, где {@code N} — длина кода из конфигурации. [file:24]
 *
 * <h2>Пример использования</h2>
 * <pre>
 * public record VerifyPhoneRequest(
 *     &#64;Phone String phone,
 *     &#64;SmsCode String code
 * ) {}
 * </pre>
 *
 * <h2>Поведение</h2>
 * <ul>
 *   <li>Если значение {@code null} или пустое — возвращается {@code false}.</li>
 *   <li>Если значение содержит нецифровые символы — возвращается {@code false}.</li>
 *   <li>Если длина не совпадает с конфигурацией — возвращается {@code false}.</li>
 * </ul>
 *
 * @see SmsCode
 */
@Component
public class SmsCodeValidator implements ConstraintValidator<SmsCode, String> {

    @Value("${app.sms.verification.code-length:6}")
    private int codeLength;

    private Pattern pattern;

    @Override
    public void initialize(SmsCode constraintAnnotation) {
        pattern = Pattern.compile("^\\d{" + codeLength + "}$");
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isBlank()) {
            return false;
        }
        return pattern.matcher(value).matches();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/in/package-info.java ===
/**
 * Входящие адаптеры (Inbound Adapters) модуля SMS верификации.
 *
 * <h2>Назначение</h2>
 * REST слой, принимающий запросы на отправку кода и верификацию телефона.
 * Преобразует HTTP DTO в команды use case-слоя.
 *
 * <h2>Подпакеты</h2>
 * <ul>
 *   <li><b>web</b> — REST контроллеры.</li>
 *   <li><b>web.dto</b> — DTO запросов/ответов.</li>
 *   <li><b>validation</b> — валидация SMS-кода (например, {@code @SmsCode}).</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.application.port.in.SendVerificationCodeUseCase
 * @see com.logistics.userauth.sms.application.port.in.VerifyPhoneUseCase
 */
package com.logistics.userauth.sms.adapter.in;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/package-info.java ===
/**
 * Адаптеры модуля SMS верификации.
 *
 * <h2>Назначение</h2>
 * Содержит входные и выходные адаптеры для интеграции SMS модуля с REST API и инфраструктурой
 * (провайдеры, Redis и т.д.).
 *
 * <h2>Подпакеты</h2>
 * <ul>
 *   <li><b>in</b> — REST контроллеры, DTO и валидация входных данных.</li>
 *   <li><b>out</b> — интеграция с persistence и SMS провайдерами.</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.adapter.in
 * @see com.logistics.userauth.sms.adapter.out
 */
package com.logistics.userauth.sms.adapter;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/provider/MockSmsProvider.java ===
package com.logistics.userauth.sms.adapter.out.provider;

import com.logistics.userauth.sms.application.port.out.SendSmsPort;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

/**
 * Mock реализация SMS сервиса для локальной разработки.
 * Просто логирует код в консоль вместо реальной отправки.
 */
@Slf4j
@Service
@ConditionalOnProperty(name = "app.sms.provider", havingValue = "mock", matchIfMissing = true)
public class MockSmsProvider implements SendSmsPort {
    @Override
    public boolean sendVerificationCode(String phone, String code) {
        log.info("╔════════════════════════════════════════════╗");
        log.info("║         MOCK SMS SERVICE                   ║");
        log.info("║  Phone: {}                      ║", phone);
        log.info("║  Code:  {}                          ║", code);
        log.info("╚════════════════════════════════════════════╝");
        return true;
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/provider/SmscSmsProvider.java ===
package com.logistics.userauth.sms.adapter.out.provider;

import com.logistics.userauth.sms.application.port.out.SendSmsPort;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

/**
 * Реализация отправки SMS через SMSC.ru API (российский провайдер).
 *
 * <h2>Регистрация SMSC.ru</h2>
 * <ol>
 *   <li>Зарегистрируйтесь на https://smsc.ru/register/</li>
 *   <li>Пополните баланс (минимум 300 руб)</li>
 *   <li>Получите логин и пароль из личного кабинета</li>
 *   <li>Установите переменные окружения SMSC_LOGIN, SMSC_PASSWORD</li>
 * </ol>
 *
 * <p><b>Стоимость:</b> ~2-4 руб за SMS по России</p>
 */
@Slf4j
@Service
@ConditionalOnProperty(name = "app.sms.provider", havingValue = "smsc")
public class SmscSmsProvider implements SendSmsPort {
    private static final String SMSC_API_URL = "https://smsc.ru/sys/send.php";

    @Value("${app.sms.smsc.login}")
    private String login;

    @Value("${app.sms.smsc.password}")
    private String password;

    @Value("${app.sms.smsc.sender}")
    private String sender;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public boolean sendVerificationCode(String phone, String code) {
        try {
             var message = String.format("Ваш код: %s. Действителен 5 минут.", code);

            var url = UriComponentsBuilder.fromHttpUrl(SMSC_API_URL)
                    .queryParam("login", login)
                    .queryParam("psw", password)
                    .queryParam("phones", phone)
                    .queryParam("mes", message)
                    .queryParam("sender", sender)
                    .queryParam("charset", "utf-8")
                    .queryParam("fmt", "3")  // JSON ответ
                    .toUriString();

            var response = restTemplate.getForObject(url, String.class);
            log.info("SMS sent to {} via SMSC. Response: {}", phone, response);

            return response != null && !response.contains("\"error\"");

        } catch (Exception e) {
            log.error("Failed to send SMS via SMSC to {}: {}", phone, e.getMessage());
            return false;
        }
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/provider/package-info.java ===
/**
 * Адаптеры SMS провайдеров.
 *
 * <h2>Назначение</h2>
 * Реализации {@link com.logistics.userauth.sms.application.port.out.SendSmsPort},
 * которые отвечают за фактическую отправку SMS (внешний API или mock для разработки).
 *
 * <h2>Реализации</h2>
 * <ul>
 *   <li><b>MockSmsProvider</b> — используется по умолчанию в режиме разработки (логирует код).</li>
 *   <li><b>SmscSmsProvider</b> — интеграция с внешним SMS API.</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.adapter.out.provider.MockSmsProvider
 * @see com.logistics.userauth.sms.adapter.out.provider.SmscSmsProvider
 * @see com.logistics.userauth.sms.application.port.out.SendSmsPort
 */
package com.logistics.userauth.sms.adapter.out.provider;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/persistence/RedisSmsRepository.java ===
package com.logistics.userauth.sms.adapter.out.persistence;

import com.logistics.shared.redis.service.RedisService;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

/**
 * Redis-реализация хранилища SMS верификации.
 *
 * <h2>Структура ключей в Redis</h2>
 * <ul>
 *   <li><b>Verification Code:</b> {@code sms:verification:{phone}}</li>
 *   <li><b>Verification Status:</b> {@code sms:verified:{phone}}</li>
 * </ul>
 *
 * <h2>TTL (Time To Live)</h2>
 * <ul>
 *   <li>Код верификации: 5 минут (конфигурируемо)</li>
 *   <li>Статус верификации: 10 минут (конфигурируемо)</li>
 * </ul>
 *
 * <h2>Формат данных</h2>
 * <p>Код верификации хранится как JSON:</p>
 * <pre>
 * {
 *   "phone": "79991234567",
 *   "code": "123456",
 *   "expiresAt": "2025-12-20T16:35:00",
 *   "attempts": 0
 * }
 * </pre>
 *
 * <p>Статус верификации хранится как строка "verified".</p>
 *
 * @see SmsRepositoryPersistenceAdapter
 */
@Slf4j
@Repository
@RequiredArgsConstructor
class RedisSmsRepository {

    private static final String KEY_PREFIX = "sms:verification:";
    private static final String VERIFIED_KEY_PREFIX = "sms:verified:";

    private final RedisService redisService;

    @Value("${logistics.redis.sms-code.ttl-minutes:5}")
    private long defaultTtlMinutes;

    void save(SmsVerificationCode code, long ttlMinutes) {
        String key = buildKey(code.getPhone());
        redisService.set(key, code, Duration.ofMinutes(ttlMinutes));
        log.debug("SMS code saved to Redis: phone={}", code.getPhone());
    }

    Optional<SmsVerificationCode> findByPhone(String phone) {
        String key = buildKey(phone);
        return redisService.get(key, SmsVerificationCode.class);
    }

    void deleteVerificationCode(String phone) {
        String key = buildKey(phone);
        redisService.delete(key);
        log.debug("SMS code deleted from Redis: phone={}", phone);
    }

    void incrementAttempts(String phone) {
        findByPhone(phone).ifPresent(code -> {
            code.setAttempts(code.getAttempts() + 1);

            long remainingTtl = redisService.getTtl(buildKey(phone), TimeUnit.MINUTES)
                    .orElse(defaultTtlMinutes);

            save(code, remainingTtl);
        });
    }

    public void markPhoneAsVerified(String phone, long ttlMinutes) {
        String key = buildVerifiedKey(phone);
        redisService.set(key, "verified", Duration.ofMinutes(ttlMinutes));
        log.info("Phone marked as verified: phone={}, ttl={}min", phone, ttlMinutes);

    }

    public boolean isPhoneVerified(String phone) {
        String key = buildVerifiedKey(phone);
        Optional<String> status = redisService.get(key, String.class);

        boolean verified = status.isPresent();
        log.debug("Phone verification status checked: phone={}, verified={}", phone, verified);

        return verified;
    }

    public void deleteVerificationStatus(String phone) {
        String key = buildVerifiedKey(phone);  // "sms:verified:79991234567"
        redisService.delete(key);
        log.info("Verification status deleted: phone={}", phone);
    }

    private String buildKey(String phone) {
        return KEY_PREFIX + phone;
    }
    private String buildVerifiedKey(String phone) {
        return VERIFIED_KEY_PREFIX + phone;
    }


}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/persistence/package-info.java ===
package com.logistics.userauth.sms.adapter.out.persistence;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/persistence/SmsRepositoryPersistenceAdapter.java ===
package com.logistics.userauth.sms.adapter.out.persistence;

import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
@RequiredArgsConstructor
public class SmsRepositoryPersistenceAdapter implements SmsRepository {
    private final RedisSmsRepository smsRepository;

    @Override
    public void save(SmsVerificationCode code, long ttlMinutes) {
        smsRepository.save(code, ttlMinutes);
    }

    @Override
    public Optional<SmsVerificationCode> findByPhone(String phone) {
        return smsRepository.findByPhone(phone);
    }

    @Override
    public void deleteVerificationCode(String phone) {
        smsRepository.deleteVerificationCode(phone);
    }

    @Override
    public void incrementAttempts(String phone) {
        smsRepository.incrementAttempts(phone);
    }

    @Override
    public void markPhoneAsVerified(String phone, long ttlMinutes) {
        smsRepository.markPhoneAsVerified(phone, ttlMinutes);
    }

    @Override
    public boolean isPhoneVerified(String phone) {
        return smsRepository.isPhoneVerified(phone);
    }

    @Override
    public void deleteVerificationStatus(String phone) {
        smsRepository.deleteVerificationStatus(phone);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/sms/adapter/out/package-info.java ===
/**
 * Исходящие адаптеры (Outbound Adapters) модуля SMS верификации.
 *
 * <h2>Назначение</h2>
 * Реализует выходные порты SMS модуля: отправку SMS через провайдер и хранение кодов/статусов в Redis.
 *
 * <h2>Подпакеты</h2>
 * <ul>
 *   <li><b>provider</b> — отправка SMS через внешние сервисы или mock-реализацию.</li>
 *   <li><b>persistence</b> — хранение кодов и статусов верификации (например, Redis).</li>
 * </ul>
 *
 * @see com.logistics.userauth.sms.application.port.out.SendSmsPort
 * @see com.logistics.userauth.sms.application.port.out.SmsRepository
 */
package com.logistics.userauth.sms.adapter.out;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/application/port/package-info.java ===
/**
 * Порты (интерфейсы) управления сессиями.
 */
package com.logistics.userauth.audit.application.port;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/application/port/out/AuditLogRepository.java ===
package com.logistics.userauth.audit.application.port.out;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.audit.adapter.out.persistence.AuditLogPersistenceAdapter;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.domain.User;

import java.util.List;
import java.util.Optional;

/**
 * Порт для работы с логами аудита.
 *
 * @see AuditLogPersistenceAdapter для реализации
 */
public interface AuditLogRepository {
    void save(AuditLog auditLog);

    void delete(AuditLog auditLog);

    List<AuditLog> findByUser(User user);

    Optional<AuditLog> findByActionType(AuditActionType actionType);

    Optional<AuditLog> findByActorIdentifier(String actorIdentifier);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/application/port/out/package-info.java ===
/**
 * Выходные порты для работы с аудитом.
 *
 * Определяют контракты для персистенции:
 * <ul>
 *   <li><b>AuditLogRepository</b> - CRUD операции с логами аудита</li>
 * </ul>
 */
package com.logistics.userauth.audit.application.port.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/application/package-info.java ===
/**
 * Прикладной слой управления аудитом.
 */
package com.logistics.userauth.audit.application;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/package-info.java ===
/**
 * Подсистема аудита и логирования действий пользователей.
 *
 * Отвечает за:
 * <ul>
 *   <li>Создание записей аудита при действиях пользователя</li>
 *   <li>Хранение информации о том, кто, что и когда сделал</li>
 *   <li>Логирование попыток несанкционированного доступа</li>
 * </ul>
 */
package com.logistics.userauth.audit;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/domain/AuditLog.java ===
package com.logistics.userauth.audit.domain;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.audit.adapter.out.persistence.AuditLogEntity;
import com.logistics.userauth.user.domain.User;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.*;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Доменная сущность для логирования аудита.
 *
 * <h2>Назначение</h2>
 * Записывает все значимые действия пользователей в системе:
 * - Вход/выход (USER_LOGIN, USER_LOGOUT)
 * - Изменение профиля (PROFILE_UPDATED)
 * - Создание заказов (ORDER_CREATED)
 * - И другие действия, определенные в AuditActionType
 *
 * <h2>Структура</h2>
 * - id: Уникальный идентификатор записи в логе
 * - user: Пользователь, совершивший действие
 * - actionType: Тип действия (ссылка на AuditActionType)
 * - tableName: Таблица, которая была изменена (если применимо)
 * - recordId: ID записи в таблице, которая была изменена
 * - actorIdentifier: Строка для идентификации актора (обычно email/телефон)
 * - newValues: JSONB с новыми значениями (для UPDATE операций)
 * - performedAt: Когда было выполнено действие
 * - ipAddress: IP-адрес клиента для аудита безопасности
 *
 * <h2>Примеры</h2>
 * <pre>
 * AuditLog log = AuditLog.builder()
 *   .user(user)
 *   .actionType(auditActionType)  // USER_LOGIN
 *   .actorIdentifier(\"john@example.com\")
 *   .performedAt(LocalDateTime.now())
 *   .ipAddress(new Inet(\"192.168.1.100\"))
 *   .build();
 * </pre>
 *
 * @see AuditActionType для типов действий
 * @see AuditLogEntity для JPA entity
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AuditLog {

    private long id;

    private User user;

    private AuditActionType actionType;

    private String tableName;

    private long recordId;

    private String actorIdentifier;

    private Map<String, Object> newValues;

    private LocalDateTime performedAt;

    private Inet ipAddress;
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/domain/package-info.java ===
/**
 * Доменная модель записи аудита.
 *
 * Описывает действие пользователя в системе:
 * <ul>
 *   <li><b>user</b> - Кто выполнил действие</li>
 *   <li><b>actionType</b> - Какое действие (от shared-library)</li>
 *   <li><b>tableName</b> - В какой таблице произошло</li>
 *   <li><b>recordId</b> - Какую запись коснулось</li>
 *   <li><b>newValues</b> - JSON с новыми значениями</li>
 *   <li><b>performedAt</b> - Когда произошло</li>
 *   <li><b>ipAddress</b> - С какого IP</li>
 * </ul>
 */
package com.logistics.userauth.audit.domain;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/AuditLogControllerMapper.java ===
package com.logistics.userauth.audit.adapter.in;

import com.logistics.userauth.audit.adapter.in.dto.AuditLogDTO;
import com.logistics.userauth.audit.domain.AuditLog;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Маппер для преобразования между Domain AuditLog и DTO.
 *
 * <h2>Назначение</h2>
 * Конвертирует AuditLog → AuditLogDTO и обратно.
 * НЕ передает пароль в DTO (по соображениям безопасности).
 *
 * @see AuditLogDTO для DTO
 * @see AuditLog для доменной сущности
 */
@Component
@RequiredArgsConstructor
public class AuditLogControllerMapper {

    private final AuditActionTypeControllerMapper actionTypeMapper;

    public AuditLogDTO toDTO(AuditLog domain) {
        return AuditLogDTO.builder()
                .user(domain.getUser())
                .actionTypeDTO(actionTypeMapper.toDTO(domain.getActionType()))
                .tableName(domain.getTableName())
                .recordId(domain.getRecordId())
                .actorIdentifier(domain.getActorIdentifier())
                .performedAt(domain.getPerformedAt())
                .newValues(domain.getNewValues())
                .build();
    }

    public AuditLog toDomain(AuditLogDTO dto) {
        return AuditLog.builder()
                .user(dto.user())
                .actionType(actionTypeMapper.toDomain(dto.actionTypeDTO()))
                .tableName(dto.tableName())
                .recordId(dto.recordId())
                .actorIdentifier(dto.actorIdentifier())
                .performedAt(dto.performedAt())
                .newValues(dto.newValues())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/package-info.java ===
/**
 * Входной адаптер для преобразования доменной модели аудита в DTO.
 */
package com.logistics.userauth.audit.adapter.in;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/AuditActionTypeControllerMapper.java ===
package com.logistics.userauth.audit.adapter.in;

import com.logistics.shared.audit_action.AuditActionTypeService;
import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.userauth.audit.adapter.in.dto.AuditActionTypeDTO;
import com.logistics.userauth.user.adapter.in.web.dto.UserDTO;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Маппер для преобразования между Domain AuditActionType и DTO.
 *
 * <h2>Назначение</h2>
 * Конвертирует AuditActionType → AuditActionTypeDTO и обратно.
 * НЕ передает пароль в DTO (по соображениям безопасности).
 *
 * @see AuditActionTypeDTO для DTO
 * @see AuditActionType для доменной сущности
 */
@Component
@RequiredArgsConstructor
public class AuditActionTypeControllerMapper {

    private final AuditActionTypeService service;

    public AuditActionTypeDTO toDTO(AuditActionType domain) {
        return AuditActionTypeDTO.builder()
                .actionType(domain.getActionName())
                .description(domain.getDescription())
                .category(domain.getCategory())
                .build();
    }

    public AuditActionType toDomain(AuditActionTypeDTO dto) {
        return AuditActionType.builder()
                .id(service.getActionTypeActionName(dto.actionType()).get().getId())
                .actionName(dto.actionType())
                .category(dto.category())
                .description(dto.description())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/dto/AuditActionTypeDTO.java ===
package com.logistics.userauth.audit.adapter.in.dto;

import lombok.Builder;

/**
 * DTO для передачи информации о типе audit-лога.
 *
 * <h2>Назначение</h2>
 * Содержит публичную информацию о типе audit-лога.
 *
 * <h2>Примеры</h2>
 * {
 *   \"actionType\": \"USER_REGISTER\",
 *   \"category\": \"Authentication\",
 *   \"category\": \"Регистрация нового пользователя\"
 * }
 */
@Builder
public record AuditActionTypeDTO (String actionType, String category, String description) {

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/dto/package-info.java ===
/**
 * DTO-классы для представления данных аудита во внешнем API.
 */
package com.logistics.userauth.audit.adapter.in.dto;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/in/dto/AuditLogDTO.java ===
package com.logistics.userauth.audit.adapter.in.dto;

import com.logistics.userauth.user.domain.User;
import lombok.Builder;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * DTO для передачи информации о audit-логах.
 *
 * <h2>Назначение</h2>
 * Содержит публичную информацию о важных логах для отправки клиенту.
 *
 * <h2>Примеры</h2>
 * {
 *   \"user\": \"1\",
 *   \"actionTypeDTO\": \"1\",
 *   \"tableName\": \"\",
 *   \"recordId\": \"\",
 *   \"actorIdentifier\": \"+71234567890\",
 *   \"newValues\": \"\",
 *   \"performedAt\": \"16.12.2025 16:20:36\",
 * }
 */
@Builder
public record AuditLogDTO (
        User user,
        AuditActionTypeDTO actionTypeDTO,
        String tableName,
        long recordId,
        String actorIdentifier,
        Map<String, Object> newValues,
        LocalDateTime performedAt
) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/package-info.java ===
/**
 * Адаптеры для преобразования представлений аудита между слоями.
 */
package com.logistics.userauth.audit.adapter;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogJpaRepository.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Spring Data JPA репозиторий для работы с сессия.
 *
 * <h2>Методы</h2>
 * Наследует от JpaRepository:
 * - save, saveAll, delete, deleteAll, findById, findAll и т.д.
 *
 * Плюс кастомные методы для поиска:
 * - findByUser(user)
 * - findByActionType(actionType)
 * - findByActorIdentifier(actorIdentifier)
 *
 * @see AuditLogEntity для сущности
 * @see AuditLogPersistenceAdapter для использования в бизнес-логике
 */
@Repository
interface AuditLogJpaRepository extends JpaRepository<AuditLogEntity, Long> {

    List<AuditLogEntity> findByUser(UserEntity user);

    Optional<AuditLogEntity> findByActionType(AuditActionTypeEntity actionType);

    Optional<AuditLogEntity> findByActorIdentifier(String actorIdentifier);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceMapper.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.adapter.in.web.dto.UserDTO;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Маппер для преобразования между Domain AuditLog и Entity AuditLog.
 *
 * <h2>Назначение</h2>
 * Конвертирует Domain → Entity и обратно.
 *
 * @see AuditLog для доменной сущности
 * @see AuditLogEntity для сущности БД
 */
@Component
@RequiredArgsConstructor
public class AuditLogPersistenceMapper {

    private final AuditActionTypeMapper actionTypeMapper;
    private final UserPersistenceMapper userMapper;

    public AuditLogEntity toEntity(AuditLog domain) {
        return AuditLogEntity.builder()
                .id(domain.getId())
                .user(userMapper.toEntity(domain.getUser()))
                .actionType(actionTypeMapper.toEntity(domain.getActionType()))
                .actorIdentifier(domain.getActorIdentifier())
                .ipAddress(domain.getIpAddress())
                .newValues(domain.getNewValues())
                .performedAt(domain.getPerformedAt())
                .tableName(domain.getTableName())
                .recordId(domain.getRecordId())
                .build();
    }

    public AuditLog toDomain(AuditLogEntity entity) {
        return AuditLog.builder()
                .id(entity.getId())
                .user(userMapper.toDomain(entity.getUser()))
                .actionType(actionTypeMapper.toDomain(entity.getActionType()))
                .actorIdentifier(entity.getActorIdentifier())
                .ipAddress(entity.getIpAddress())
                .newValues(entity.getNewValues())
                .performedAt(entity.getPerformedAt())
                .tableName(entity.getTableName())
                .recordId(entity.getRecordId())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceAdapter.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.application.port.out.AuditLogRepository;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.auth.session.adapter.out.persistence.UserSessionJpaRepository;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

/**
 * Адаптер, реализующий интерфейс AuditLogRepository для JPA.
 *
 * <h2>Паттерн</h2>
 * Это реализация Adapter паттерна:
 * - Интерфейс AuditLogRepository определяет контракт
 * - AuditLogPersistenceAdapter реализует этот контракт с помощью JPA
 * - Бизнес-логика зависит от интерфейса, а не от реализации
 *
 * <h2>Преимущества</h2>
 * - Если позже нужна другая БД (MongoDB, Redis), создаем новый адаптер
 * - Бизнес-логика не меняется
 * - Легче тестировать (подменить mock-адаптер)
 *
 * @implements AuditLogRepository
 * @see AuditLogRepository для контракта
 * @see AuditLogJpaRepository для JPA работы
 */
@Component
@RequiredArgsConstructor
public class AuditLogPersistenceAdapter implements AuditLogRepository {

    private final AuditLogJpaRepository jpaRepo;
    private final AuditLogPersistenceMapper auditLogMapper;
    private final UserPersistenceMapper userMapper;
    private final AuditActionTypeMapper auditActionTypeMapper;

    @Override
    public void save(AuditLog auditLog) {
        AuditLogEntity auditLogEntity = auditLogMapper.toEntity(auditLog);
        jpaRepo.save(auditLogEntity);
    }

    @Override
    public void delete(AuditLog auditLog) {
        AuditLogEntity auditLogEntity = auditLogMapper.toEntity(auditLog);
        jpaRepo.delete(auditLogEntity);
    }

    @Override
    public List<AuditLog> findByUser(User user) {
        return jpaRepo.findByUser(userMapper.toEntity(user)).stream().map(auditLogMapper::toDomain).toList();
    }

    @Override
    public Optional<AuditLog> findByActionType(AuditActionType actionType) {
        return jpaRepo.findByActionType(auditActionTypeMapper.toEntity(actionType)).map(auditLogMapper::toDomain);
    }

    @Override
    public Optional<AuditLog> findByActorIdentifier(String actorIdentifier) {
        return jpaRepo.findByActorIdentifier(actorIdentifier).map(auditLogMapper::toDomain);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/package-info.java ===
/**
 * Выходной адаптер для хранения логов аудита в БД через JPA.
 *
 * Содержит:
 * <ul>
 *   <li><b>AuditLogEntity</b> - JPA сущность</li>
 *   <li><b>AuditLogJpaRepository</b> - Spring Data JPA репозиторий</li>
 *   <li><b>AuditLogPersistenceMapper</b> - Преобразование Domain ↔ Entity</li>
 *   <li><b>AuditLogPersistenceAdapter</b> - Реализация интерфейса AuditLogRepository</li>
 * </ul>
 */
package com.logistics.userauth.audit.adapter.out.persistence;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogEntity.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import io.hypersistence.utils.hibernate.type.basic.PostgreSQLInetType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.annotations.Type;
import org.hibernate.type.SqlTypes;
import org.springframework.data.annotation.CreatedDate;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * JPA сущность для хранения логов аудита в БД.
 *
 * <h2>Таблица в БД</h2>
 * Schema: user_management
 * Table: audit_logs
 *
 * <h2>Структура</h2>
 * - audit_log_id: Первичный ключ
 * - user_id: Внешний ключ на users
 * - action_type_id: Внешний ключ на shared_data.audit_action_types
 * - table_name: Названи таблицы, которая была изменена
 * - record_id: ID записи в этой таблице
 * - actor_identifier: Идентификатор актора (email/телефон)
 * - new_values: JSONB с новыми значениями
 * - performed_at: Дата/время действия
 * - ip_address: inet тип (специальный тип PostgreSQL)
 *
 * @see AuditLogJpaRepository для работы с БД
 * @see AuditLogPersistenceMapper для преобразования Domain ↔ Entity
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(
        name = "audit_logs",
        schema = "user_management"
        ,
        indexes = {
                @Index(columnList = "user_id", name = "idx_audit_logs_user_id"),
                @Index(columnList = "action_type_id", name = "idx_audit_logs_action_type_id"),
                @Index(columnList = "table_name, record_id", name = "idx_audit_logs_record"),
                @Index(columnList = "performed_at", name = "idx_audit_logs_performed_at")
        }
)
@Builder
public class AuditLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "audit_logs_seq")
    @SequenceGenerator(
            name = "audit_logs_seq",
            sequenceName = "audit_logs_audit_log_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "audit_log_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private UserEntity user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "action_type_id")
    private AuditActionTypeEntity actionType;

    @Column(name = "table_name")
    private String tableName;

    @Column(name = "record_id")
    private Long recordId;

    @Column(name = "actor_identifier")
    private String actorIdentifier;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "new_values", columnDefinition = "jsonb")
    private Map<String, Object> newValues;

    @CreatedDate
    @Column(name = "performed_at")
    private LocalDateTime performedAt;

    @Column(name = "ip_address", columnDefinition = "inet")
    @Type(PostgreSQLInetType.class)
    private Inet ipAddress;
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/audit/adapter/out/package-info.java ===
/**
 * Выходные адаптеры для работы с логами аудита.
 */
package com.logistics.userauth.audit.adapter.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/package-info.java ===
/**
 * Микросервис аутентификации и управления пользователями логистической системы.
 *
 * Основные функции:
 * <ul>
 *   <li><b>Аутентификация</b> - JWT-based (access + refresh tokens)</li>
 *   <li><b>Регистрация</b> - Создание новых пользователей</li>
 *   <li><b>Token Rotation</b> - Безопасное обновление токенов</li>
 *   <li><b>Session Management</b> - Управление сессиями пользователя</li>
 *   <li><b>Audit Logging</b> - Логирование всех действий в системе</li>
 * </ul>
 *
 * REST API endpoints:
 * <ul>
 *   <li>POST /auth/sign-up - Регистрация</li>
 *   <li>POST /auth/sign-in - Вход</li>
 *   <li>POST /auth/refresh - Обновление токена</li>
 *   <li>POST /auth/logout - Выход</li>
 * </ul>
 *
 * @see com.logistics.userauth.UserAuthServiceApplication
 */
package com.logistics.userauth;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/application/port/package-info.java ===
/**
 * Порты (интерфейсы) подсистемы управления пользователями.
 */
package com.logistics.userauth.user.application.port;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/application/port/out/UserRepository.java ===
package com.logistics.userauth.user.application.port.out;

import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceAdapter;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;

import java.util.Optional;
/**
 * Порт (интерфейс) для работы с хранилищем пользователей.
 *
 * <h2>Назначение</h2>
 * Определяет контракт для всех операций с пользователями,
 * не привязываясь к конкретной реализации (JPA, MongoDB и т.д.).
 *
 * <h2>Реализации</h2>
 * - UserPersistenceAdapter (текущая - JPA)
 * - Может быть заменена на другую реализацию при необходимости
 *
 * <h2>Методы</h2>
 * - save(user) - Сохранить или обновить пользователя
 * - delete(user) - Удалить пользователя
 * - findById(id) - Найти по ID
 * - findByPhone(phone) - Найти по телефону (уникален)
 * - findByEmail(email) - Найти по email
 * - findByRole(role) - Найти первого пользователя с ролью
 * - findByFacilityId(id) - Найти по объекту (склад, ПВЗ)
 *
 * @see UserPersistenceAdapter для реализации на JPA
 * @see User для доменной сущности
 */
public interface UserRepository {
    User save(User user);

    void delete(User user);

    Optional<User> findById(Long id);

    Optional<User> findByPhone(String phone);

    Optional<User> findByEmail(String email);

    Optional<User> findByRole(UserRole role);

    Optional<User> findByFacilityId(long id);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/application/port/out/package-info.java ===
/**
 * Выходные порты для работы с пользователями.
 *
 * Определяют контракты для персистенции:
 * <ul>
 *   <li><b>UserRepository</b> - CRUD операции с пользователями</li>
 * </ul>
 *
 * Реализуются адаптерами в пакете adapter.out.persistence.
 */
package com.logistics.userauth.user.application.port.out;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/application/package-info.java ===
/**
 * Прикладной слой подсистемы управления пользователями.
 *
 * Содержит порты (интерфейсы), определяющие, как приложение работает с пользователями.
 */
package com.logistics.userauth.user.application;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/package-info.java ===
/**
 * Подсистема управления пользователями.
 *
 * Отвечает за:
 * <ul>
 *   <li>Доменную модель User (с ролями и статусами)</li>
 *   <li>CRUD операции с пользователями</li>
 *   <li>Маппинг между слоями (Domain ↔ Entity ↔ DTO)</li>
 *   <li>Интеграцию со Spring Security</li>
 * </ul>
 */
package com.logistics.userauth.user;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/UserRole.java ===
package com.logistics.userauth.user.domain;

import com.logistics.userauth.user.infrastructure.LogisticsUserDetails;

/**
 * Перечисление ролей пользователей в системе логистики.
 *
 * <h2>Роли и их значение</h2>
 *
 * Клиенты:
 * - CLIENT: Обычный клиент, заказывающий доставку
 *
 * ПВЗ (Пункт выдачи):
 * - PVZ_OPERATOR: Оператор на стойке выдачи
 * - PVZ_ADMIN: Администратор ПВЗ
 *
 * Доставка:
 * - COURIER: Курьер (доставка в пределах города)
 * - DRIVER: Водитель (доставка между городами)
 *
 * Логистика:
 * - DISPATCHER: Диспетчер (управляет маршрутами и доставками)
 *
 * Склады:
 * - WAREHOUSE_OPERATOR: Оператор склада (комплектует)
 * - WAREHOUSE_ADMIN: Администратор склада
 *
 * Администрация:
 * - HR: HR менеджер
 * - ACCOUNTANT: Бухгалтер
 * - SYSTEM_ADMIN: Администратор системы (полные права)
 * - SYSTEM: Специальная роль для системных операций
 * - UNREGISTERED_CONTACT: Контакт, еще не зарегистрировавшийся
 *
 * <h2>Spring Security интеграция</h2>
 * Преобразуется в ROLE_COURIER, ROLE_CLIENT и т.д.
 * для использования в @PreAuthorize и других security аннотациях.
 *
 * @see User для сущности пользователя
 * @see LogisticsUserDetails для Spring Security интеграции
 */
public enum UserRole {
    UNREGISTERED_CONTACT,
    CLIENT,
    PVZ_OPERATOR, PVZ_ADMIN,
    COURIER, DRIVER,
    DISPATCHER,
    WAREHOUSE_OPERATOR, WAREHOUSE_ADMIN,
    HR, ACCOUNTANT, SYSTEM_ADMIN,
    SYSTEM
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/User.java ===
package com.logistics.userauth.user.domain;

import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import lombok.*;

import java.time.LocalDateTime;
/**
 * Доменная сущность пользователя системы логистики.
 *
 * <h2>Назначение</h2>
 * Представляет пользователя с его основной информацией:
 * - Личные данные (ФИО)
 * - Контактные данные (email, телефон)
 * - Аутентификация (пароль в хэшированном виде - НИКОГДА не сырой!)
 * - Роль в системе (CLIENT, COURIER, ADMIN и т.д.)
 * - Статус (ACTIVE, ON_DELETE)
 * - Связь с объектом (склад, ПВЗ)
 *
 * <h2>Примеры ролей</h2>
 * - CLIENT: Обычный клиент, заказывающий доставку
 * - COURIER: Курьер (доставка в пределах города)
 * - DRIVER: Водитель (доставка между городами)
 * - PVZ_OPERATOR: Оператор на стойке выдачи
 * - WAREHOUSE_OPERATOR: Оператор склада (комплектует заказы)
 * - DISPATCHER: Диспетчер (управляет маршрутами)
 * - SYSTEM_ADMIN: Администратор системы
 *
 * @see UserRole для доступных ролей
 * @see UserStatus для доступных статусов
 * @see UserEntity для JPA representation
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {

    private Long id;

    private String email;

    private String phone;

    private String passwordHash;

    private String firstName;

    private String lastName;

    private String middleName;

    private UserRole role;

    private Long facilityId;

    private LocalDateTime createdTime;

    private LocalDateTime lastAccessedTime;

    private UserStatus status;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/UserStatus.java ===
package com.logistics.userauth.user.domain;

/**
 * Перечисление статусов пользователя.
 *
 * <h2>Статусы</h2>
 * - ACTIVE: Пользователь активен и может использовать систему
 * - ON_DELETE: Пользователь запросил удаление
 *             (удаление выполнится на следующий день, дается время на отмену)
 *
 * <h2>Процесс удаления пользователя</h2>
 * 1. Пользователь инициирует запрос на удаление
 * 2. Статус меняется на ON_DELETE
 * 3. Пользователю отправляется подтверждение по email
 * 4. В течение 24 часов пользователь может отменить запрос
 * 5. После 24 часов пользователь удаляется необратимо
 *
 * @see User для сущности пользователя
 */
public enum UserStatus {
    ACTIVE,
    ON_DELETE
}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/domain/package-info.java ===
/**
 * Доменная модель пользователя и связанные перечисления.
 *
 * Классы:
 * <ul>
 *   <li><b>User</b> - Основная доменная модель (идентификатор, контакты, роль, статус)</li>
 *   <li><b>UserRole</b> - Enum ролей (CLIENT, COURIER, DISPATCHER, SYSTEM_ADMIN и т.д.)</li>
 *   <li><b>UserStatus</b> - Enum статусов (ACTIVE, ON_DELETE)</li>
 * </ul>
 *
 * Особенности:
 * <ul>
 *   <li>Независимы от Spring и JPA</li>
 *   <li>Используются во всех слоях приложения</li>
 *   <li>Содержат бизнес-логику и инварианты</li>
 * </ul>
 */
package com.logistics.userauth.user.domain;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/package-info.java ===
/**
 * REST контроллеры и их зависимые DTO для операций с пользователями.
 */
package com.logistics.userauth.user.adapter.in.web;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/SignUpRequest.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.shared.validation.Password;
import com.logistics.shared.validation.Phone;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;

/**
 * Запрос для авторизации пользователя.
 *
 * <h2>Валидация</h2>
 * - phone: Обязателен, формат +7/375/77...
 * - password: Обязателен, сложный пароль
 * - email: Опциональный альтернативный способ входа
 *
 * <h2>Пример запроса</h2>
 * {
 *   \"phone\": \"+79991234567\",
 *   \"password\": \"Password123!\"
 * }
 */
@Builder
public record SignUpRequest(
        @Email
        String email,

        @NotNull
        @Phone
        String phone,

        @Password
        String password,

        @NotBlank
        String firstName,

        @NotBlank
        String lastName,

        String middleName
) {}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/UserDTO.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.userauth.user.domain.UserRole;
import lombok.Builder;

/**
 * DTO для передачи информации о пользователе в ответах.
 *
 * <h2>Назначение</h2>
 * Содержит публичную информацию пользователя для отправки клиенту.
 * НЕ содержит чувствительной информации (пароль, passwordHash).
 *
 * <h2>Примеры</h2>
 * {
 *   \"phone\": \"+79991234567\",
 *   \"firstName\": \"Иван\",
 *   \"lastName\": \"Иванов\",
 *   \"role\": \"CLIENT\"
 * }
 */
@Builder
public record UserDTO (String phone,
                       String firstName,
                       String lastName,
                       String middleName,
                       UserRole role){

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/package-info.java ===
/**
 * DTO-классы запросов и ответов REST-API для работы с пользователями.
 *
 * Содержит:
 * <ul>
 *   <li><b>SignUpRequest</b> - Запрос на регистрацию</li>
 *   <li><b>SignInRequest</b> - Запрос на вход</li>
 *   <li><b>UserDTO</b> - Ответ с информацией о пользователе</li>
 *   <li><b>FacilityDTO</b> - Информация об объекте (филиал, ПВЗ, склад)</li>
 * </ul>
 */
package com.logistics.userauth.user.adapter.in.web.dto;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/SignInRequest.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import com.logistics.shared.validation.Password;
import com.logistics.shared.validation.Phone;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;

/**
 * Запрос для регистрации нового пользователя.
 *
 * <h2>Валидация</h2>
 * - email: Должен быть в формате email
 * - phone: Формат +7XXXXXXXXXX (РФ), +375XXXXXXXXX (БР), +77XXXXXXXXX (КЗ)
 * - password: Минимум 8 символов, цифра, заглавная, строчная, спецсимвол
 * - firstName, lastName: Не пусты
 *
 * <h2>Пример запроса</h2>
 * {
 *   \"email\": \"john@example.com\",
 *   \"phone\": \"+79991234567\",
 *   \"password\": \"Password123!\",
 *   \"firstName\": \"Иван\",
 *   \"lastName\": \"Иванов\",
 *   \"middleName\": \"Иванович\"
 * }
 */
@Builder
public record SignInRequest (
        @NotNull
        @Phone
        String phone,

        @Email
        String email,

        @Password
        String password
) { }


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/web/dto/FacilityDTO.java ===
package com.logistics.userauth.user.adapter.in.web.dto;

import lombok.Builder;
/**
 * DTO для передачи информации о здании, где работает сотрудник.
 *
 * <h2>Назначение</h2>
 * Содержит публичную информацию про здание кампании.
 *
 * <h2>Примеры</h2>
 * {
 *   \"name\": \"Склад №1\",
 *   \"address\": \"г. Вологда, ул. Ленинградская, д. 25\",
 * }
 */

@Builder
public record FacilityDTO (String name, String address) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/UserControllerMapper.java ===
package com.logistics.userauth.user.adapter.in;

import com.logistics.userauth.user.adapter.in.web.dto.UserDTO;
import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * Маппер для преобразования между Domain User и DTO.
 *
 * <h2>Назначение</h2>
 * Конвертирует User → UserDTO и обратно.
 * НЕ передает пароль в DTO (по соображениям безопасности).
 *
 * @see UserDTO для DTO
 * @see User для доменной сущности
 */
@Component
public class UserControllerMapper {
    public static UserDTO toDTO(User domain) {
        return UserDTO.builder()
                .phone(domain.getPhone())
                .firstName(domain.getFirstName())
                .lastName(domain.getLastName())
                .middleName(domain.getMiddleName())
                .role(domain.getRole())
                .build();
    }

    public static User toDomain(UserDTO dto) {
        return User.builder()
                .phone(dto.phone())
                .firstName(dto.firstName())
                .lastName(dto.lastName())
                .middleName(dto.middleName())
                .role(dto.role())
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/in/package-info.java ===
/**
 * Входной адаптер для преобразования веб-DTO в доменную модель пользователя.
 *
 * Используется REST-контроллерами для отделения транспортных форматов от бизнес-логики.
 */
package com.logistics.userauth.user.adapter.in;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/package-info.java ===
/**
 * Адаптеры для преобразования представлений пользователя между слоями.
 */
package com.logistics.userauth.user.adapter;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceMapper.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.time.LocalDateTime;

/**
 * Маппер для преобразования между Domain и JPA Entity.
 *
 * <h2>Назначение</h2>
 * Конвертирует User (доменная модель) ↔ UserEntity (JPA entity).
 * Позволяет скрыть детали БД от бизнес-слоя.
 *
 * @see User для доменной модели
 * @see UserEntity для JPA entity
 */
@Component
public class UserPersistenceMapper {

    public UserEntity toEntity(User domain) {
        return UserEntity.builder()
                .id(domain.getId())
                .email(domain.getEmail())
                .phone(domain.getPhone())
                .passwordHash(domain.getPasswordHash())
                .firstName(domain.getFirstName())
                .lastName(domain.getLastName())
                .middleName(domain.getMiddleName())
                .role(domain.getRole())
                .facilityId(domain.getFacilityId())
                .status(domain.getStatus())
                .createdAt(domain.getCreatedTime())
                .lastAccessedAt(domain.getLastAccessedTime())
                .build();
    }

    public User toDomain(UserEntity entity) {
        return User.builder()
                .id(entity.getId())
                .email(entity.getEmail())
                .phone(entity.getPhone())
                .passwordHash(entity.getPasswordHash())
                .firstName(entity.getFirstName())
                .lastName(entity.getLastName())
                .middleName(entity.getMiddleName())
                .role(entity.getRole())
                .facilityId(entity.getFacilityId())
                .status(entity.getStatus())
                .createdTime(entity.getCreatedAt())
                .lastAccessedTime(entity.getLastAccessedAt())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceAdapter.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

/**
 * Адаптер, реализующий интерфейс UserRepository для JPA.
 *
 * <h2>Паттерн</h2>
 * Это реализация Adapter паттерна:
 * - Интерфейс UserRepository определяет контракт
 * - UserPersistenceAdapter реализует этот контракт с помощью JPA
 * - Бизнес-логика зависит от интерфейса, а не от реализации
 *
 * <h2>Преимущества</h2>
 * - Если позже нужна другая БД (MongoDB, Redis), создаем новый адаптер
 * - Бизнес-логика не меняется
 * - Легче тестировать (подменить mock-адаптер)
 *
 * @implements UserRepository
 * @see UserRepository для контракта
 * @see UserJpaRepository для JPA работы
 */
@RequiredArgsConstructor
@Component
public class UserPersistenceAdapter implements UserRepository {

    private final UserJpaRepository jpaRepo;
    private final UserPersistenceMapper mapper;

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        var saved = jpaRepo.save(entity);
        return mapper.toDomain(saved);
    }

    @Override
    public void delete(User user) {
        UserEntity entity = mapper.toEntity(user);
        jpaRepo.delete(entity);
    }

    @Override
    public Optional<User> findById(Long id) {
        return jpaRepo.findById(id).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByPhone(String phone) {
        return jpaRepo.findByPhone(phone).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByEmail(String email) {
        return jpaRepo.findByEmail(email).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByRole(UserRole role) {
        return jpaRepo.findByRole(role).map(mapper::toDomain);
    }

    @Override
    public Optional<User> findByFacilityId(long id) {
        return jpaRepo.findByFacilityId(id).map(mapper::toDomain);
    }


}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/package-info.java ===
/**
 * Выходной адаптер для работы с пользователями через JPA.
 *
 * Содержит:
 * <ul>
 *   <li><b>UserEntity</b> - JPA сущность для БД</li>
 *   <li><b>UserJpaRepository</b> - Spring Data JPA репозиторий</li>
 *   <li><b>UserPersistenceMapper</b> - Преобразование Domain ↔ Entity</li>
 *   <li><b>UserPersistenceAdapter</b> - Реализация интерфейса UserRepository</li>
 * </ul>
 *
 * Паттерн Adapter обеспечивает, что использование JPA скрыто от бизнес-логики.
 */
package com.logistics.userauth.user.adapter.out.persistence;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserEntity.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import lombok.*;
import org.springframework.data.annotation.CreatedDate;

import java.time.Instant;
import java.time.LocalDateTime;

/**
 * JPA сущность для хранения пользователей в БД.
 *
 * <h2>Таблица в БД</h2>
 * Schema: user_management
 * Table: users
 *
 * Уникальность: phone UNIQUE
 * Индексы: email, phone, role_name, last_accessed_at, facility_id
 *
 * @see UserJpaRepository для работы с БД
 * @see UserPersistenceMapper для преобразования Domain ↔ Entity
 */
@Entity
@Table(
        name = "users",
        schema = "user_management",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "phone")
        },
        indexes = {
                @Index(columnList = "email", name = "idx_users_email"),
                @Index(columnList = "phone", name = "idx_users_phone"),
                @Index(columnList = "role_name", name = "idx_users_role_name"),
                @Index(columnList = "last_accessed_at", name = "idx_users_last_accessed"),
                @Index(columnList = "facility_id", name = "idx_users_facility_id")
        }
)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_seq")
    @SequenceGenerator(
            name = "users_seq",
            sequenceName = "users_user_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "user_id")
    private Long id;

    @Column(name = "email")
    @Email
    private String email;

    @Column(name = "phone", nullable = false)
    private String phone;

    @Column(name = "password_hash")
    private String passwordHash;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Column(name = "middle_name")
    private String middleName;

    @Enumerated(EnumType.STRING)
    @Column(name = "role_name", nullable = false)
    private UserRole role;

    @Column(name = "facility_id")
    private Long facilityId;

    @Enumerated(EnumType.STRING)
    @Column(name = "user_status")
    private UserStatus status;

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "last_accessed_at")
    private LocalDateTime lastAccessedAt;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/persistence/UserJpaRepository.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.UserRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * Spring Data JPA репозиторий для работы с пользователями.
 *
 * <h2>Методы</h2>
 * Наследует от JpaRepository:
 * - save, saveAll, delete, deleteAll, findById, findAll и т.д.
 *
 * Плюс кастомные методы для поиска:
 * - findByEmail(email)
 * - findByPhone(phone)
 * - findByRole(role)
 * - findByFacilityId(id)
 *
 * @see UserEntity для сущности
 * @see UserPersistenceAdapter для использования в бизнес-логике
 */
@Repository
public interface UserJpaRepository extends JpaRepository<UserEntity, Long> {

    Optional<UserEntity> findByEmail(String email);

    Optional<UserEntity> findByPhone(String phone);

    Optional<UserEntity> findByRole(UserRole role);

    Optional<UserEntity> findByFacilityId(long id);

}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/adapter/out/package-info.java ===
/**
 * Выходные адаптеры для работы с пользователями через различные каналы (БД, API и т.д.).
 */
package com.logistics.userauth.user.adapter.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/infrastructure/LogisticsUserDetails.java ===
package com.logistics.userauth.user.infrastructure;

import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;

/**
 * Адаптер доменной модели User к интерфейсу UserDetails Spring Security.
 *
 * Реализует UserDetails, чтобы Spring Security мог использовать доменного
 * пользователя для аутентификации и авторизации.
 *
 * Основные функции:
 * - Возвращает Authorities на основе UserRole (преобразует CLIENT → ROLE_CLIENT)
 * - Предоставляет passwordHash как getPassword()
 * - Использует phone как getUsername() (основной идентификатор)
 * - Всегда возвращает true для isAccountNonExpired, isAccountNonLocked,
 *   isCredentialsNonExpired, isEnabled (логика блокировки в доменной модели)
 *
 * Пример использования:
 * ```java
 * User user = userRepository.findByPhone(phone);
 * UserDetails userDetails = new LogisticsUserDetails(user);
 * Authentication auth = new UsernamePasswordAuthenticationToken(
 *     userDetails, null, userDetails.getAuthorities()
 * );
 * SecurityContextHolder.getContext().setAuthentication(auth);
 * ```
 *
 * @see UserDetails
 * @see LogisticsUserDetailsService
 * @see User
 * @see UserRole
 */
@RequiredArgsConstructor
public class LogisticsUserDetails implements UserDetails {

    private final User user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority("ROLE_" + user.getRole().name()));
    }

    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }

    @Override
    public String getUsername() {
        return user.getPhone();
    }

    public Long getId() {
        return user.getId();
    }


    @Override
    public boolean isAccountNonExpired() { return true; }
    @Override
    public boolean isAccountNonLocked() { return true; }
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    @Override
    public boolean isEnabled() { return true; }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/infrastructure/package-info.java ===
/**
 * Инфраструктурные классы интеграции доменной модели пользователя со Spring Security.
 *
 * Реализует интерфейсы Spring Security:
 * <ul>
 *   <li><b>LogisticsUserDetails</b> - Адаптер User к UserDetails Spring Security</li>
 *   <li><b>LogisticsUserDetailsService</b> - Загрузка пользователя из БД по phone (username)</li>
 * </ul>
 *
 * Используется для:
 * <ul>
 *   <li>Аутентификации через JWT (JwtAuthenticationFilter)</li>
 *   <li>Проверки прав доступа к защищённым endpoint'ам</li>
 *   <li>Заполнения SecurityContext информацией о текущем пользователе</li>
 * </ul>
 */
package com.logistics.userauth.user.infrastructure;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/user/infrastructure/LogisticsUserDetailsService.java ===
package com.logistics.userauth.user.infrastructure;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/**
 * Реализация UserDetailsService для загрузки пользователей из базы данных.
 *
 * Интегрирует доменный репозиторий UserRepository с механизмом
 * аутентификации Spring Security.
 *
 * Процесс загрузки пользователя:
 * 1. Принимает phone как username (Spring Security вызывает с username)
 * 2. Ищет пользователя в БД через UserRepository.findByPhone()
 * 3. Если не найден - выбрасывает UsernameNotFoundException
 * 4. Если найден - оборачивает в LogisticsUserDetails
 *
 * Используется:
 * - При аутентификации через JWT (JwtAuthenticationFilter)
 * - При аутентификации через форму логина (если включена)
 *
 * Пример workflow:
 * ```java
 * // Spring Security вызывает автоматически:
 * UserDetails userDetails = userDetailsService.loadUserByUsername("+79991234567");
 * // userDetails содержит все данные для проверки прав доступа
 * ```
 *
 * @see UserDetailsService
 * @see LogisticsUserDetails
 * @see UserRepository#findByPhone(String)
 * @see JwtAuthenticationFilter
 */
@Service
@RequiredArgsConstructor
public class LogisticsUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    /**
     * Загружает пользователя по номеру телефона.
     *
     * @param phone номер телефона пользователя (используется как username)
     * @return UserDetails с полной информацией о пользователе
     * @throws UsernameNotFoundException если пользователь с таким телефоном не найден
     */
    @Override
    public UserDetails loadUserByUsername(String phone) throws UsernameNotFoundException {
        User user = userRepository.findByPhone(phone)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + phone));
        return new LogisticsUserDetails(user);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/web/GlobalExceptionHandler.java ===
package com.logistics.userauth.common.web;

import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.exception.PhoneNotVerifiedException;
import com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException;
import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.exception.SmsDeliveryException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * Глобальный обработчик исключений для всех REST endpoints.
 *
 * <h2>Назначение</h2>
 * Перехватывает исключения и возвращает единообразный JSON формат ошибок.
 *
 * <h2>Обработанные исключения</h2>
 * - BadCredentialsException → 401 INVALID_CREDENTIALS
 * - DataIntegrityViolationException → 409 CONFLICT
 * - MethodArgumentNotValidException → 400 VALIDATION_FAILED
 * - InvalidRefreshTokenException → 401 INVALID_REFRESH_TOKEN
 * - Все остальные Exception → 500 INTERNAL_SERVER_ERROR
 *
 * <h2>Формат ответа</h2>
 * {
 *   \"error\": \"ERROR_CODE\",
 *   \"message\": \"Human-readable message\",
 *   \"fields\": { \"fieldName\": \"error message\" }  // только для VALIDATION_FAILED
 * }
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Обработка ошибок аутентификации (неверные учетные данные).
     *
     * @param ex BadCredentialsException
     * @return ResponseEntity с кодом 401
     */
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<Map<String, Object>> handleBadCredentials(BadCredentialsException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "INVALID_CREDENTIALS");
        body.put("message", "Неверный телефон или пароль");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);
    }

    /**
     * Обработка ошибок целостности данных (duplicate keys, constraint violations).
     *
     * @param ex DataIntegrityViolationException
     * @return ResponseEntity с кодом 409
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<Map<String, Object>> handleDataIntegrity(DataIntegrityViolationException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "CONFLICT");
        body.put("message", "Пользователь с таким телефоном или email уже существует");
        return ResponseEntity.status(HttpStatus.CONFLICT).body(body);
    }

    /**
     * Обработка ошибок валидации входных параметров.
     *
     * @param ex MethodArgumentNotValidException
     * @return ResponseEntity с кодом 400 и деталями ошибок по полям
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> fieldErrors = new HashMap<>();
        for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) {
            fieldErrors.put(fieldError.getField(), fieldError.getDefaultMessage());
        }

        Map<String, Object> body = new HashMap<>();
        body.put("error", "VALIDATION_FAILED");
        body.put("fields", fieldErrors);
        return ResponseEntity.badRequest().body(body);
    }

    /**
     * Обработка ошибок невалидного refresh token.
     *
     * @param ex InvalidRefreshTokenException
     * @return ResponseEntity с кодом 401
     */
    @ExceptionHandler(InvalidRefreshTokenException.class)
    public ResponseEntity<Map<String, Object>> handleInvalidRefreshToken(InvalidRefreshTokenException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "INVALID_REFRESH_TOKEN");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);
    }

    /**
     * Обработка превышения rate limit.
     *
     * @param ex RateLimitExceededException
     * @return ResponseEntity с кодом 429
     */
    @ExceptionHandler(RateLimitExceededException.class)
    public ResponseEntity<Map<String, Object>> handleRateLimitExceeded(
            RateLimitExceededException ex
    ) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "RATE_LIMIT_EXCEEDED");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(body);
    }

    /**
     * Обработка ошибки доставки SMS.
     *
     * @param ex SmsDeliveryException
     * @return ResponseEntity с кодом 503
     */
    @ExceptionHandler(SmsDeliveryException.class)
    public ResponseEntity<Map<String, Object>> handleSmsDeliveryError(
            SmsDeliveryException ex
    ) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "SMS_DELIVERY_FAILED");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(body);
    }

    /**
     * Обработка ошибок невалидного кода верификации.
     *
     * @param ex InvalidVerificationCodeException
     * @return ResponseEntity с кодом 400
     */
    @ExceptionHandler(InvalidVerificationCodeException.class)
    public ResponseEntity<Map<String, Object>> handleInvalidVerificationCode(
            InvalidVerificationCodeException ex
    ) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "INVALID_VERIFICATION_CODE");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(body);
    }


    /**
     * Обработка ошибки верификации телефона.
     *
     * @param ex PhoneNotVerifiedException
     * @return ResponseEntity с кодом 400
     */
    @ExceptionHandler(PhoneNotVerifiedException.class)
    public ResponseEntity<Map<String, Object>> handlePhoneNotVerified(
            PhoneNotVerifiedException ex
    ) {
        Map<String, Object> body = new HashMap<>();
        body.put("error", "PHONE_NOT_VERIFIED");
        body.put("message", ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(body);
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/web/package-info.java ===
/**
 * Общие веб-компоненты микросервиса.
 *
 * Содержит:
 * <ul>
 *   <li><b>GlobalExceptionHandler</b> - Глобальный обработчик исключений (@ControllerAdvice)</li>
 * </ul>
 *
 * Преобразует исключения в единообразные HTTP-ответы (ошибки с кодом, сообщением и деталями).
 */
package com.logistics.userauth.common.web;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/LogoutOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint выхода из аккаунта.
 *
 * @Operation для Swagger
 * - summary: \"Выход из системы\"
 * - description: \"Отзывает (revoke) refresh token, делая его неиспользуемым\"
 * - tags: {\"Аутентификация\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Выход из системы",
        description = "Отзывает (revoke) refresh token, делая его неиспользуемым",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(responseCode = "204", description = "Успешный выход"),
        @ApiResponse(responseCode = "401", description = "Refresh token невалиден")
})
public @interface LogoutOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/VerifyPhoneOperation.java ===
package com.logistics.userauth.common.api;

import com.logistics.userauth.sms.adapter.in.web.dto.VerifyPhoneResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint проверки SMS кода.
 *
 * @Operation для Swagger
 * - summary: \"Проверить SMS код\"
 * - description: \"Проверяет введенный пользователем 6-значный код. Максимум 3 попытки ввода. После 3 неудачных попыток код удаляется.\"
 * - tags: {\"SMS\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Проверить SMS код",
        description = "Проверяет введенный пользователем 6-значный код. Максимум 3 попытки ввода. После 3 неудачных попыток код удаляется.",
        tags = {"SMS"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "Телефон успешно подтвержден",
                content = @Content(
                        mediaType = "application/json",
                        schema = @Schema(implementation = VerifyPhoneResponse.class)
                )
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Неверный код или истек срок действия",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "404",
                description = "Код не найден. Запросите новый код.",
                content = @Content(mediaType = "application/json")
        )
})
public @interface VerifyPhoneOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/SignInOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint авторизации.
 *
 * @Operation для Swagger
 * - summary: \"Авторизация пользователя\"
 * - description: \"Проверяет учетные данные пользователя (телефон/пароль) и выдает JWT access token и refresh token\"
 * - tags: {\"Аутентификация\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Авторизация пользователя",
        description = "Проверяет учетные данные пользователя (телефон/пароль) и выдает JWT access token и refresh token",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "Успешная авторизация",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "401",
                description = "Неверные учетные данные (телефон или пароль)",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Ошибка валидации входных данных"
        )
})
public @interface SignInOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/RefreshOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint обновления access токена.
 *
 * @Operation для Swagger
 * - summary: \"Обновление access токена\"
 * - description: \"Использует refresh token для выдачи нового access token и нового refresh token (token rotation)\"
 * - tags: {\"Аутентификация\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Обновление access токена",
        description = "Использует refresh token для выдачи нового access token и нового refresh token (token rotation)",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "Новые токены успешно выданы"
        ),
        @ApiResponse(
                responseCode = "401",
                description = "Refresh token невалиден, истек или был отозван"
        )
})
public @interface RefreshOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/SignUpOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint регистрации.
 *
 * @Operation для Swagger
 * - summary: \"Регистрация нового пользователя\"
 * - description: \"Использует refresh token для выдачи нового access token и нового refresh token (token rotation)\"
 * - tags: {\"Аутентификация\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Регистрация нового пользователя",
        description = "Создает новый аккаунт пользователя с ролью CLIENT и выдает JWT tokens",
        tags = {"Аутентификация"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "201",
                description = "Пользователь успешно зарегистрирован"
        ),
        @ApiResponse(
                responseCode = "409",
                description = "Пользователь с таким телефоном или email уже существует"
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Ошибка валидации входных данных"
        )
})
public @interface SignUpOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/package-info.java ===
/**
 * Набор meta-аннотаций для описания REST-операций в OpenAPI/Swagger.
 *
 * Оборачивают стандартные аннотации OpenAPI (@Operation, @ApiResponse и т.д.),
 * чтобы сократить дублирование описаний в контроллерах.
 *
 * Примеры:
 * <ul>
 *   <li><b>@SignUpOperation</b> - Аннотирует endpoint регистрации</li>
 *   <li><b>@SignInOperation</b> - Аннотирует endpoint входа</li>
 *   <li><b>@RefreshOperation</b> - Аннотирует endpoint обновления токена</li>
 *   <li><b>@LogoutOperation</b> - Аннотирует endpoint выхода</li>
 *   <li><b>@SendVerificationCodeOperation</b> - Аннотирует endpoint отправления кода</li>
 *   <li><b>@LogoutOperation</b> - Аннотирует endpoint подтверждения </li>
 * </ul>
 *
 * Использование:
 * <pre>{@code
 * @PostMapping("/sign-up")
 * @SignUpOperation
 * public ResponseEntity<?> signUp(@Valid @RequestBody SignUpRequest request) { }
 * }</pre>
 */
package com.logistics.userauth.common.api;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/api/SendVerificationCodeOperation.java ===
package com.logistics.userauth.common.api;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

/**
 * Аннотация для документирования endpoint отправки SMS кода.
 *
 * @Operation для Swagger
 * - summary: \"Отправить SMS код верификации\"
 * - description: \"Генерирует и отправляет 6-значный код на указанный номер телефона. Код действителен 5 минут. Максимум 3 попытки ввода.\"
 * - tags: {\"SMS\"}
 *
 * @ApiResponses документируют все возможные HTTP ответы
 */
@Operation(
        summary = "Отправить SMS код верификации",
        description = "Генерирует и отправляет 6-значный код на указанный номер телефона. Код действителен 5 минут. Максимум 3 попытки ввода.",
        tags = {"SMS"}
)
@ApiResponses(value = {
        @ApiResponse(
                responseCode = "200",
                description = "SMS код успешно отправлен"
        ),
        @ApiResponse(
                responseCode = "400",
                description = "Некорректный формат номера телефона",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "429",
                description = "Превышен лимит запросов. Повторите через 60 секунд.",
                content = @Content(mediaType = "application/json")
        ),
        @ApiResponse(
                responseCode = "500",
                description = "Не удалось отправить SMS. Попробуйте позже.",
                content = @Content(mediaType = "application/json")
        )
})
public @interface SendVerificationCodeOperation {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/common/package-info.java ===
/**
 * Общие компоненты микросервиса аутентификации.
 */
package com.logistics.userauth.common;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RegisterUserService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.exception.PhoneNotVerifiedException;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RegisterUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

/**
 * Сервис для регистрации новых пользователей.
 *
 * <h2>Процесс</h2>
 * 1. Получает данные нового пользователя
 * 2. Проверяет уникальность телефона/email
 * 3. Хэширует пароль с помощью PasswordEncoder (BCrypt)
 * 4. Создает пользователя с ролью CLIENT и статусом ACTIVE
 * 5. Сохраняет в БД
 * 6. Генерирует access token
 * 7. Создает refresh token
 * 8. Возвращает оба токена
 *
 * <h2>Исключения</h2>
 * - DataIntegrityViolationException: Если телефон/email уже существует
 *
 * @implements RegisterUserUseCase
 */
@Service
@RequiredArgsConstructor
public class RegisterUserService implements RegisterUserUseCase {
    private final UserRepository userRepository;
    private final SmsRepository smsRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    /**
     * Регистрирует нового пользователя и возвращает пару токенов (access/refresh).
     *
     * <p>Алгоритм:</p>
     * <ul>
     *   <li>Хеширует пароль через {@link PasswordEncoder}.</li>
     *   <li>Создаёт доменного пользователя с ролью CLIENT и статусом ACTIVE.</li>
     *   <li>Сохраняет пользователя через {@link UserRepository}.</li>
     *   <li>Генерирует access token.</li>
     *   <li>Создаёт refresh token (новая сессия) с привязкой к IP и User-Agent.</li>
     * </ul>
     *
     * @param command Команда регистрации (email, phone, rawPassword, ФИО, ipAddress, userAgent).
     * @return DTO с accessToken и refreshToken.
     * @throws DataIntegrityViolationException
     *         При нарушении уникальности (например, телефон или email уже существуют) — обычно маппится в 409 обработчиком ошибок.
     * @see RegisterUserUseCase
     * @see InternalCreateRefreshTokenUseCase
     */
    @Override
    public JwtAuthenticationResponse register(RegisterUserCommand command) {
        validatePhoneVerification(command.phone());

        var user = User.builder()
                .email(command.email())
                .phone(command.phone())
                .passwordHash(passwordEncoder.encode(command.rawPassword()))
                .firstName(command.firstName())
                .lastName(command.lastName())
                .middleName(command.middleName())
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        var saved = userRepository.save(user);

        smsRepository.deleteVerificationStatus(command.phone());

        var accessToken = tokenGenerator.generateAccessToken(saved);

        var refreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(saved.getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(accessToken, refreshToken);
    }

    private void validatePhoneVerification(String phone) {
        if (!smsRepository.isPhoneVerified(phone)) {
            throw new PhoneNotVerifiedException(
                    "Необходимо подтвердить номер телефона перед регистрацией"
            );
        }
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RefreshAccessTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RefreshAccessTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

/**
 * Сервис для обновления access токена с использованием refresh токена.
 *
 * <h2>Реализует паттерн Token Rotation</h2>
 * 1. Принимает старый refresh token
 * 2. Проверяет его валидность (не истек, не отозван)
 * 3. Помечает старый refresh token как отозванный
 * 4. Выдает новый access token и новый refresh token
 *
 * Это повышает безопасность: если refresh token будет скомпрометирован,
 * злоумышленник сможет его использовать только один раз.
 *
 * <h2>Валидация</h2>
 * Проверяет:
 * - Токен существует в БД
 * - Токен не был отозван (revoked = false)
 * - Токен не истек (expiresAt >= now)
 *
 * <h2>Исключения</h2>
 * - InvalidRefreshTokenException: Если токен невалиден, отозван или истек
 *
 * @implements RefreshAccessTokenUseCase
 * @Transactional используется для атомарности операции
 */
@Service
@RequiredArgsConstructor
public class RefreshAccessTokenService implements RefreshAccessTokenUseCase {

    private final UserSessionRepository repository;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    /**
     * Обновляет access token по refresh token и выдаёт новую пару токенов (Token Rotation).
     *
     * <p>Алгоритм Token Rotation:</p>
     * <ol>
     *   <li>Находит сессию по refresh token.</li>
     *   <li>Проверяет, что токен не отозван и не истёк.</li>
     *   <li>Помечает текущую сессию как revoked=true (старый refresh становится недействительным).</li>
     *   <li>Генерирует новый access token.</li>
     *   <li>Создаёт новый refresh token (новая сессия) с привязкой к текущим IP и User-Agent.</li>
     * </ol>
     *
     * @param command Команда обновления (refreshToken, ipAddress, userAgent).
     * @return DTO с новым accessToken и новым refreshToken.
     * @throws InvalidRefreshTokenException
     *         Если refresh token не найден, отозван или истёк.
     * @see RefreshAccessTokenUseCase
     * @see UserSessionRepository
     */
    @Override
    @Transactional
    public JwtAuthenticationResponse refresh(RefreshAccessTokenCommand command) {
        var session = repository.findByRefreshToken(command.refreshToken())
                .orElseThrow(() -> new InvalidRefreshTokenException("Invalid refresh token"));

        validate(session);

        String newAccessToken = tokenGenerator.generateAccessToken(session.getUser());

        session.setRevoked(true);
        repository.save(session);

        String newRefreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(session.getUser().getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(newAccessToken, newRefreshToken);
    }

    /**
     * Проверяет валидность найденной пользовательской сессии для refresh token.
     *
     * @param session Сессия пользователя, найденная по refresh token.
     * @throws InvalidRefreshTokenException
     *         Если сессия помечена как revoked=true или если expiresAt меньше текущего времени.
     */
    private static void validate(UserSession session) {
        if (session.isRevoked()) {
            throw new InvalidRefreshTokenException("Refresh token is revoked");
        }

        if (session.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new InvalidRefreshTokenException("Refresh token is expired");
        }
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/package-info.java ===
/**
 * Реализации use cases JWT-аутентификации.
 *
 * Содержат бизнес-логику:
 * <ul>
 *   <li><b>AuthenticateUserService</b> - Проверка пароля, генерация токенов</li>
 *   <li><b>RegisterUserService</b> - Хеширование пароля, создание пользователя</li>
 *   <li><b>RefreshAccessTokenService</b> - Token Rotation (отзыв старого, создание новых)</li>
 *   <li><b>RevokeRefreshTokenService</b> - Отзыв refresh token (logout)</li>
 *   <li><b>InternalCreateRefreshTokenService</b> - Создание новой сессии</li>
 * </ul>
 *
 * Каждый сервис реализует соответствующий port.in.
 */
package com.logistics.userauth.auth.jwt.application.usecase;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/AuthenticateUserService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.auth.jwt.application.port.in.AuthenticateUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import javax.naming.AuthenticationException;

/**
 * Сервис для аутентификации пользователя.
 *
 * <h2>Процесс</h2>
 * 1. Находит пользователя по телефону
 * 2. Проверяет пароль используя PasswordEncoder
 * 3. Генерирует access token
 * 4. Создает refresh token
 * 5. Возвращает оба токена в ответе
 *
 * <h2>Исключения</h2>
 * - BadCredentialsException: Если телефон не найден или пароль неверен
 *
 * @implements AuthenticateUserUseCase
 */
@Service
@RequiredArgsConstructor
public class AuthenticateUserService implements AuthenticateUserUseCase {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenGeneratorPort tokenGenerator;
    private final InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    /**
     * Выполняет аутентификацию пользователя по номеру телефона и паролю и возвращает пару токенов (access/refresh).
     *
     * <p>Алгоритм:</p>
     * <ul>
     *   <li>Ищет пользователя по телефону.</li>
     *   <li>Проверяет пароль через {@link PasswordEncoder}.</li>
     *   <li>Генерирует access token.</li>
     *   <li>Создаёт refresh token через внутренний use case создания сессии (привязка к IP и User-Agent).</li>
     * </ul>
     *
     * @param command Команда аутентификации (phone, password, ipAddress, userAgent).
     * @return DTO с accessToken и refreshToken.
     * @throws BadCredentialsException
     *         Если пользователь не найден или пароль неверный (сообщение намеренно общее).
     * @see AuthenticateUserUseCase
     * @see InternalCreateRefreshTokenUseCase
     */
    @Override
    public JwtAuthenticationResponse authenticate(AuthenticateUserCommand command) {
        var user = userRepository.findByPhone(command.phone())
                .orElseThrow(() -> new BadCredentialsException("Invalid credentials"));

        if (!passwordEncoder.matches(command.password(), user.getPasswordHash())) {
            throw new BadCredentialsException("Invalid credentials");
        }

        var accessToken = tokenGenerator.generateAccessToken(user);

        var refreshToken = createRefreshTokenUseCase.create(
                CreateRefreshTokenCommand.builder()
                        .userId(user.getId())
                        .ipAddress(command.ipAddress())
                        .userAgent(command.userAgent())
                        .build()
        );
        return new JwtAuthenticationResponse(accessToken, refreshToken);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/RevokeRefreshTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.port.in.RevokeRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;


/**
 * Сервис для отзыва (revoke) refresh токенов.
 *
 * <h2>Назначение</h2>
 * Отзыв токена делает его непригодным для дальнейшего использования.
 * Используется при logout и других операциях завершения сессии.
 *
 * <h2>Процесс</h2>
 * 1. Находит сессию по refresh token
 * 2. Помечает сессию как revoked = true
 * 3. Сохраняет в БД
 *
 * При попытке использовать отозванный токен для обновления access token
 * будет выброшено исключение InvalidRefreshTokenException.
 *
 * <h2>Исключения</h2>
 * - InvalidRefreshTokenException: Если токен не найден в БД
 *
 * @implements RevokeRefreshTokenUseCase
 */
@Service
@RequiredArgsConstructor
public class RevokeRefreshTokenService implements RevokeRefreshTokenUseCase {

    private final UserSessionRepository repository;

    /**
     * Отзывает refresh token (logout), помечая соответствующую сессию как revoked=true.
     *
     * <p>После выполнения:</p>
     * <ul>
     *   <li>refresh token больше не может быть использован для обновления access token;</li>
     *   <li>уже выданный access token продолжит действовать до истечения TTL (если не применяются дополнительные механизмы блокировки).</li>
     * </ul>
     *
     * @param command Команда отзыва refresh token.
     * @throws InvalidRefreshTokenException
     *         Если refresh token не найден (или сессия недоступна).
     * @see RevokeRefreshTokenUseCase
     */
    @Override
    public void revoke(RevokeRefreshTokenCommand command) {
        var session = repository.findByRefreshToken(command.refreshToken()).orElseThrow(() -> new InvalidRefreshTokenException("Invalid refresh token"));
        session.setRevoked(true);
        repository.save(session);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/usecase/InternalCreateRefreshTokenService.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.application.port.out.UserRepository;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Внутренний сервис для создания refresh токенов.
 *
 * <h2>Назначение</h2>
 * Отмечен как \"Internal\" потому что:
 * - Не должен вызваться напрямую из контроллеров
 * - Используется другими use cases (Register, Authenticate, Refresh)
 * - Инкапсулирует логику создания и сохранения сессии
 *
 * <h2>Каждый refresh token уникален и привязан к</h2>
 * - Конкретному пользователю
 * - Конкретному устройству (IP + User-Agent)
 * - Определенному времени истечения (TTL из конфигурации)
 *
 * <h2>Конфигурация</h2>
 * TTL читается из app.jwt.refresh-expiration в application.yml
 *
 * @implements InternalCreateRefreshTokenUseCase
 */
@Service
@RequiredArgsConstructor
public class InternalCreateRefreshTokenService implements InternalCreateRefreshTokenUseCase {

    private final UserSessionRepository sessionRepository;
    private final UserRepository userRepository;

    @Value("${app.jwt.refresh-expiration}")
    private long refreshTokenTtlSeconds;

    /**
     * Внутренний use case: создаёт новый refresh token и сохраняет пользовательскую сессию.
     *
     * <p>Особенности:</p>
     * <ul>
     *   <li>refresh token генерируется как UUID;</li>
     *   <li>expiresAt вычисляется как now + refreshTokenTtlSeconds;</li>
     *   <li>сессия привязывается к IP (если передан) и User-Agent;</li>
     *   <li>revoked устанавливается в false.</li>
     * </ul>
     *
     * @param command Команда создания refresh token (userId, ipAddress, userAgent).
     * @return Сгенерированный refresh token (строка UUID).
     * @throws RuntimeException Если пользователь по userId не найден.
     * @see InternalCreateRefreshTokenUseCase
     * @see UserSession
     */
    @Override
    public String create(CreateRefreshTokenCommand command) {
        var user = userRepository.findById(command.userId()).orElseThrow(() ->  new RuntimeException("User not found"));

        String refreshToken = UUID.randomUUID().toString();

        var session = UserSession.builder()
                .user(user)
                .refreshToken(refreshToken)
                .expiresAt(LocalDateTime.now().plusSeconds(refreshTokenTtlSeconds))
                .createdAt(LocalDateTime.now())
                .ipAddress(command.ipAddress() != null ? new Inet(command.ipAddress()): null)
                .userAgent(command.userAgent())
                .revoked(false)
                .build();

        sessionRepository.save(session);
        return refreshToken;
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RegisterUserUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.usecase.RegisterUserService;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;

/**
 * Use Case для регистрации нового пользователя.
 *
 * <h2>Процесс</h2>
 * 1. Получает команду с данными пользователя
 * 2. Проверяет уникальность телефона/email
 * 3. Создает новый аккаунт с ролью CLIENT
 * 4. Выдает access token и refresh token
 *
 * <h2>Реализация</h2>
 * RegisterUserService
 *
 * @see RegisterUserService для реализации
 */
public interface RegisterUserUseCase {
    JwtAuthenticationResponse register(RegisterUserCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/AuthenticateUserUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.usecase.AuthenticateUserService;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;

/**
 * Use Case для аутентификации пользователя (вход в систему).
 *
 * <h2>Процесс</h2>
 * 1. Получает команду с телефоном и паролем
 * 2. Проверяет учетные данные
 * 3. Выдает access token и refresh token
 *
 * <h2>Реализация</h2>
 * AuthenticateUserService
 *
 * @see AuthenticateUserService для реализации
 */
public interface AuthenticateUserUseCase {
    JwtAuthenticationResponse authenticate(AuthenticateUserCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RevokeRefreshTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.usecase.RevokeRefreshTokenService;

/**
 * Use Case для отзыва (revoke) refresh токенов.
 *
 * <h2>Назначение</h2>
 * Отзыв токена делает его непригодным для дальнейшего использования.
 * Используется при logout и других операциях завершения сессии.
 *
 * <h2>Процесс</h2>
 * 1. Получает refresh token
 * 2. Находит соответствующую сессию
 * 3. Помечает сессию как revoked = true
 *
 * При попытке использовать отозванный токен для обновления access token
 * будет выброшено исключение InvalidRefreshTokenException.
 *
 * <h2>Реализация</h2>
 * RevokeRefreshTokenService
 *
 * @see RevokeRefreshTokenService для реализации
 */
public interface RevokeRefreshTokenUseCase {
    void revoke(RevokeRefreshTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/InternalCreateRefreshTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.jwt.application.usecase.InternalCreateRefreshTokenService;

/**
 * Internal Use Case для создания refresh токенов.
 *
 * <h2>Назначение</h2>
 * Отмечен как \"Internal\" потому что:
 * - Не должен вызваться напрямую из контроллеров
 * - Используется другими use cases (Register, Authenticate, Refresh)
 * - Инкапсулирует логику создания и сохранения сессии
 *
 * <h2>Процесс</h2>
 * 1. Генерирует случайный UUID для refresh токена
 * 2. Создает сессию пользователя с TTL
 * 3. Привязывает к IP и User-Agent (для защиты)
 * 4. Сохраняет в БД
 * 5. Возвращает токен строку
 *
 * <h2>Реализация</h2>
 * InternalCreateRefreshTokenService
 *
 * @see InternalCreateRefreshTokenService для реализации
 */
public interface InternalCreateRefreshTokenUseCase {
    String create(CreateRefreshTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/RefreshAccessTokenUseCase.java ===
package com.logistics.userauth.auth.jwt.application.port.in;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.usecase.RefreshAccessTokenService;

/**
 * Use Case для обновления access токена используя refresh token.
 *
 * <h2>Процесс (Token Rotation)</h2>
 * 1. Получает старый refresh token
 * 2. Проверяет его валидность
 * 3. Помечает старый токен как отозванный
 * 4. Выдает новый access token и новый refresh token
 *
 * Это повышает безопасность: если refresh token будет скомпрометирован,
 * злоумышленник сможет его использовать только один раз.
 *
 * <h2>Реализация</h2>
 * RefreshAccessTokenService
 *
 * @see RefreshAccessTokenService для реализации
 */
public interface RefreshAccessTokenUseCase {
    JwtAuthenticationResponse refresh(RefreshAccessTokenCommand command);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/package-info.java ===
/**
 * Входные порты (use cases) для операций JWT-аутентификации.
 *
 * Описывают сценарии использования системы:
 * <ul>
 *   <li><b>AuthenticateUserUseCase</b> - Вход пользователя (phone + password → tokens)</li>
 *   <li><b>RegisterUserUseCase</b> - Регистрация (email, phone, password → tokens)</li>
 *   <li><b>RefreshAccessTokenUseCase</b> - Обновление access token (старый refresh → новая пара)</li>
 *   <li><b>RevokeRefreshTokenUseCase</b> - Выход (отзыв refresh token)</li>
 *   <li><b>InternalCreateRefreshTokenUseCase</b> - Внутренний use case создания сессии</li>
 * </ul>
 *
 * Реализуются в пакете usecase.
 */
package com.logistics.userauth.auth.jwt.application.port.in;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/CreateRefreshTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.usecase.AuthenticateUserService;
import com.logistics.userauth.auth.jwt.application.usecase.InternalCreateRefreshTokenService;
import com.logistics.userauth.auth.jwt.application.usecase.RegisterUserService;
import lombok.Builder;

/**
 * Внутренняя команда для создания нового refresh токена.
 *
 * Используется только внутри сервисов аутентификации (не вызывается напрямую из контроллеров).
 * Создает новую сессию пользователя с привязкой к IP и устройству.
 *
 * Инкапсулирует:
 * - userId: ID пользователя, для которого создается сессия
 * - ipAddress: IP-адрес клиента для привязки сессии
 * - userAgent: информация об устройстве клиента
 *
 * Используется в: InternalCreateRefreshTokenService
 * Создается в: AuthenticateUserService, RegisterUserService, RefreshAccessTokenService
 *
 * Пример создания:
 * ```java
 * CreateRefreshTokenCommand command = CreateRefreshTokenCommand.builder()
 *     .userId(1L)
 *     .ipAddress("192.168.1.1")
 *     .userAgent("Mozilla/5.0")
 *     .build();
 * ```
 *
 * @see InternalCreateRefreshTokenUseCase
 * @see InternalCreateRefreshTokenService
 * @see AuthenticateUserService
 * @see RegisterUserService
 */
@Builder
public record CreateRefreshTokenCommand(
        Long userId,
        String ipAddress,
        String userAgent
){
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RegisterUserCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import com.logistics.userauth.auth.jwt.adapter.in.web.AuthController;
import com.logistics.userauth.auth.jwt.application.port.in.RegisterUserUseCase;
import com.logistics.userauth.auth.jwt.application.usecase.RegisterUserService;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Builder;

/**
 * Команда для регистрации нового пользователя в системе.
 *
 * Инкапсулирует все данные, необходимые для создания нового аккаунта:
 * - email: адрес электронной почты
 * - phone: номер телефона (уникальный идентификатор)
 * - rawPassword: пароль в открытом виде (будет захеширован BCrypt)
 * - firstName, lastName, middleName: ФИО пользователя
 * - ipAddress: IP-адрес для логирования аудита
 * - userAgent: информация об устройстве для логирования
 *
 * Валидация:
 * - phone: должен пройти проверку @Phone (РФ, Беларусь, Казахстан)
 * - rawPassword: должен пройти проверку @Password (8+ символов, сложность)
 * - email: должен быть валидным форматом email
 *
 * Используется в: RegisterUserService
 * Создается в: AuthController из SignUpRequest
 *
 * Пример создания:
 * ```java
 * RegisterUserCommand command = RegisterUserCommand.builder()
 *     .email("ivan@example.com")
 *     .phone("+79991234567")
 *     .rawPassword("Password123!")
 *     .firstName("Иван")
 *     .lastName("Иванов")
 *     .middleName("Иванович")
 *     .ipAddress("192.168.1.1")
 *     .userAgent("Mozilla/5.0")
 *     .build();
 * ```
 *
 * @see RegisterUserUseCase
 * @see RegisterUserService
 * @see AuthController#signUp(SignUpRequest, HttpServletRequest)
 */
@Builder
public record RegisterUserCommand(
        String email,
        String phone,
        String rawPassword,
        String firstName,
        String lastName,
        String middleName,
        String ipAddress,
        String userAgent
) { }



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RefreshAccessTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import com.logistics.userauth.auth.jwt.adapter.in.web.AuthController;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.auth.jwt.application.port.in.RefreshAccessTokenUseCase;
import com.logistics.userauth.auth.jwt.application.usecase.RefreshAccessTokenService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Builder;

/**
 * Команда для обновления access токена через refresh токен.
 *
 * Реализует паттерн Token Rotation:
 * - Использует старый refresh token для получения новой пары токенов
 * - Старый refresh token отзывается после использования
 * - Новый refresh token привязывается к текущему IP и User-Agent
 *
 * Инкапсулирует:
 * - refreshToken: текущий valid refresh token
 * - ipAddress: IP-адрес клиента (для привязки новой сессии)
 * - userAgent: информация об устройстве клиента
 *
 * Используется в: RefreshAccessTokenService
 * Создается в: AuthController из RefreshTokenRequest
 *
 * Пример создания:
 * ```java
 * RefreshAccessTokenCommand command = RefreshAccessTokenCommand.builder()
 *     .refreshToken("550e8400-e29b-41d4-a716-446655440000")
 *     .ipAddress("192.168.1.1")
 *     .userAgent("Mozilla/5.0")
 *     .build();
 * ```
 *
 * @see RefreshAccessTokenUseCase
 * @see RefreshAccessTokenService
 * @see AuthController#refresh(RefreshTokenRequest, HttpServletRequest)
 * @see <a href="https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/">Token Rotation Pattern</a>
 */
@Builder
public record RefreshAccessTokenCommand (
        String refreshToken,
        String ipAddress,
        String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/package-info.java ===
/**
 * Пакет CQRS-команд для use cases JWT-аутентификации.
 *
 * Каждая команда - неизменяемый объект-значение, инкапсулирующий входные данные
 * конкретного use case:
 * <ul>
 *   <li><b>AuthenticateUserCommand</b> - phone, password, ipAddress, userAgent</li>
 *   <li><b>RegisterUserCommand</b> - email, phone, password, ФИО, ipAddress, userAgent</li>
 *   <li><b>RefreshAccessTokenCommand</b> - refreshToken, ipAddress, userAgent</li>
 *   <li><b>RevokeRefreshTokenCommand</b> - refreshToken</li>
 *   <li><b>CreateRefreshTokenCommand</b> - userId, ipAddress, userAgent</li>
 * </ul>
 *
 * Используются для:
 * <ul>
 *   <li>Явной передачи всех параметров (уменьшает ошибки)</li>
 *   <li>Маппинга из веб-DTO в доменные объекты</li>
 *   <li>Тестирования (легко создавать test doubles)</li>
 * </ul>
 */
package com.logistics.userauth.auth.jwt.application.port.in.command;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/AuthenticateUserCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import com.logistics.userauth.auth.jwt.adapter.in.web.AuthController;
import com.logistics.userauth.auth.jwt.application.port.in.AuthenticateUserUseCase;
import com.logistics.userauth.auth.jwt.application.usecase.AuthenticateUserService;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Builder;


/**
 * Команда для аутентификации пользователя в системе.
 *
 * Инкапсулирует все необходимые данные для входа пользователя:
 * - phone: номер телефона (основной идентификатор)
 * - password: пароль в открытом виде (будет проверен через BCrypt)
 * - ipAddress: IP-адрес клиента для логирования и безопасности
 * - userAgent: браузер/устройство клиента для логирования
 *
 * Используется в: AuthenticateUserService
 * Создается в: AuthController из SignInRequest
 *
 * Пример создания:
 * ```java
 * AuthenticateUserCommand command = AuthenticateUserCommand.builder()
 *     .phone("+79991234567")
 *     .password("Password123!")
 *     .ipAddress("192.168.1.1")
 *     .userAgent("Mozilla/5.0")
 *     .build();
 * ```
 *
 * @see AuthenticateUserUseCase
 * @see AuthenticateUserService
 * @see AuthController#signIn(SignInRequest, HttpServletRequest)
 */
@Builder
public record AuthenticateUserCommand (
        String phone,
        String password,
        String ipAddress,
        String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/in/command/RevokeRefreshTokenCommand.java ===
package com.logistics.userauth.auth.jwt.application.port.in.command;

import com.logistics.userauth.auth.jwt.adapter.in.web.AuthController;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.auth.jwt.application.port.in.RevokeRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.usecase.RevokeRefreshTokenService;
import lombok.Builder;

/**
 * Команда для отзыва (revoke) refresh токена.
 *
 * Используется при выходе пользователя из системы (logout).
 * После отзыва токен помечается как revoked=true и не может быть использован снова.
 *
 * Инкапсулирует:
 * - refreshToken: токен, который нужно отозвать
 *
 * Используется в: RevokeRefreshTokenService
 * Создается в: AuthController из RefreshTokenRequest
 *
 * Пример создания:
 * ```java
 * RevokeRefreshTokenCommand command = RevokeRefreshTokenCommand.builder()
 *     .refreshToken("550e8400-e29b-41d4-a716-446655440000")
 *     .build();
 * ```
 *
 * @see RevokeRefreshTokenUseCase
 * @see RevokeRefreshTokenService
 * @see AuthController#logout(RefreshTokenRequest)
 */
@Builder
public record RevokeRefreshTokenCommand(String refreshToken) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/package-info.java ===
/**
 * Порты (интерфейсы) прикладного уровня для JWT-аутентификации.
 *
 * Определяет границы приложения по паттерну Hexagonal Architecture:
 * <ul>
 *   <li><b>port.in</b> - Входные порты (use cases). Описывают, что может делать приложение.
 *       Реализуются в пакете usecase. Вызываются адаптерами (web, message queues).</li>
 *   <li><b>port.out</b> - Выходные порты. Описывают, как приложение общается с внешним миром
 *       (БД, внешние API, генерация токенов). Реализуются в адаптерах (persistence, out).</li>
 * </ul>
 *
 * Преимущества:
 * <ul>
 *   <li>Независимость от фреймворков</li>
 *   <li>Тестируемость (mock-адаптеры)</li>
 *   <li>Явные контракты между слоями</li>
 *   <li>Гибкость (легко менять реализации)</li>
 * </ul>
 *
 * @see <a href="https://alistair.cockburn.us/hexagonal-architecture/">Hexagonal Architecture</a>
 */
package com.logistics.userauth.auth.jwt.application.port;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/out/package-info.java ===
/**
 * Выходные порты для операций JWT-аутентификации.
 *
 * Определяют контракты для внешних зависимостей:
 * <ul>
 *   <li><b>TokenGeneratorPort</b> - Генерация и валидация JWT-токенов</li>
 * </ul>
 *
 * Реализуются адаптерами в пакете adapter.out.
 */
package com.logistics.userauth.auth.jwt.application.port.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/port/out/TokenGeneratorPort.java ===
package com.logistics.userauth.auth.jwt.application.port.out;

import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

/**
 * Порт для генерации и валидации JWT токенов.
 *
 * <h2>Методы</h2>
 * - generateAccessToken(user) - Создать новый access token
 * - isTokenValid(token) - Проверить валидность токена
 * - extractUserId(token) - Получить userId из токена
 *
 * <h2>Реализация</h2>
 * JwtTokenProvider
 *
 * @see JwtTokenProvider для реализации
 */
public interface TokenGeneratorPort {
    String generateAccessToken(User user);
    boolean isTokenValid(String token);
    Long extractUserId(String token);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/exception/InvalidRefreshTokenException.java ===
package com.logistics.userauth.auth.jwt.application.exception;

import com.logistics.userauth.auth.jwt.application.usecase.RefreshAccessTokenService;
import com.logistics.userauth.common.web.GlobalExceptionHandler;

/**
 * Исключение выбрасываемое когда refresh token невалиден или не может быть использован.
 *
 * <h2>Случаи когда выбрасывается</h2>
 * <ul>
 *   <li>Token not found: Токен отсутствует в БД</li>
 *   <li>Token expired: Токен истек (current time > expiresAt)</li>
 *   <li>Token revoked: Токен был явно отозван (revoked = true)</li>
 *   <li>Token rotated: Токен был заменен на новый (pattern token rotation)</li>
 * </ul>
 *
 * <h2>HTTP ответ</h2>
 * 401 Unauthorized
 *
 * <h2>Обработка</h2>
 * @ExceptionHandler в GlobalExceptionHandler возвращает:
 * {
 *   \"error\": \"INVALID_REFRESH_TOKEN\",
 *   \"message\": \"...\"
 * }
 *
 * @see GlobalExceptionHandler для обработки этого исключения
 * @see RefreshAccessTokenService где выбрасывается
 */
public class InvalidRefreshTokenException extends RuntimeException {

    public InvalidRefreshTokenException(String message) {
        super(message);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/exception/package-info.java ===
/**
 * Специализированные исключения прикладного уровня JWT-аутентификации.
 *
 * Типичные исключения:
 * <ul>
 *   <li><b>InvalidRefreshTokenException</b> - Refresh token не найден, отозван или истёк</li>
 * </ul>
 *
 * Маппируются в HTTP-ответы через GlobalExceptionHandler (обычно 401 Unauthorized).
 */
package com.logistics.userauth.auth.jwt.application.exception;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/exception/PhoneNotVerifiedException.java ===
package com.logistics.userauth.auth.jwt.application.exception;

/**
 * Исключение при попытке регистрации без верификации телефона.
 *
 * <h2>Когда выбрасывается</h2>
 * <ul>
 *   <li>Пользователь пытается зарегистрироваться без подтверждения телефона</li>
 *   <li>Статус верификации истек (TTL 10 минут)</li>
 * </ul>
 *
 * <h2>HTTP статус</h2>
 * 400 Bad Request
 *
 * <h2>Обработка</h2>
 * @ExceptionHandler в GlobalExceptionHandler возвращает:
 * {
 *   \"error\": \"PHONE_NOT_VERIFIED\",
 *   \"message\": \"...\"
 * }
 *
 * @see com.logistics.userauth.common.web.GlobalExceptionHandler
 */
public class PhoneNotVerifiedException extends RuntimeException {
    public PhoneNotVerifiedException(String message) {
        super(message);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/application/package-info.java ===
/**
 * Прикладной слой JWT-аутентификации.
 *
 * Содержит use cases и порты для операций JWT.
 */
package com.logistics.userauth.auth.jwt.application;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/package-info.java ===
/**
 * Подсистема JWT-аутентификации.
 *
 * Использует:
 * <ul>
 *   <li>HS256 подписание с секретным ключом</li>
 *   <li>Access token - короткоживущий (5-15 минут)</li>
 *   <li>Refresh token - долгоживущий (7-30 дней, привязан к сессии)</li>
 *   <li>Token Rotation - отзыв старого refresh после обновления</li>
 * </ul>
 */
package com.logistics.userauth.auth.jwt;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/security/JwtAuthenticationFilter.java ===
package com.logistics.userauth.auth.jwt.adapter.in.security;

import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.jwt.infrastructure.security.SecurityConfiguration;
import com.logistics.userauth.user.application.port.out.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * Фильтр для аутентификации запросов на основе JWT токенов.
 *
 * Применяется ко ВСЕМ запросам кроме /auth/** endpoints.
 *
 * Процесс:
 * 1. Читает header Authorization
 * 2. Извлекает Bearer токен
 * 3. Валидирует токен через JwtTokenProvider
 * 4. Извлекает userId из токена
 * 5. Загружает пользователя из БД
 * 6. Создает Authentication объект и устанавливает в SecurityContext
 * 7. Передает запрос дальше по цепочке
 *
 * Если токен невалиден:
 * - Запрос передается дальше БЕЗ аутентификации
 * - Spring Security вернет 403 Forbidden для защищенных ресурсов
 *
 * Интеграция:
 * @see SecurityConfiguration где регистрируется этот фильтр
 * @see JwtTokenProvider для валидации токенов
 */
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    public static final String HEADER_NAME = "Authorization";
    public static final String BEARER_PREFIX = "Bearer ";

    private final TokenGeneratorPort tokenGenerator;
    private final UserRepository userRepository;

    /**
     * Выполняет фильтрацию и аутентификацию.
     *
     * @param request HTTP запрос
     * @param response HTTP ответ
     * @param filterChain Цепочка фильтров
     */
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String authHeader = request.getHeader(HEADER_NAME);

        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(BEARER_PREFIX.length());

        if (!tokenGenerator.isTokenValid(token)) {
            filterChain.doFilter(request, response);
            return;
        }

        var userId = tokenGenerator.extractUserId(token);
        if (userId != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            var userOpt = userRepository.findById(userId);
            if (userOpt.isPresent()) {
                var user = userOpt.get();
                var authorities = List.of(new SimpleGrantedAuthority(user.getRole().name()));
                var authToken = new UsernamePasswordAuthenticationToken(
                                user, null, authorities
                );

                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Исключает /auth/** endpoints из обработки этого фильтра.
     *
     * @param request HTTP запрос
     * @return true если запрос НЕ должен быть обработан этим фильтром
     */
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/v1/auth") ||
                path.startsWith("/api/v1/sms") ||
                path.startsWith("/v3/api-docs") ||
                path.startsWith("/swagger-ui");
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/security/package-info.java ===
/**
 * Security-фильтры для проверки JWT-токенов в HTTP-запросах.
 *
 * Содержит:
 * <ul>
 *   <li><b>JwtAuthenticationFilter</b> - Spring Security фильтр для Extract & Validate JWT</li>
 * </ul>
 *
 * Процесс:
 * <ol>
 *   <li>Извлекает JWT из заголовка Authorization (Bearer scheme)</li>
 *   <li>Валидирует подпись и время жизни</li>
 *   <li>Заполняет SecurityContext информацией о пользователе</li>
 *   <li>Если валидация не пройдена - возвращает 401 Unauthorized</li>
 * </ol>
 */
package com.logistics.userauth.auth.jwt.adapter.in.security;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/package-info.java ===
/**
 * REST-контроллер и DTO для операций JWT-аутентификации.
 *
 * Содержит:
 * <ul>
 *   <li><b>AuthController</b> - endpoints для sign-up, sign-in, refresh, logout</li>
 *   <li><b>JwtAuthenticationResponse</b> - ответ с accessToken и refreshToken</li>
 *   <li><b>RefreshTokenRequest</b> - запрос на refresh или logout</li>
 * </ul>
 */
package com.logistics.userauth.auth.jwt.adapter.in.web;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/dto/JwtAuthenticationResponse.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web.dto;

import lombok.Builder;

/**
 * Ответ с JWT токенами после успешной аутентификации или регистрации.
 *
 * Содержит:
 * - accessToken: JWT токен для доступа к защищенным ресурсам (TTL: 15-60 минут)
 * - refreshToken: Токен для получения нового accessToken без повторной аутентификации (TTL: 7-30 дней)
 *
 * Пример:
 * {
 *   "accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNjk3NTAwMzIzfQ.xxxx",
 *   "refreshToken": "550e8400-e29b-41d4-a716-446655440000"
 * }
 *
 * Использование:
 * 1. accessToken используется в header: Authorization: Bearer {accessToken}
 * 2. refreshToken хранится безопасно на клиенте (при истечении accessToken)
 */
@Builder
public record JwtAuthenticationResponse (String accessToken, String refreshToken) {
}


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/dto/RefreshTokenRequest.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web.dto;

/**
 * Запрос для обновления access token или выхода из системы.
 *
 * Используется для:
 * 1. POST /auth/refresh - получить новый access token
 * 2. POST /auth/logout - отозвать (invalidate) текущую сессию
 *
 * Пример:
 * {
 *   "refreshToken": "550e8400-e29b-41d4-a716-446655440000"
 * }
 */
public record RefreshTokenRequest(String refreshToken) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/dto/package-info.java ===
/**
 * DTO-классы для REST API операций JWT-аутентификации.
 */
package com.logistics.userauth.auth.jwt.adapter.in.web.dto;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/web/AuthController.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.auth.jwt.application.port.in.AuthenticateUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RefreshAccessTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RegisterUserUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.RevokeRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.common.api.LogoutOperation;
import com.logistics.userauth.common.api.RefreshOperation;
import com.logistics.userauth.common.api.SignInOperation;
import com.logistics.userauth.common.api.SignUpOperation;
import com.logistics.userauth.sms.application.port.in.VerifyPhoneUseCase;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * REST контроллер для аутентификации и работы с токенами.
 *
 * <h2>Endpoints</h2>
 * <ul>
 *   <li>POST /api/v1/auth/register — Регистрация нового пользователя</li>
 *   <li>POST /api/v1/auth/sign-in — Вход в систему</li>
 *   <li>POST /api/v1/auth/refresh — Обновление access token</li>
 *   <li>POST /api/v1/auth/logout — Отзыв refresh token</li>
 * </ul>
 *
 * <h2>Security</h2>
 * Все endpoints исключены из JWT фильтра (shouldNotFilter).
 * Каждый endpoint имеет собственную валидацию.
 *
 * @see JwtAuthenticationFilter где исключаются эти endpoints
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
@Tag(
        name = "Аутентификация",
        description = "REST API endpoints для регистрации, логина, refresh токенов и выхода из системы"
)
public class AuthController {
    private final AuthenticateUserUseCase authenticateUserUseCase;
    private final RegisterUserUseCase registerUserUseCase;
    private final RefreshAccessTokenUseCase refreshAccessTokenUseCase;
    private final RevokeRefreshTokenUseCase revokeRefreshTokenUseCase;

    /**
     * POST /auth/sign-in
     * Вход в систему (аутентификация по телефону + пароль).
     */
    @PostMapping("/sign-in")
    @SignInOperation
    public ResponseEntity<JwtAuthenticationResponse> signIn(
            @Valid @RequestBody SignInRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = AuthenticateUserCommand.builder()
                .phone(request.phone())
                .password(request.password())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();
        return ResponseEntity.ok(authenticateUserUseCase.authenticate(command));
    }

    /**
     * POST /auth/register
     * Регистрация нового пользователя.
     */
    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    @SignUpOperation
    public ResponseEntity<JwtAuthenticationResponse> signUp(
            @Valid @RequestBody SignUpRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = RegisterUserCommand.builder()
                .email(request.email())
                .phone(request.phone())
                .rawPassword(request.password())
                .firstName(request.firstName())
                .lastName(request.lastName())
                .middleName(request.middleName())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();

        var response = registerUserUseCase.register(command);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * POST /auth/logout
     * Выход из системы (отзыв refresh токена).
     */
    @PostMapping("/logout")
    @LogoutOperation
    public ResponseEntity<Void> logout(@Valid @RequestBody RefreshTokenRequest request) {
        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken(request.refreshToken())
                .build();

        revokeRefreshTokenUseCase.revoke(command);
        return ResponseEntity.noContent().build();
    }

    /**
     * POST /auth/refresh
     * Обновление access токена (token rotation).
     */
    @PostMapping("/refresh")
    @RefreshOperation
    public ResponseEntity<JwtAuthenticationResponse> refresh(
            @Valid @RequestBody RefreshTokenRequest request,
            HttpServletRequest httpRequest
    ) {
        var command = RefreshAccessTokenCommand.builder()
                .refreshToken(request.refreshToken())
                .ipAddress(httpRequest.getRemoteAddr())
                .userAgent(httpRequest.getHeader("User-Agent"))
                .build();

        return ResponseEntity.ok(refreshAccessTokenUseCase.refresh(command));
    }

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/in/package-info.java ===
/**
 * Входные адаптеры для JWT-аутентификации (веб-контроллеры и фильтры безопасности).
 */
package com.logistics.userauth.auth.jwt.adapter.in;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/package-info.java ===
/**
 * Адаптеры для связи JWT-логики с внешним миром (веб, БД).
 */
package com.logistics.userauth.auth.jwt.adapter;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/out/JwtTokenProvider.java ===
package com.logistics.userauth.auth.jwt.adapter.out;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.domain.User;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Date;

/**
 * Провайдер для генерации и валидации JWT access токенов.
 *
 * Использует HS256 (HMAC SHA256) алгоритм подписания.
 *
 * Структура JWT:
 * - Header: { "alg": "HS256" }
 * - Payload: { "sub": "userId", "iat": timestamp, "exp": timestamp, "phone": "...", "role": "..." }
 * - Signature: HMAC(secret, header.payload)
 *
 * Конфигурация в application.yml:
 * app:
 *   jwt:
 *     secret: "your-secret-key-change-in-production"
 *     expiration: 3600  # 1 час в секундах
 *
 * @see JwtAuthenticationFilter для проверки токена в каждом запросе
 */
@Component
@RequiredArgsConstructor
public class JwtTokenProvider implements TokenGeneratorPort {

    @Value("${app.jwt.secret}")
    private String secret;

    @Value("${app.jwt.expiration}")
    private long accessTokenTtlSeconds;

    /**
     * Генерирует новый JWT access token для пользователя.
     *
     * @param user Пользователь, для которого создается токен
     * @return Подписанный JWT токен в виде строки
     */
    @Override
    public String generateAccessToken(User user) {
        Instant now = Instant.now();
        Instant expiry = now.plusSeconds(accessTokenTtlSeconds);

        return Jwts.builder()
                .subject(user.getId().toString())
                .issuedAt(Date.from(now))
                .expiration(Date.from(expiry))
                .claim("phone", user.getPhone())
                .claim("role", user.getRole().name())
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
    }

    /**
     * Проверяет валидность JWT токена.
     *
     * @param token JWT токен для проверки
     * @return true если токен валиден и не истек
     */
    @Override
    public boolean isTokenValid(String token) {
        try {
            parseClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException ex) {
            return false;
        }
    }

    /**
     * Извлекает ID пользователя из JWT токена.
     *
     * @param token JWT токен
     * @return ID пользователя (значение "sub" claim)
     */
    @Override
    public Long extractUserId(String token) {
        Claims claims = parseClaims(token);
        String sub = claims.getSubject();
        return Long.valueOf(sub);
    }

    /**
     * Создаёт HMAC-ключ подписи для JWT (HS256) из {@code app.jwt.secret}.
     *
     * @return SecretKey для подписи/проверки JWT.
     */
    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * Парсит JWT, проверяет подпись и возвращает {@link Claims}.
     *
     * @param token JWT (compact string).
     * @return Claims токена.
     * @throws JwtException Если токен невалиден (подпись/формат/exp и т.п.).
     * @throws IllegalArgumentException Если token некорректен.
     */
    private Claims parseClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/adapter/out/package-info.java ===
/**
 * Выходной адаптер для генерации и валидации JWT-токенов.
 *
 * Реализует TokenGeneratorPort, инкапсулирует работу с JWT-библиотекой.
 */
package com.logistics.userauth.auth.jwt.adapter.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/infrastructure/security/SecurityConfiguration.java ===
package com.logistics.userauth.auth.jwt.infrastructure.security;

import com.logistics.userauth.auth.jwt.adapter.in.security.JwtAuthenticationFilter;
import com.logistics.userauth.user.infrastructure.LogisticsUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Конфигурация Spring Security для JWT-based аутентификации.
 *
 * Особенности:
 * - Stateless сессии (не используются cookies и sessions)
 * - CSRF отключен (для REST API с JWT не требуется)
 * - JWT фильтр регистрируется в цепочке безопасности
 * - /auth/** endpoints открыты для всех
 * - Остальные endpoints требуют валидный JWT токен
 *
 * Архитектура:
 * 1. JwtAuthenticationFilter → извлекает и валидирует токен
 * 2. AuthenticationProvider → аутентифицирует user/password при логине
 * 3. SecurityFilterChain → определяет какие endpoint защищены
 *
 * @see JwtAuthenticationFilter для деталей обработки JWT
 * @see LogisticsUserDetailsService для загрузки пользователя из БД
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    private final LogisticsUserDetailsService userDetailsService;

    /**
     * Определяет цепочку фильтров безопасности.
     *
     * @param http HttpSecurity для конфигурации
     * @return SecurityFilterChain
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .csrf(csrf -> csrf.disable())

                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .requestMatchers("/sms/**").permitAll()
                        .requestMatchers(
                                "/v3/api-docs/**",
                                "/swagger-ui/**",
                                "/swagger-ui.html",
                                "/swagger-ui/index.html",
                                "/webjars/**"
                        ).permitAll()
                        .anyRequest().authenticated()

                )

                .authenticationProvider(authenticationProvider())

                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    /**
     * Провайдер аутентификации для username/password при логине.
     *
     * @return AuthenticationProvider
     */
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
            throws Exception {
        return config.getAuthenticationManager();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/infrastructure/security/package-info.java ===
/**
 * Spring Security конфигурация для JWT-аутентификации.
 *
 * Регистрирует:
 * <ul>
 *   <li>JWT-фильтр (JwtAuthenticationFilter)</li>
 *   <li>Правила доступа к endpoint'ам</li>
 *   <li>Обработчики ошибок безопасности</li>
 *   <li>CORS и другие безопасностные header'ы</li>
 * </ul>
 */
package com.logistics.userauth.auth.jwt.infrastructure.security;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/jwt/infrastructure/package-info.java ===
/**
 * Инфраструктурная конфигурация для JWT-аутентификации.
 */
package com.logistics.userauth.auth.jwt.infrastructure;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/application/port/package-info.java ===
/**
 * Порты (интерфейсы) управления сессиями.
 */
package com.logistics.userauth.auth.session.application.port;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/application/port/out/UserSessionRepository.java ===
package com.logistics.userauth.auth.session.application.port.out;

import com.logistics.userauth.auth.session.adapter.out.persistence.UserSessionPersistenceAdapter;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceAdapter;
import com.logistics.userauth.user.domain.User;

import java.util.Optional;

/**
 * Порт (интерфейс) для работы с хранилищем сессий.
 *
 * <h2>Назначение</h2>
 * Определяет контракт для всех операций с сессий,
 * не привязываясь к конкретной реализации (JPA, MongoDB и т.д.).
 *
 * <h2>Реализации</h2>
 * - UserSessionPersistenceAdapter (текущая - JPA)
 * - Может быть заменена на другую реализацию при необходимости
 *
 * <h2>Методы</h2>
 * - save(userSession) - Сохранить или обновить сессию
 * - delete(userSession) - Удалить сессию
 * - findById(id) - Найти по ID
 * - findByUser(user) - Найти по пользователю
 * - findByRefreshToken(refreshToken) - Найти по refresh-токену
 *
 * @see UserSessionPersistenceAdapter для реализации на JPA
 * @see UserSession для доменной сущности
 */
public interface UserSessionRepository {
    Optional<UserSession> findByUser(User user);

    Optional<UserSession> findByRefreshToken(String refreshToken);

    void save(UserSession userSession);

    void delete(UserSession userSession);
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/application/port/out/package-info.java ===
/**
 * Выходные порты для работы с сессиями.
 *
 * Определяют контракты для персистенции:
 * <ul>
 *   <li><b>UserSessionRepository</b> - CRUD операции с сессиями</li>
 * </ul>
 *
 * Реализуются адаптерами в пакете adapter.out.persistence.
 */
package com.logistics.userauth.auth.session.application.port.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/application/package-info.java ===
/**
 * Прикладной слой управления пользовательскими сессиями.
 */
package com.logistics.userauth.auth.session.application;



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/package-info.java ===
/**
 * Подсистема управления пользовательскими сессиями.
 *
 * Отвечает за:
 * <ul>
 *   <li>Создание сессий (привязка refresh token к IP и User-Agent)</li>
 *   <li>Отзыв сессий (logout)</li>
 *   <li>Управление временем жизни сессии</li>
 * </ul>
 */
package com.logistics.userauth.auth.session;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/domain/package-info.java ===
/**
 * Domain entity для управления пользовательскими сессиями.
 *
 * <h2>Назначение</h2>
 * Представляет сессию пользователя: refresh token, metadata запроса (IP, User-Agent),
 * TTL (время истечения), и статус (revoked=true при logout).
 *
 * <h2>Структура UserSession</h2>
 * <ul>
 *   <li><b>id</b> - Primary key (auto-generated BIGSERIAL)</li>
 *   <li><b>user</b> - User, владелец session'а</li>
 *   <li><b>refreshToken</b> - UUID строка (уникальный для каждой session'а)</li>
 *   <li><b>createdAt</b> - Timestamp создания (устанавливается @CreatedDate)</li>
 *   <li><b>expiresAt</b> - Timestamp истечения (обычно +30 дней от создания)</li>
 *   <li><b>ipAddress</b> - IP-адрес из request'а (тип Inet, PostgreSQL native)</li>
 *   <li><b>userAgent</b> - User-Agent header из request'а (браузер, версия, ОС)</li>
 *   <li><b>revoked</b> - Flag логаута (true если logout вызван)</li>
 * </ul>
 *
 * <h2>Жизненный цикл</h2>
 * <ol>
 *   <li>Создание: {@link com.logistics.userauth.auth.jwt.application.usecase.RegisterUserService} создает session</li>
 *   <li>Использование: {@link com.logistics.userauth.auth.jwt.application.usecase.RefreshAccessTokenService} проверяет session</li>
 *   <li>Отзыв: {@link com.logistics.userauth.auth.jwt.application.usecase.RevokeRefreshTokenService} устанавливает revoked=true</li>
 *   <li>Удаление: можно удалить по expiresAt < NOW (background job)</li>
 * </ol>
 *
 * <h2>Token Rotation</h2>
 * При refresh access token'а:
 * <ol>
 *   <li>Клиент отправляет old refresh token</li>
 *   <li>Сервер проверяет: expiresAt > NOW, revoked=false</li>
 *   <li>Генерирует новые access и refresh token'ы</li>
 *   <li>Создает новую session запись</li>
 *   <li>Стара session может остаться в БД (для audit log'ов)</li>
 * </ol>
 *
 * @see com.logistics.userauth.auth.session.adapter.out.persistence.UserSessionEntity
 */
package com.logistics.userauth.auth.session.domain;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/domain/UserSession.java ===
package com.logistics.userauth.auth.session.domain;

import com.logistics.userauth.auth.session.adapter.out.persistence.UserSessionEntity;
import com.logistics.userauth.user.domain.User;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.*;

import java.time.LocalDateTime;

/**
 * Доменная сущность для сессии пользователя.
 *
 * <h2>Назначение</h2>
 * Представляет активную сессию пользователя с refresh токеном.
 * Привязана к конкретному устройству (IP + User-Agent).
 *
 * <h2>Структура</h2>
 * - id: Уникальный идентификатор сессии
 * - user: Пользователь этой сессии
 * - refreshToken: UUID токен для обновления access token
 * - createdAt: Когда была создана сессия
 * - expiresAt: Когда истекает refresh token
 * - revoked: Был ли токен отозван (logout)
 * - ipAddress: IP-адрес клиента для защиты
 * - userAgent: User-Agent браузера для защиты
 *
 * <h2>Примеры</h2>
 * <pre>
 * UserSession session = UserSession.builder()
 *   .user(user)
 *   .refreshToken(UUID.randomUUID().toString())
 *   .expiresAt(LocalDateTime.now().plusDays(30))
 *   .ipAddress(new Inet(\"192.168.1.1\"))
 *   .userAgent(\"Mozilla/5.0...\")
 *   .revoked(false)
 *   .build();
 * </pre>
 *
 * @see User для пользователя
 * @see UserSessionEntity для JPA entity
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserSession {

    private long id;

    private User user;

    private String refreshToken;

    private LocalDateTime createdAt;

    private LocalDateTime expiresAt;

    private Inet ipAddress;

    private String userAgent;

    private boolean revoked;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/UserSessionControllerMapper.java ===
package com.logistics.userauth.auth.session.adapter.in;

import com.logistics.userauth.audit.adapter.out.persistence.AuditLogEntity;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.auth.session.adapter.in.dto.UserSessionDTO;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.in.web.dto.UserDTO;
import com.logistics.userauth.user.domain.User;
import org.springframework.stereotype.Component;

/**
 * Маппер для преобразования между Domain UserSession и DTO.
 *
 * <h2>Назначение</h2>
 * Конвертирует UserSession → UserSessionDTO и обратно.
 *
 * @see UserSessionDTO для DTO
 * @see UserSession для доменной сущности
 */
@Component
public class UserSessionControllerMapper {

    public UserSession toDomain(UserSessionDTO userSessionDTO) {
        return UserSession.builder()
                .createdAt(userSessionDTO.createdAt())
                .ipAddress(userSessionDTO.ipAddress())
                .userAgent(userSessionDTO.userAgent())
                .expiresAt(userSessionDTO.expiresAt())
                .build();
    }

    public UserSessionDTO toDTO(UserSession userSession) {
        return UserSessionDTO.builder()
                .createdAt(userSession.getCreatedAt())
                .ipAddress(userSession.getIpAddress())
                .userAgent(userSession.getUserAgent())
                .expiresAt(userSession.getExpiresAt())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/package-info.java ===
/**
 * Входной адаптер для преобразования веб-DTO в доменную модель сессии.
 *
 * Используется REST-контроллерами для отделения транспортных форматов от бизнес-логики.
 */
package com.logistics.userauth.auth.session.adapter.in;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/dto/UserSessionDTO.java ===
package com.logistics.userauth.auth.session.adapter.in.dto;


import io.hypersistence.utils.hibernate.type.basic.Inet;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * DTO для передачи информации о сессиях в ответах.
 *
 * <h2>Назначение</h2>
 * Содержит информацию сессии для отправки клиенту.
 *
 * <h2>Примеры</h2>
 * {
 *   \"createdAt\": \"15.12.2025\",
 *   \"expiresAt\": \"20.12.2025\",
 *   \"ipAddress\": \"192.168.0.10\",
 *   \"userAgent\": \"Mozilla\"
 * }
 */
@Builder
public record UserSessionDTO (LocalDateTime createdAt,
                              LocalDateTime expiresAt,
                              Inet ipAddress,
                              String userAgent) {
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/in/dto/package-info.java ===
/**
 * DTO-классы запросов и ответов REST-API для работы с сессиями.
 *
 * Содержит:
 * <ul>
 *   <li><b>UserSessionDTO</b> - Ответ и информацией по сессии</li>
 * </ul>
 */
package com.logistics.userauth.auth.session.adapter.in.dto;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/package-info.java ===
/**
 * Адаптеры для связи логики сессий.
 */
package com.logistics.userauth.auth.session.adapter;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionEntity.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import io.hypersistence.utils.hibernate.type.basic.PostgreSQLInetType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.Type;
import org.springframework.data.annotation.CreatedDate;

import java.time.LocalDateTime;
/**
 * JPA Entity для хранения сессий пользователей и их refresh токенов.
 *
 * Таблица: user_management.user_sessions
 *
 * Основные поля:
 * - sessionId: Уникальный ID сессии (первичный ключ)
 * - userId: Внешний ключ на таблицу users
 * - refreshToken: UUID токен для обновления access token
 * - expiresAt: Время истечения refresh token (обычно 7-30 дней)
 * - createdAt: Время создания сессии
 * - revoked: Флаг отзыва (true = токен больше не валиден)
 * - ipAddress: IP-адрес клиента (для аудита)
 * - userAgent: User-Agent браузера (для аудита)
 *
 * Индексы:
 * - idx_user_sessions_user_id: для быстрого поиска сессий пользователя
 * - idx_user_sessions_expires_at: для очистки истекших сессий
 *
 * Уникальные ограничения:
 * - refresh_token должен быть уникален (один токен = одна сессия)
 *
 * @see UserSession доменная модель
 * @see UserSessionPersistenceMapper преобразование Entity ↔ Domain
 */
@Entity
@Table(
        name = "user_sessions",
        schema = "user_management",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "refresh_token")
        },
        indexes = {
                @Index(columnList = "user_id", name = "idx_user_sessions_user_id"),
                @Index(columnList = "expires_at", name = "idx_user_sessions_expires_at")
        }
)
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserSessionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_sessions_seq")
    @SequenceGenerator(
            name = "user_sessions_seq",
            sequenceName = "user_sessions_session_id_seq",
            schema = "user_management",
            allocationSize = 1
    )
    @Column(name = "session_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    private UserEntity user;

    @Column(name = "refresh_token", nullable = false)
    private String refreshToken;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Builder.Default
    @Column(name = "revoked", nullable = false)
    private boolean revoked = false;

    @Column(name = "ip_address", columnDefinition = "inet")
    @Type(PostgreSQLInetType.class)
    private Inet ipAddress;

    @Column(name = "user_agent")
    private String userAgent;

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionPersistenceMapper.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.audit.adapter.out.persistence.AuditLogEntity;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Маппер для преобразования между Domain UserSession и Entity UserSession.
 *
 * <h2>Назначение</h2>
 * Конвертирует Domain → Entity и обратно.
 *
 * @see UserSession для доменной сущности
 * @see UserSessionEntity для сущности БД
 */
@Component
@RequiredArgsConstructor
public class UserSessionPersistenceMapper {

    private final UserPersistenceMapper upMapper;

    public UserSession toDomain(UserSessionEntity entity) {
        return UserSession.builder()
                .id(entity.getId())
                .user(upMapper.toDomain(entity.getUser()))
                .refreshToken(entity.getRefreshToken())
                .expiresAt(entity.getExpiresAt())
                .ipAddress(entity.getIpAddress())
                .revoked(entity.isRevoked())
                .userAgent(entity.getUserAgent())
                .createdAt(entity.getCreatedAt())
                .build();
    }

    public UserSessionEntity toEntity(UserSession domain) {
        return UserSessionEntity.builder()
                .id(domain.getId())
                .user(upMapper.toEntity(domain.getUser()))
                .refreshToken(domain.getRefreshToken())
                .createdAt(domain.getCreatedAt())
                .expiresAt(domain.getExpiresAt())
                .revoked(domain.isRevoked())
                .ipAddress(domain.getIpAddress())
                .userAgent(domain.getUserAgent())
                .build();
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionPersistenceAdapter.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.adapter.out.persistence.UserJpaRepository;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

/**
 * Адаптер, реализующий интерфейс UserSessionRepository для JPA.
 *
 * <h2>Паттерн</h2>
 * Это реализация Adapter паттерна:
 * - Интерфейс UserSessionRepository определяет контракт
 * - UserSessionPersistenceAdapter реализует этот контракт с помощью JPA
 * - Бизнес-логика зависит от интерфейса, а не от реализации
 *
 * <h2>Преимущества</h2>
 * - Если позже нужна другая БД (MongoDB, Redis), создаем новый адаптер
 * - Бизнес-логика не меняется
 * - Легче тестировать (подменить mock-адаптер)
 *
 * @implements UserSessionRepository
 * @see UserSessionRepository для контракта
 * @see UserSessionJpaRepository для JPA работы
 */
@Component
@RequiredArgsConstructor
public class UserSessionPersistenceAdapter implements UserSessionRepository {

    private final UserSessionJpaRepository jpaRepo;
    private final UserSessionPersistenceMapper mapper;

    @Override
    public Optional<UserSession> findByUser(User user) {
        return jpaRepo.findByUser(user).map(mapper::toDomain);
    }

    @Override
    public Optional<UserSession> findByRefreshToken(String refreshToken) {
        return jpaRepo.findByRefreshToken(refreshToken).map(mapper::toDomain);
    }

    @Override
    public void save(UserSession userSession) {
        UserSessionEntity entity = mapper.toEntity(userSession);
        jpaRepo.save(entity);
    }

    @Override
    public void delete(UserSession userSession) {
        UserSessionEntity entity = mapper.toEntity(userSession);
        jpaRepo.delete(entity);
    }
}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/package-info.java ===
/**
 * Выходной адаптер для работы с сессиями через JPA.
 *
 * Содержит:
 * <ul>
 *   <li><b>UserSessionEntity</b> - JPA сущность для БД</li>
 *   <li><b>UserSessionJpaRepository</b> - Spring Data JPA репозиторий</li>
 *   <li><b>UserSessionPersistenceMapper</b> - Преобразование Domain ↔ Entity</li>
 *   <li><b>UserSessionPersistenceAdapter</b> - Реализация интерфейса UserSessionRepository</li>
 * </ul>
 *
 * Паттерн Adapter обеспечивает, что использование JPA скрыто от бизнес-логики.
 */
package com.logistics.userauth.auth.session.adapter.out.persistence;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionJpaRepository.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.audit.adapter.out.persistence.AuditLogEntity;
import com.logistics.userauth.audit.adapter.out.persistence.AuditLogPersistenceAdapter;
import com.logistics.userauth.user.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * Spring Data JPA репозиторий для работы с сессия.
 *
 * <h2>Методы</h2>
 * Наследует от JpaRepository:
 * - save, saveAll, delete, deleteAll, findById, findAll и т.д.
 *
 * Плюс кастомные методы для поиска:
 * - findByUser(user)
 * - findByRefreshToken(refreshToken)
 *
 * @see UserSessionEntity для сущности
 * @see UserSessionPersistenceAdapter для использования в бизнес-логике
 */
@Repository
public interface UserSessionJpaRepository extends JpaRepository<UserSessionEntity, Long> {
    Optional<UserSessionEntity> findByUser(User user);

    Optional<UserSessionEntity> findByRefreshToken(String refreshToken);

}



=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/session/adapter/out/package-info.java ===
/**
 * Выходные адаптеры для работы с сессиями через различные каналы (БД, API и т.д.).
 */
package com.logistics.userauth.auth.session.adapter.out;


=== backend/user-auth-service/src/main/java/com/logistics/userauth/auth/package-info.java ===
/**
 * Подсистема аутентификации (JWT).
 *
 * Отвечает за:
 * <ul>
 *   <li>Генерацию и валидацию JWT токенов</li>
 *   <li>Управление сессиями пользователя (refresh tokens)</li>
 *   <li>Защиту от скомпрометированных токенов (Token Rotation)</li>
 *   <li>HTTP фильтрацию и проверку авторизации</li>
 * </ul>
 */
package com.logistics.userauth.auth;


=== backend/user-auth-service/src/test/java/com/logistics/userauth/UserAuthServiceApplicationTests.java ===
package com.logistics.userauth;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@IntegrationTest
@DisplayName("UserAuth Service: тесты загрузки контекста")
class UserAuthServiceApplicationTests {

    @Test
    @DisplayName("Должен успешно загрузить контекст приложения")
    void contextLoads() {
        // Проверяет, что все модули корректно интегрируются
    }
}


=== backend/user-auth-service/src/test/java/com/logistics/userauth/IntegrationTest.java ===
package com.logistics.userauth;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.junit.jupiter.Testcontainers;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@ActiveProfiles("test")
public @interface IntegrationTest {
}




=== backend/user-auth-service/src/test/java/com/logistics/userauth/sms/application/usecase/VerifyPhoneServiceTest.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException;
import com.logistics.userauth.sms.application.port.in.command.VerifyPhoneCommand;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("VerifyPhoneService - тестирование проверки SMS кодов")
class VerifyPhoneServiceTest {

    @Mock
    private SmsRepository repository;

    private VerifyPhoneService service;

    @BeforeEach
    void setUp() {
        service = new VerifyPhoneService(repository);
        ReflectionTestUtils.setField(service, "maxAttempts", 3);
        ReflectionTestUtils.setField(service, "verifiedStatusTtlMinutes", 10L);
    }

    @Test
    @DisplayName("Должен успешно верифицировать корректный код")
    void shouldSuccessfullyVerifyValidCode() {
        // Given
        String phone = "89991234567";
        String code = "123456";
        var command = VerifyPhoneCommand.builder()
                .phone(phone)
                .code(code)
                .build();

        var storedCode = SmsVerificationCode.builder()
                .phone(phone)
                .code(code)
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(0)
                .build();

        when(repository.findByPhone(phone)).thenReturn(Optional.of(storedCode));

        // When
        service.verify(command);

        // Then
        verify(repository).deleteVerificationCode(phone);
        verify(repository).markPhoneAsVerified(phone, 10L);
    }

    @Test
    @DisplayName("Должен бросить исключение если код не найден")
    void shouldThrowExceptionIfCodeNotFound() {
        // Given
        String phone = "89991234567";
        var command = VerifyPhoneCommand.builder()
                .phone(phone)
                .code("123456")
                .build();

        when(repository.findByPhone(phone)).thenReturn(Optional.empty());

        // When & Then
        assertThatThrownBy(() -> service.verify(command))
                .isInstanceOf(InvalidVerificationCodeException.class);
    }

    @Test
    @DisplayName("Должен бросить исключение если код истек")
    void shouldThrowExceptionIfCodeExpired() {
        // Given
        String phone = "89991234567";
        var command = VerifyPhoneCommand.builder()
                .phone(phone)
                .code("123456")
                .build();

        var expiredCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().minusMinutes(1))
                .attempts(0)
                .build();

        when(repository.findByPhone(phone)).thenReturn(Optional.of(expiredCode));

        // When & Then
        assertThatThrownBy(() -> service.verify(command))
                .isInstanceOf(InvalidVerificationCodeException.class);

        verify(repository).deleteVerificationCode(phone);
    }

    @Test
    @DisplayName("Должен удалить код при превышении максимального числа попыток")
    void shouldDeleteCodeWhenMaxAttemptsExceeded() {
        // Given
        String phone = "89991234567";
        var command = VerifyPhoneCommand.builder()
                .phone(phone)
                .code("654321")
                .build();

        var storedCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(3)
                .build();

        when(repository.findByPhone(phone)).thenReturn(Optional.of(storedCode));

        // When & Then
        assertThatThrownBy(() -> service.verify(command))
                .isInstanceOf(InvalidVerificationCodeException.class);

        verify(repository).incrementAttempts(phone);
        verify(repository).deleteVerificationCode(phone);
    }

}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/sms/application/usecase/SendVerificationCodeServiceTest.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.exception.SmsDeliveryException;
import com.logistics.userauth.sms.application.port.in.InternalSmsRateLimiterUseCase;
import com.logistics.userauth.sms.application.port.in.command.SendVerificationCodeCommand;
import com.logistics.userauth.sms.application.port.out.SendSmsPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("SendVerificationCodeService - тестирование отправки SMS кодов")
class SendVerificationCodeServiceTest {

    @Mock
    private SmsRepository smsRepository;

    @Mock
    private SendSmsPort sendSmsPort;

    @Mock
    private InternalSmsRateLimiterUseCase internalSmsRateLimiterUseCase;

    private SendVerificationCodeService service;

    @BeforeEach
    void setUp() {
        service = new SendVerificationCodeService(
                smsRepository,
                sendSmsPort,
                internalSmsRateLimiterUseCase
        );
        ReflectionTestUtils.setField(service, "codeLength", 6);
        ReflectionTestUtils.setField(service, "codeTtlMinutes", 5L);
    }

    @Test
    @DisplayName("Должен успешно отправить SMS код")
    void shouldSuccessfullySendVerificationCode() {
        // Given
        String phone = "89991234567";
        var command = new SendVerificationCodeCommand(phone);

        when(sendSmsPort.sendVerificationCode(eq(phone), anyString())).thenReturn(true);

        // When
        service.sendCode(command);

        // Then
        ArgumentCaptor<SmsVerificationCode> codeCaptor = ArgumentCaptor.forClass(SmsVerificationCode.class);
        verify(smsRepository).save(codeCaptor.capture(), eq(5L));

        SmsVerificationCode savedCode = codeCaptor.getValue();
        assertThat(savedCode.getPhone()).isEqualTo(phone);
        assertThat(savedCode.getCode()).hasSize(6);
        assertThat(savedCode.getAttempts()).isZero();
        assertThat(savedCode.getExpiresAt()).isAfter(LocalDateTime.now());

        verify(sendSmsPort).sendVerificationCode(eq(phone), anyString());
    }

    @Test
    @DisplayName("Должен проверить rate limit перед отправкой")
    void shouldCheckRateLimitBeforeSending() {
        // Given
        String phone = "89991234567";
        var command = new SendVerificationCodeCommand(phone);
        doNothing().when(internalSmsRateLimiterUseCase).checkRateLimiter(any());
        when(sendSmsPort.sendVerificationCode(eq(phone), anyString())).thenReturn(true);

        // When
        service.sendCode(command);

        // Then
        verify(internalSmsRateLimiterUseCase).checkRateLimiter(any());
    }


    @Test
    @DisplayName("Должен позволить отправку если старый код истек")
    void shouldAllowSendingIfOldCodeExpired() {
        // Given
        String phone = "89991234567";
        var command = new SendVerificationCodeCommand(phone);

        var expiredCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().minusMinutes(1))
                .attempts(0)
                .build();

        when(sendSmsPort.sendVerificationCode(eq(phone), anyString())).thenReturn(true);

        // When
        service.sendCode(command);

        // Then
        verify(sendSmsPort).sendVerificationCode(eq(phone), anyString());
    }

    @Test
    @DisplayName("Должен бросить исключение если SMS не удалось отправить")
    void shouldThrowExceptionIfSmsDeliveryFails() {
        // Given
        String phone = "89991234567";
        var command = new SendVerificationCodeCommand(phone);

        when(sendSmsPort.sendVerificationCode(eq(phone), anyString())).thenReturn(false);

        // When & Then
        assertThatThrownBy(() -> service.sendCode(command))
                .isInstanceOf(SmsDeliveryException.class)
                .hasMessageContaining("SMS");
    }

    @Test
    @DisplayName("Должен генерировать код заданной длины")
    void shouldGenerateCodeOfSpecifiedLength() {
        // Given
        String phone = "89991234567";
        var command = new SendVerificationCodeCommand(phone);

        when(sendSmsPort.sendVerificationCode(eq(phone), anyString())).thenReturn(true);

        // When
        service.sendCode(command);

        // Then
        var codeCaptor = ArgumentCaptor.forClass(String.class);
        verify(sendSmsPort).sendVerificationCode(eq(phone), codeCaptor.capture());

        String generatedCode = codeCaptor.getValue();
        assertThat(generatedCode).hasSize(6);
        assertThat(generatedCode).matches("\\d{6}");
    }

}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/sms/application/usecase/InternalSmsRateLimiterServiceTest.java ===
package com.logistics.userauth.sms.application.usecase;

import com.logistics.shared.redis.service.RateLimiterService;
import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.port.in.command.InternalSmsRateLimiterCommand;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.Duration;

import static org.assertj.core.api.Assertions.assertThatCode;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@DisplayName("InternalSmsRateLimiterService - тестирование ограничения SMS запросов")
class InternalSmsRateLimiterServiceTest {

    @Mock
    private RateLimiterService rateLimiterService;

    private InternalSmsRateLimiterService service;

    @BeforeEach
    void setUp() {
        service = new InternalSmsRateLimiterService(rateLimiterService);

        ReflectionTestUtils.setField(service, "resendCooldownSeconds", 60L);
        ReflectionTestUtils.setField(service, "maxAttempts", 1);
    }

    @Test
    @DisplayName("Должен разрешить запрос если лимит не превышен")
    void shouldAllowRequestWhenNotRateLimited() {
        // Given
        String phone = "89991234567";
        var command = new InternalSmsRateLimiterCommand(phone);

        when(rateLimiterService.isRateLimited(anyString(), eq(1), any(Duration.class)))
                .thenReturn(false);

        // When & Then
        assertThatCode(() -> service.checkRateLimiter(command))
                .doesNotThrowAnyException();

        verify(rateLimiterService).isRateLimited(
                eq("sms:send:" + phone),
                eq(1),
                eq(Duration.ofSeconds(60))
        );
    }

    @Test
    @DisplayName("Должен бросить исключение если лимит превышен")
    void shouldThrowExceptionWhenRateLimited() {
        // Given
        String phone = "89991234567";
        var command = new InternalSmsRateLimiterCommand(phone);

        when(rateLimiterService.isRateLimited(anyString(), eq(1), any(Duration.class)))
                .thenReturn(true);

        // When & Then
        assertThatThrownBy(() -> service.checkRateLimiter(command))
                .isInstanceOf(RateLimitExceededException.class)
                .hasMessageContaining("60");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/sms/adapter/in/web/SmsControllerIntegrationTest.java ===
package com.logistics.userauth.sms.adapter.in.web;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.common.web.GlobalExceptionHandler;
import com.logistics.userauth.sms.adapter.in.web.dto.SendVerificationCodeRequest;
import com.logistics.userauth.sms.adapter.in.web.dto.VerifyPhoneRequest;
import com.logistics.userauth.sms.application.port.out.SendSmsPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.mock.mockito.SpyBean;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.http.MediaType;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.utility.DockerImageName;

import java.time.LocalDateTime;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@IntegrationTest
@AutoConfigureMockMvc
@Import({GlobalExceptionHandler.class})
@DisplayName("SmsController: интеграционные тесты")
class SmsControllerIntegrationTest {

    private static final String SEND_URL = "/sms/send-verification-code";
    private static final String VERIFY_URL = "/sms/verify-phone";


    @Container
    static GenericContainer<?> redis = new GenericContainer<>(DockerImageName.parse("redis:7-alpine"))
            .withExposedPorts(6379);

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", () -> redis.getFirstMappedPort());

        // Чтобы не ждать 30 секунд в интеграционных тестах
        registry.add("app.sms.verification.resend-cooldown-seconds", () -> "5");

        // Не обязательно (у вас и так default 5), но можно зафиксировать:
        registry.add("app.sms.verification.code-ttl-minutes", () -> "5");

        registry.add("app.sms.verification.max-attempts", () -> "1");
    }


    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private SendSmsPort sendSmsPort;

    @Autowired
    private SmsRepository smsRepository;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @BeforeEach
    void setUp() {
        redisTemplate.getConnectionFactory().getConnection().flushAll();
        when(sendSmsPort.sendVerificationCode(anyString(), anyString())).thenReturn(true);
    }

    @Test
    @DisplayName("Должен успешно отправить код верификации")
    void shouldSendVerificationCode() throws Exception {
        // Given
        var request = new SendVerificationCodeRequest("89991234567");

        // When & Then
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());
    }


    @Test
    @DisplayName("Должен вернуть 400 при невалидном номере телефона")
    void shouldReturn400ForInvalidPhone() throws Exception {
        var request = new SendVerificationCodeRequest("123");

        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("VALIDATION_FAILED"))
                .andExpect(jsonPath("$.fields.phone").value("Неверный формат телефона"));
    }


    @SpyBean
    private com.logistics.shared.redis.service.RateLimiterService rateLimiterService;

    @Test
    @DisplayName("POST /sms/send-verification-code - 429 rate limit")
    void shouldReturn429WhenRateLimitExceeded() throws Exception {
        // Given
        var request = new SendVerificationCodeRequest("89991234567");

        // When
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());


        //Then
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isTooManyRequests())
                .andExpect(jsonPath("$.message").exists());
    }


    @Test
    @DisplayName("Должен успешно верифицировать корректный код")
    void shouldVerifyCorrectCode() throws Exception {
        // Given
        String phone = "89991234567";
        String code = "123456";

        var verificationCode = SmsVerificationCode.builder()
                .phone(phone)
                .code(code)
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(0)
                .build();
        smsRepository.save(verificationCode, 5L);

        var request = VerifyPhoneRequest.builder()
                .phone(phone)
                .code(code)
                .build();

        // When & Then
        mockMvc.perform(post(VERIFY_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Телефон успешно верифицирован"));
    }

    @Test
    @DisplayName("POST /sms/verify-phone - должен вернуть 400 при неверном коде")
    void shouldReturn400ForInvalidCode() throws Exception {
        // Given
        String phone = "89991234567";

        var verificationCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(0)
                .build();
        smsRepository.save(verificationCode, 5L);

        var request = VerifyPhoneRequest.builder()
                .phone(phone)
                .code("654321") // Неверный код
                .build();

        // When & Then
        mockMvc.perform(post(VERIFY_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(org.hamcrest.Matchers.containsString("попыток")));
    }

    @Test
    @DisplayName("POST /sms/verify-phone - должен вернуть 400 при истекшем коде")
    void shouldReturn400ForExpiredCode() throws Exception {
        // Given
        String phone = "89991234567";

        var verificationCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().minusMinutes(1)) // Истек
                .attempts(0)
                .build();
        smsRepository.save(verificationCode, 5L);

        var request = VerifyPhoneRequest.builder()
                .phone(phone)
                .code("123456")
                .build();

        // When & Then
        mockMvc.perform(post(VERIFY_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value(org.hamcrest.Matchers.containsString("истек")));
    }

    @Test
    @DisplayName("POST /sms/verify-phone - должен вернуть 400 при отсутствии кода")
    void shouldReturn400WhenCodeNotFound() throws Exception {
        // Given
        var request = VerifyPhoneRequest.builder()
                .phone("89991234567")
                .code("123456")
                .build();

        // When & Then
        mockMvc.perform(post(VERIFY_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").exists());
    }

    @Test
    @DisplayName("POST /sms/send-verification-code - должен вернуть 503 при ошибке отправки SMS")
    void shouldReturn503WhenSmsDeliveryFails() throws Exception {
        // When
        when(sendSmsPort.sendVerificationCode(anyString(), anyString())).thenReturn(false);

        var request = new SendVerificationCodeRequest("89991234567");

        // Then
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isServiceUnavailable())
                .andExpect(jsonPath("$.error").value("SMS_DELIVERY_FAILED"))
                .andExpect(jsonPath("$.message").value(org.hamcrest.Matchers.containsString("SMS")));
    }


    @Test
    @DisplayName("POST /sms/send-verification-code - должен разрешить resend после cooldown")
    void shouldAllowResendAfterCooldown() throws Exception {
        // Given
        var request = new SendVerificationCodeRequest("89991234567");

        // When
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());

        Thread.sleep(5100);

        // Then
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());
    }

    @Test
    @DisplayName("POST /sms/send-verification-code - resend после cooldown генерирует новый код")
    void shouldGenerateNewCodeOnResend() throws Exception {
        // Given
        String phone = "89991234567";
        var request = new SendVerificationCodeRequest(phone);

        // When
        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());

        Thread.sleep(5100);

        mockMvc.perform(post(SEND_URL)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());

        ArgumentCaptor<String> codeCaptor = ArgumentCaptor.forClass(String.class);

        // Then
        verify(sendSmsPort, times(2)).sendVerificationCode(eq(phone), codeCaptor.capture());

        var codes = codeCaptor.getAllValues();
        assertThat(codes.get(0)).isNotEqualTo(codes.get(1));
    }


}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/sms/adapter/out/persistence/RedisSmsRepositoryTest.java ===
package com.logistics.userauth.sms.adapter.out.persistence;

import com.logistics.shared.redis.service.RedisService;
import com.logistics.userauth.sms.domain.SmsVerificationCode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RedisSmsRepository - тестирование Redis репозитория для SMS")
class RedisSmsRepositoryTest {

    @Mock
    private RedisService redisService;

    private RedisSmsRepository repository;

    @BeforeEach
    void setUp() {
        repository = new RedisSmsRepository(redisService);
        ReflectionTestUtils.setField(repository, "defaultTtlMinutes", 5L);
    }

    @Test
    @DisplayName("Должен сохранить код верификации в Redis")
    void shouldSaveVerificationCode() {
        // Given
        String phone = "79991234567";
        var code = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(0)
                .build();
        long ttl = 5L;

        // When
        repository.save(code, ttl);

        // Then
        verify(redisService).set(
                eq("sms:verification:" + phone),
                eq(code),
                eq(Duration.ofMinutes(ttl))
        );
    }

    @Test
    @DisplayName("Должен найти код верификации по телефону")
    void shouldFindVerificationCodeByPhone() {
        // Given
        String phone = "79991234567";
        var expectedCode = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(0)
                .build();

        when(redisService.get(eq("sms:verification:" + phone), eq(SmsVerificationCode.class)))
                .thenReturn(Optional.of(expectedCode));

        // When
        Optional<SmsVerificationCode> result = repository.findByPhone(phone);

        // Then
        assertThat(result).isPresent();
        assertThat(result.get().getPhone()).isEqualTo(phone);
        assertThat(result.get().getCode()).isEqualTo("123456");
    }

    @Test
    @DisplayName("Должен вернуть пустой Optional если код не найден")
    void shouldReturnEmptyOptionalIfCodeNotFound() {
        // Given
        String phone = "79991234567";
        when(redisService.get(anyString(), eq(SmsVerificationCode.class)))
                .thenReturn(Optional.empty());

        // When
        Optional<SmsVerificationCode> result = repository.findByPhone(phone);

        // Then
        assertThat(result).isEmpty();
    }

    @Test
    @DisplayName("Должен удалить код верификации")
    void shouldDeleteVerificationCode() {
        // Given
        String phone = "79991234567";

        // When
        repository.deleteVerificationCode(phone);

        // Then
        verify(redisService).delete("sms:verification:" + phone);
    }

    @Test
    @DisplayName("Должен инкрементировать попытки верификации")
    void shouldIncrementAttempts() {
        // Given
        String phone = "79991234567";
        var code = SmsVerificationCode.builder()
                .phone(phone)
                .code("123456")
                .expiresAt(LocalDateTime.now().plusMinutes(5))
                .attempts(1)
                .build();

        when(redisService.get(eq("sms:verification:" + phone), eq(SmsVerificationCode.class)))
                .thenReturn(Optional.of(code));
        when(redisService.getTtl(eq("sms:verification:" + phone), eq(TimeUnit.MINUTES)))
                .thenReturn(Optional.of(4L));

        // When
        repository.incrementAttempts(phone);

        // Then
        verify(redisService).set(
                eq("sms:verification:" + phone),
                argThat(c -> ((SmsVerificationCode) c).getAttempts() == 2),
                eq(Duration.ofMinutes(4L))
        );
    }

    @Test
    @DisplayName("Должен пометить телефон как верифицированный")
    void shouldMarkPhoneAsVerified() {
        // Given
        String phone = "79991234567";
        long ttl = 10L;

        // When
        repository.markPhoneAsVerified(phone, ttl);

        // Then
        verify(redisService).set(
                eq("sms:verified:" + phone),
                eq("verified"),
                eq(Duration.ofMinutes(ttl))
        );
    }

    @Test
    @DisplayName("Должен проверить что телефон верифицирован")
    void shouldCheckIfPhoneIsVerified() {
        // Given
        String phone = "79991234567";
        when(redisService.get(eq("sms:verified:" + phone), eq(String.class)))
                .thenReturn(Optional.of("verified"));

        // When
        boolean result = repository.isPhoneVerified(phone);

        // Then
        assertThat(result).isTrue();
    }

    @Test
    @DisplayName("Должен вернуть false если телефон не верифицирован")
    void shouldReturnFalseIfPhoneNotVerified() {
        // Given
        String phone = "79991234567";
        when(redisService.get(eq("sms:verified:" + phone), eq(String.class)))
                .thenReturn(Optional.empty());

        // When
        boolean result = repository.isPhoneVerified(phone);

        // Then
        assertThat(result).isFalse();
    }

    @Test
    @DisplayName("Должен удалить статус верификации")
    void shouldDeleteVerificationStatus() {
        // Given
        String phone = "79991234567";

        // When
        repository.deleteVerificationStatus(phone);

        // Then
        verify(redisService).delete("sms:verified:" + phone);
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogPersistenceMapperTest.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.domain.AuditActionType;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.shared.audit_action.persistence.AuditActionTypeMapper;
import com.logistics.userauth.audit.domain.AuditLog;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserPersistenceMapper;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@DisplayName("AuditLogPersistenceMapper: юнит-тесты")
class AuditLogPersistenceMapperTest {

    @Mock
    private AuditActionTypeMapper actionTypeMapper;

    @Mock
    private UserPersistenceMapper userMapper;

    @InjectMocks
    private AuditLogPersistenceMapper mapper;

    private User testUser;
    private UserEntity testUserEntity;
    private AuditActionType testActionType;
    private AuditActionTypeEntity testActionTypeEntity;

    @BeforeEach
    void setUp() {
        testUser = User.builder().id(1L).firstName("Test").lastName("User").role(UserRole.CLIENT).build();
        testUserEntity = UserEntity.builder().id(1L).firstName("Test").lastName("User").role(UserRole.CLIENT).build();
        testActionType = AuditActionType.builder().id((short) 1).actionName("USER_LOGIN").build();
        testActionTypeEntity = AuditActionTypeEntity.builder().id((short) 1).actionName("USER_LOGIN").build();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("status", "active");
        AuditLog domain = AuditLog.builder()
                .id(1L)
                .user(testUser)
                .actionType(testActionType)
                .tableName("users")
                .newValues(newValues)
                .build();
        when(userMapper.toEntity(any(User.class))).thenReturn(testUserEntity);
        when(actionTypeMapper.toEntity(any(AuditActionType.class))).thenReturn(testActionTypeEntity);

        // When
        AuditLogEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo(1L);
        assertThat(entity.getUser()).isEqualTo(testUserEntity);
        assertThat(entity.getActionType()).isEqualTo(testActionTypeEntity);
        assertThat(entity.getNewValues()).containsEntry("status", "active");
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("role", "COURIER");
        AuditLogEntity entity = AuditLogEntity.builder()
                .id(2L)
                .user(testUserEntity)
                .actionType(testActionTypeEntity)
                .tableName("users")
                .recordId(100L)
                .newValues(newValues)
                .build();
        when(userMapper.toDomain(any(UserEntity.class))).thenReturn(testUser);
        when(actionTypeMapper.toDomain(any(AuditActionTypeEntity.class))).thenReturn(testActionType);

        // When
        AuditLog domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo(2L);
        assertThat(domain.getUser()).isEqualTo(testUser);
        assertThat(domain.getActionType()).isEqualTo(testActionType);
        assertThat(domain.getNewValues()).containsEntry("role", "COURIER");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/audit/adapter/out/persistence/AuditLogJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.audit.adapter.out.persistence;

import com.logistics.shared.audit_action.persistence.AuditActionJpaRepository;
import com.logistics.shared.audit_action.persistence.AuditActionTypeEntity;
import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserJpaRepository;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("AuditLogJpaRepository: интеграционные тесты")
class AuditLogJpaRepositoryIntegrationTest {
    @Autowired
    private AuditLogJpaRepository repository;

    @Autowired
    private UserJpaRepository userRepository;

    @Autowired
    private AuditActionJpaRepository actionTypeRepository;

    private UserEntity testUser;
    private AuditActionTypeEntity testActionType;

    @BeforeEach
    void setUp() {
        // Создаём тестового пользователя
        testUser = UserEntity.builder()
                .phone("+79991111111")
                .firstName("Test")
                .lastName("User")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        testUser = userRepository.save(testUser);

        // Создаём тип действия
        testActionType = AuditActionTypeEntity.builder()
                .actionName("TEST_ACTION")
                .category("TEST")
                .description("Test action")
                .build();

        testActionType = actionTypeRepository.save(testActionType);
    }

    @Test
    @Transactional
    @DisplayName("Должен сохранить и найти лог аудита по пользователю")
    void shouldSaveAndFindByUser() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("field", "value");

        Inet in = new Inet("192.168.1.1");

        AuditLogEntity auditLog = AuditLogEntity.builder()
                .user(testUser)
                .actionType(testActionType)
                .tableName("test_table")
                .recordId(1L)
                .actorIdentifier("test@example.com")
                .newValues(newValues)
                .performedAt(LocalDateTime.now())
                .ipAddress(in)
                .build();

        // When
        repository.save(auditLog);

        // Then
        List<AuditLogEntity> found = repository.findByUser(testUser);

        assertThat(found).isNotEmpty();
        assertThat(found.get(0).getActionType()).isEqualTo(testActionType);
        assertThat(found.get(0).getTableName()).isEqualTo("test_table");
        assertThat(found.get(0).getRecordId()).isEqualTo(1L);
        assertThat(found.get(0).getActorIdentifier()).isEqualTo("test@example.com");
        assertThat(found.get(0).getNewValues()).isEqualTo(newValues);
        assertThat(found.get(0).getIpAddress()).isEqualTo(in);
    }

    @Test
    @DisplayName("Должен сохранить лог аудита с корректными данными")
    void shouldSaveAuditLogWithCorrectData() {
        // Given
        Map<String, Object> newValues = new HashMap<>();
        newValues.put("status", "COMPLETED");
        newValues.put("amount", 1500.50);

        Inet in = new Inet("192.168.1.1");

        AuditLogEntity auditLog = AuditLogEntity.builder()
                .user(testUser)
                .actionType(testActionType)
                .tableName("orders")
                .recordId(999L)
                .actorIdentifier("admin@example.com")
                .newValues(newValues)
                .performedAt(LocalDateTime.now())
                .ipAddress(in)
                .build();

        // When
        AuditLogEntity saved = repository.save(auditLog);

        // Then
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getNewValues()).containsEntry("status", "COMPLETED");
        assertThat(saved.getNewValues()).containsEntry("amount", 1500.50);
    }
}


=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceAdapterIntegrationTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@Transactional
@DisplayName("UserPersistenceAdapter: интеграционные тесты")
class UserPersistenceAdapterIntegrationTest {

    @Autowired
    private UserPersistenceAdapter adapter;

    @Test
    @DisplayName("Должен сохранить и получить пользователя")
    void shouldSaveAndRetrieveUser() {
        // Given
        User user = User.builder()
                .email("adapter@test.com")
                .phone("+79993333333")
                .passwordHash("hashed123")
                .firstName("Adapter")
                .lastName("Test")
                .role(UserRole.DISPATCHER)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        // When
        adapter.save(user);

        // Then
        Optional<User> found = adapter.findByEmail("adapter@test.com");
        assertThat(found).isPresent();
        assertThat(found.get().getPhone()).isEqualTo("+79993333333");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("UserJpaRepository: интеграционные тесты")
class UserJpaRepositoryIntegrationTest {

    @Autowired
    private UserJpaRepository repository;

    @Test
    @DisplayName("Должен сохранить и найти User по ID")
    void shouldSaveAndFindById() {
        // Given
        UserEntity entity = UserEntity.builder()
                .email("test@example.com")
                .phone("1234567890")
                .passwordHash("hashedpassword")
                .firstName("John")
                .lastName("Doe")
                .role(UserRole.CLIENT)
                .build();

        UserEntity savedEntity = repository.save(entity);

        // When
        Optional<UserEntity> found = repository.findById(savedEntity.getId());

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getEmail()).isEqualTo("test@example.com");
        assertThat(found.get().getId()).isEqualTo(savedEntity.getId());
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/user/adapter/out/persistence/UserPersistenceMapperTest.java ===
package com.logistics.userauth.user.adapter.out.persistence;

import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.time.LocalDateTime;

import static org.assertj.core.api.Assertions.assertThat;

@DisplayName("UserPersistenceMapper: юнит-тесты")
class UserPersistenceMapperTest {

    private UserPersistenceMapper mapper;

    @BeforeEach
    void setUp() {
        mapper = new UserPersistenceMapper();
    }

    @Test
    @DisplayName("Должен корректно преобразовать Domain в Entity")
    void shouldMapDomainToEntity() {
        // Given
        User domain = User.builder()
                .id(1L)
                .email("test@example.com")
                .phone("+79991234567")
                .passwordHash("hashedPassword123")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .facilityId(100L)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();

        // When
        UserEntity entity = mapper.toEntity(domain);

        // Then
        assertThat(entity).isNotNull();
        assertThat(entity.getId()).isEqualTo(1L);
        assertThat(entity.getEmail()).isEqualTo("test@example.com");
        assertThat(entity.getRole()).isEqualTo(UserRole.CLIENT);
    }

    @Test
    @DisplayName("Должен корректно преобразовать Entity в Domain")
    void shouldMapEntityToDomain() {
        // Given
        UserEntity entity = UserEntity.builder()
                .id(2L)
                .email("courier@example.com")
                .phone("+79997654321")
                .passwordHash("hashedPassword456")
                .firstName("Петр")
                .lastName("Петров")
                .role(UserRole.COURIER)
                .facilityId(200L)
                .status(UserStatus.ACTIVE)
                .createdAt(LocalDateTime.now())
                .lastAccessedAt(LocalDateTime.now())
                .build();

        // When
        User domain = mapper.toDomain(entity);

        // Then
        assertThat(domain).isNotNull();
        assertThat(domain.getId()).isEqualTo(2L);
        assertThat(domain.getEmail()).isEqualTo("courier@example.com");
        assertThat(domain.getRole()).isEqualTo(UserRole.COURIER);
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/common/web/GlobalExceptionHandlerTest.java ===
package com.logistics.userauth.common.web;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.logistics.userauth.auth.jwt.application.exception.InvalidRefreshTokenException;
import com.logistics.userauth.auth.jwt.application.exception.PhoneNotVerifiedException;
import com.logistics.userauth.sms.application.exception.InvalidVerificationCodeException;
import com.logistics.userauth.sms.application.exception.RateLimitExceededException;
import com.logistics.userauth.sms.application.exception.SmsDeliveryException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import static org.hamcrest.Matchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@WebMvcTest(
        excludeAutoConfiguration = {
                org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class
        }
)
@Import({
        GlobalExceptionHandler.class,
        GlobalExceptionHandlerTest.TestController.class
})
@DisplayName("GlobalExceptionHandler - тестирование обработки исключений")
class GlobalExceptionHandlerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    // ========== КОНФИГУРАЦИЯ ==========

    @Configuration
    @EnableWebSecurity
    static class TestSecurityConfig {
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http
                    .csrf(AbstractHttpConfigurer::disable)
                    .authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
            return http.build();
        }
    }


    // ========== ТЕСТЫ ==========

    @Test
    @DisplayName("Должен возвращать 401 и INVALID_CREDENTIALS при BadCredentialsException")
    void shouldHandleBadCredentials() throws Exception {
        mockMvc.perform(post("/test/bad-credentials"))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.error").value("INVALID_CREDENTIALS"))
                .andExpect(jsonPath("$.message").value("Неверный телефон или пароль"));
    }

    @Test
    @DisplayName("Должен возвращать 409 и CONFLICT при DataIntegrityViolationException")
    void shouldHandleDataIntegrityViolation() throws Exception {
        mockMvc.perform(post("/test/data-integrity"))
                .andExpect(status().isConflict())
                .andExpect(jsonPath("$.error").value("CONFLICT"))
                .andExpect(jsonPath("$.message").value("Пользователь с таким телефоном или email уже существует"));
    }

    @Test
    @DisplayName("Должен возвращать 400 и VALIDATION_FAILED при ошибках Bean Validation")
    void shouldHandleValidationErrors() throws Exception {
        var invalidRequest = new TestRequest("");

        mockMvc.perform(post("/test/validation")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("VALIDATION_FAILED"))
                .andExpect(jsonPath("$.fields.phone").value("Неверный формат телефона"));
    }

    @Test
    @DisplayName("Должен обработать InvalidRefreshTokenException и вернуть 401")
    void shouldHandleInvalidRefreshToken() throws Exception {
        mockMvc.perform(post("/test/invalid-refresh-token"))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.error").value("INVALID_REFRESH_TOKEN"))
                .andExpect(jsonPath("$.message").value("Invalid refresh token"));
    }

    @Test
    @DisplayName("Должен обработать RateLimitExceededException и вернуть 429")
    void shouldHandleRateLimitExceeded() throws Exception {
        mockMvc.perform(post("/test/rate-limit"))
                .andExpect(status().isTooManyRequests())
                .andExpect(jsonPath("$.error").value("RATE_LIMIT_EXCEEDED"))
                .andExpect(jsonPath("$.message").value(containsString("60 сек")));
    }

    @Test
    @DisplayName("Должен обработать SmsDeliveryException и вернуть 500")
    void shouldHandleSmsDeliveryException() throws Exception {
        mockMvc.perform(post("/test/sms-delivery-error"))
                .andExpect(status().isServiceUnavailable())
                .andExpect(jsonPath("$.error").value("SMS_DELIVERY_FAILED"))
                .andExpect(jsonPath("$.message").value("Не удалось отправить SMS. Повторите попытку позже."));
    }

    @Test
    @DisplayName("Должен обработать PhoneNotVerifiedException и вернуть 500")
    void shouldHandlePhoneNotVerifiedException() throws Exception {
        mockMvc.perform(post("/test/phone-not-verified"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("PHONE_NOT_VERIFIED"))
                .andExpect(jsonPath("$.message").value("Телефон не верифицирован"));
    }

    @Test
    @DisplayName("Должен обработать InvalidVerificationCodeException и вернуть 400")
    void shouldHandleInvalidVerificationCode() throws Exception {
        mockMvc.perform(post("/test/invalid-verification-code"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("INVALID_VERIFICATION_CODE"))
                .andExpect(jsonPath("$.message").value("Неверный код верификации"));
    }




    // ========== ТЕСТОВЫЙ КОНТРОЛЛЕР ==========

    @RestController
    static class TestController {

        @PostMapping("/test/bad-credentials")
        public void testBadCredentials() {
            throw new BadCredentialsException("Invalid credentials");
        }

        @PostMapping("/test/data-integrity")
        public void testDataIntegrity() {
            throw new DataIntegrityViolationException("duplicate key");
        }

        @PostMapping("/test/validation")
        public void testValidation(@Valid @RequestBody TestRequest request) {
        }

        @PostMapping("/test/invalid-refresh-token")
        public void testInvalidRefreshToken() {
            throw new InvalidRefreshTokenException("Invalid refresh token");
        }

        @PostMapping("/test/rate-limit")
        public void testRateLimit() {
            throw new RateLimitExceededException("Слишком много запросов. Повторите через 60 сек.");
        }

        @PostMapping("/test/invalid-verification-code")
        public void testInvalidVerificationCode() {
            throw new InvalidVerificationCodeException("Неверный код верификации");
        }

        @PostMapping("/test/phone-not-verified")
        public void testPhoneNotVerified() {
            throw new PhoneNotVerifiedException("Телефон не верифицирован");
        }

        @PostMapping("/test/sms-delivery-error")
        public void testSmsDeliveryError() {
            throw new SmsDeliveryException("Не удалось отправить SMS. Повторите попытку позже.");
        }


    }

    // ========== ТЕСТОВЫЕ DTO ==========

    @Data
    @NoArgsConstructor
    static class TestRequest {
        @NotBlank(message = "Неверный формат телефона")
        private String phone;

        public TestRequest(String phone) {
            this.phone = phone;
        }
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RevokeRefreshTokenServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.command.RevokeRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RevokeRefreshTokenService: юнит-тесты")
class RevokeRefreshTokenServiceTest {

    @Mock
    private UserSessionRepository repository;

    @InjectMocks
    private RevokeRefreshTokenService service;

    @Test
    @DisplayName("Должен отозвать валидный refresh токен")
    void shouldRevokeValidRefreshToken() {
        // Given
        var session = UserSession.builder()
                .id(1L)
                .refreshToken("valid-token")
                .revoked(false)
                .build();

        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken("valid-token")
                .build();

        when(repository.findByRefreshToken("valid-token"))
                .thenReturn(Optional.of(session));

        // When
        service.revoke(command);

        // Then
        verify(repository).save(argThat(s -> s.isRevoked()));
    }

    @Test
    @DisplayName("Должен выбросить исключение для несуществующего токена")
    void shouldThrowExceptionForNonExistentToken() {
        // Given
        var command = RevokeRefreshTokenCommand.builder()
                .refreshToken("non-existent-token")
                .build();

        when(repository.findByRefreshToken("non-existent-token"))
                .thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.revoke(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid refresh token");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RefreshAccessTokenServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RefreshAccessTokenCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RefreshAccessTokenService: юнит-тесты")
class RefreshAccessTokenServiceTest {

    @Mock
    private UserSessionRepository repository;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private RefreshAccessTokenService service;

    @Test
    @DisplayName("Должен обновить токены для валидного refresh токена")
    void shouldRefreshTokensForValidRefreshToken() {
        // Given
        var user = User.builder()
                .id(1L)
                .phone("79991234567")
                .role(UserRole.CLIENT)
                .build();

        var session = UserSession.builder()
                .id(1L)
                .user(user)
                .refreshToken("old-refresh-token")
                .expiresAt(LocalDateTime.now().plusDays(1))
                .revoked(false)
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("old-refresh-token")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(repository.findByRefreshToken("old-refresh-token"))
                .thenReturn(Optional.of(session));
        when(tokenGenerator.generateAccessToken(user))
                .thenReturn("new-access-token");
        when(createRefreshTokenUseCase.create(any()))
                .thenReturn("new-refresh-token");

        // When
        var response = service.refresh(command);

        // Then
        assertThat(response.accessToken()).isEqualTo("new-access-token");
        assertThat(response.refreshToken()).isEqualTo("new-refresh-token");

        // Проверяем, что старая сессия отозвана
        verify(repository).save(argThat(s -> s.isRevoked()));

        // Проверяем, что создан новый refresh токен
        verify(createRefreshTokenUseCase).create(any());
    }

    @Test
    @DisplayName("Должен выбросить исключение для невалидного refresh токена")
    void shouldThrowExceptionForInvalidRefreshToken() {
        // Given
        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("invalid-token")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(repository.findByRefreshToken("invalid-token"))
                .thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid refresh token");
    }

    @Test
    @DisplayName("Должен выбросить исключение для отозванного токена")
    void shouldThrowExceptionForRevokedToken() {
        // Given
        var session = UserSession.builder()
                .refreshToken("revoked-token")
                .revoked(true)
                .expiresAt(LocalDateTime.now().plusDays(1))
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("revoked-token")
                .build();

        when(repository.findByRefreshToken("revoked-token"))
                .thenReturn(Optional.of(session));

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("revoked");
    }

    @Test
    @DisplayName("Должен выбросить исключение для истекшего токена")
    void shouldThrowExceptionForExpiredToken() {
        // Given
        var session = UserSession.builder()
                .refreshToken("expired-token")
                .revoked(false)
                .expiresAt(LocalDateTime.now().minusDays(1)) // Истёк вчера
                .build();

        var command = RefreshAccessTokenCommand.builder()
                .refreshToken("expired-token")
                .build();

        when(repository.findByRefreshToken("expired-token"))
                .thenReturn(Optional.of(session));

        // Then
        assertThatThrownBy(() -> service.refresh(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("expired");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/InternalCreateRefreshTokenServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.application.port.in.command.CreateRefreshTokenCommand;
import com.logistics.userauth.auth.session.application.port.out.UserSessionRepository;
import com.logistics.userauth.auth.session.domain.UserSession;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("InternalCreateRefreshTokenService: юнит-тесты")
class InternalCreateRefreshTokenServiceTest {

    @Mock
    private UserSessionRepository sessionRepository;

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private InternalCreateRefreshTokenService service;

    @Test
    @DisplayName("Должен создать refresh токен для валидного пользователя")
    void shouldCreateRefreshTokenForValidUser() {
        // Given
        ReflectionTestUtils.setField(service, "refreshTokenTtlSeconds", 604800L);

        var user = User.builder()
                .id(1L)
                .phone("79991234567")
                .role(UserRole.CLIENT)
                .build();

        var command = CreateRefreshTokenCommand.builder()
                .userId(1L)
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        // When
        String refreshToken = service.create(command);

        // Then
        assertThat(refreshToken).isNotNull();
        assertThat(refreshToken).isNotEmpty();

        // Проверяем, что сессия сохранена
        ArgumentCaptor<UserSession> sessionCaptor = ArgumentCaptor.forClass(UserSession.class);
        verify(sessionRepository).save(sessionCaptor.capture());

        UserSession savedSession = sessionCaptor.getValue();
        assertThat(savedSession.getUser()).isEqualTo(user);
        assertThat(savedSession.getRefreshToken()).isEqualTo(refreshToken);
        assertThat(savedSession.isRevoked()).isFalse();
        assertThat(savedSession.getExpiresAt()).isAfter(LocalDateTime.now());
    }

    @Test
    @DisplayName("Должен выбросить исключение, если пользователь не найден")
    void shouldThrowExceptionWhenUserNotFound() {
        // Given
        var command = CreateRefreshTokenCommand.builder()
                .userId(999L)
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        when(userRepository.findById(999L)).thenReturn(Optional.empty());

        // Then
        assertThatThrownBy(() -> service.create(command))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("User not found");
    }

    @Test
    @DisplayName("Должен создать токен с IP и User-Agent")
    void shouldCreateTokenWithIpAndUserAgent() {
        // Given
        ReflectionTestUtils.setField(service, "refreshTokenTtlSeconds", 604800L);

        var user = User.builder().id(1L).build();
        var command = CreateRefreshTokenCommand.builder()
                .userId(1L)
                .ipAddress("10.0.0.1")
                .userAgent("Chrome/120")
                .build();

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        // When
        service.create(command);

        // Then
        ArgumentCaptor<UserSession> captor = ArgumentCaptor.forClass(UserSession.class);
        verify(sessionRepository).save(captor.capture());

        UserSession session = captor.getValue();
        assertThat(session.getIpAddress()).isNotNull();
        assertThat(session.getUserAgent()).isEqualTo("Chrome/120");
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/AuthenticateUserServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.AuthenticateUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@DisplayName("AuthenticateUserService: юнит-тесты")
public class AuthenticateUserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private AuthenticateUserService service;

    private User buildUser() {
        return User.builder()
                .id(1L)
                .email("test@example.com")
                .phone("79991234567")
                .passwordHash("HASH")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }

    @Test
    @DisplayName("Должен аутентифицировать пользователя и вернуть JWT")
    void shouldAuthenticateUserAndReturnJwt() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79991234567")
                .password("Password123!")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        var user = buildUser();

        when(userRepository.findByPhone("79991234567")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("Password123!", "HASH")).thenReturn(true);
        when(tokenGenerator.generateAccessToken(any(User.class))).thenReturn("jwt-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");
        // when
        JwtAuthenticationResponse response = service.authenticate(command);

        // then
        assertThat(response).isNotNull();
        assertThat(response.accessToken()).isEqualTo("jwt-token");
        assertThat(response.refreshToken()).isEqualTo("refresh-token");

        verify(createRefreshTokenUseCase).create(any());
    }

    @Test
    @DisplayName("Должен бросить BadCredentialsException при неверном пароле")
    void shouldThrowWhenPasswordInvalid() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79991234567")
                .password("wrong")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        var user = buildUser();

        when(userRepository.findByPhone("79991234567")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("wrong", "HASH")).thenReturn(false);

        // then
        assertThatThrownBy(() -> service.authenticate(command))
                .isInstanceOf(BadCredentialsException.class);
    }

    @Test
    @DisplayName("Должен бросить BadCredentialsException, если пользователь не найден")
    void shouldThrowWhenUserNotFound() {
        // given
        var command = AuthenticateUserCommand.builder()
                .phone("79990000000")
                .password("Password123!")
                .ipAddress("192.168.1.10")
                .userAgent("Mozilla")
                .build();

        when(userRepository.findByPhone("79990000000")).thenReturn(Optional.empty());

        // then
        assertThatThrownBy(() -> service.authenticate(command))
                .isInstanceOf(BadCredentialsException.class);
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/usecase/RegisterUserServiceTest.java ===
package com.logistics.userauth.auth.jwt.application.usecase;

import com.logistics.userauth.auth.jwt.adapter.in.web.dto.JwtAuthenticationResponse;
import com.logistics.userauth.auth.jwt.application.exception.PhoneNotVerifiedException;
import com.logistics.userauth.auth.jwt.application.port.in.InternalCreateRefreshTokenUseCase;
import com.logistics.userauth.auth.jwt.application.port.in.command.RegisterUserCommand;
import com.logistics.userauth.auth.jwt.application.port.out.TokenGeneratorPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.user.application.port.out.UserRepository;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("RegisterUserService - тестирование регистрации пользователя")
class RegisterUserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private SmsRepository smsRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private TokenGeneratorPort tokenGenerator;

    @Mock
    private InternalCreateRefreshTokenUseCase createRefreshTokenUseCase;

    @InjectMocks
    private RegisterUserService service;

    private RegisterUserCommand validCommand;
    private User savedUser;

    @BeforeEach
    void setUp() {
        validCommand = RegisterUserCommand.builder()
                .email("test@example.com")
                .phone("79991234567")
                .rawPassword("Password123!")
                .firstName("Ivan")
                .lastName("Ivanov")
                .middleName("Ivanovich")
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        savedUser = User.builder()
                .id(1L)
                .email(validCommand.email())
                .phone(validCommand.phone())
                .passwordHash("encodedPass")
                .firstName(validCommand.firstName())
                .lastName(validCommand.lastName())
                .middleName(validCommand.middleName())
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();
    }

    @Test
    @DisplayName("Должен успешно зарегистрировать пользователя и вернуть JWT токены")
    void shouldRegisterUserAndReturnJwt() {
        // Given
        when(smsRepository.isPhoneVerified(validCommand.phone())).thenReturn(true);
        when(passwordEncoder.encode(validCommand.rawPassword())).thenReturn("encodedPass");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        when(tokenGenerator.generateAccessToken(savedUser)).thenReturn("access-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");

        // When
        JwtAuthenticationResponse response = service.register(validCommand);

        // Then
        assertThat(response).isNotNull();
        assertThat(response.accessToken()).isEqualTo("access-token");
        assertThat(response.refreshToken()).isEqualTo("refresh-token");

        // Verify interactions
        verify(smsRepository).isPhoneVerified(validCommand.phone());
        verify(passwordEncoder).encode(validCommand.rawPassword());
        verify(userRepository).save(any(User.class));
        verify(smsRepository).deleteVerificationStatus(validCommand.phone());
        verify(tokenGenerator).generateAccessToken(savedUser);
        verify(createRefreshTokenUseCase).create(any());
    }

    @Test
    @DisplayName("Должен выбросить PhoneNotVerifiedException если телефон не верифицирован")
    void shouldThrowPhoneNotVerifiedExceptionWhenPhoneNotVerified() {
        // Given
        when(smsRepository.isPhoneVerified(validCommand.phone())).thenReturn(false);

        // When & Then
        assertThatThrownBy(() -> service.register(validCommand))
                .isInstanceOf(PhoneNotVerifiedException.class);

        // Verify
        verify(smsRepository).isPhoneVerified(validCommand.phone());
        verify(userRepository, never()).save(any());
        verify(tokenGenerator, never()).generateAccessToken(any());
    }

    @Test
    @DisplayName("Должен выбросить DataIntegrityViolationException при дублировании телефона")
    void shouldThrowDataIntegrityViolationExceptionWhenPhoneDuplicated() {
        // Given
        when(smsRepository.isPhoneVerified(validCommand.phone())).thenReturn(true);
        when(passwordEncoder.encode(validCommand.rawPassword())).thenReturn("encodedPass");
        when(userRepository.save(any(User.class)))
                .thenThrow(new DataIntegrityViolationException("Duplicate phone"));

        // When & Then
        assertThatThrownBy(() -> service.register(validCommand))
                .isInstanceOf(DataIntegrityViolationException.class);

        // Verify
        verify(smsRepository).isPhoneVerified(validCommand.phone());
        verify(userRepository).save(any(User.class));
        verify(tokenGenerator, never()).generateAccessToken(any());
    }

    @Test
    @DisplayName("Должен правильно сохранить пользователя с захешированным паролем")
    void shouldSaveUserWithEncodedPassword() {
        // Given
        when(smsRepository.isPhoneVerified(validCommand.phone())).thenReturn(true);
        when(passwordEncoder.encode(validCommand.rawPassword())).thenReturn("encodedPass");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        when(tokenGenerator.generateAccessToken(any())).thenReturn("access-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");

        // When
        service.register(validCommand);

        // Then
        verify(passwordEncoder).encode("Password123!");
        verify(userRepository).save(argThat(user ->
                user.getPhone().equals("79991234567") &&
                        user.getPasswordHash().equals("encodedPass") &&
                        user.getFirstName().equals("Ivan") &&
                        user.getLastName().equals("Ivanov") &&
                        user.getMiddleName().equals("Ivanovich") &&
                        user.getEmail().equals("test@example.com") &&
                        user.getRole().equals(UserRole.CLIENT) &&
                        user.getStatus().equals(UserStatus.ACTIVE)
        ));
    }

    @Test
    @DisplayName("Должен удалить статус верификации после успешной регистрации")
    void shouldDeleteVerificationStatusAfterRegistration() {
        // Given
        when(smsRepository.isPhoneVerified(validCommand.phone())).thenReturn(true);
        when(passwordEncoder.encode(validCommand.rawPassword())).thenReturn("encodedPass");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        when(tokenGenerator.generateAccessToken(any())).thenReturn("access-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");

        // When
        service.register(validCommand);

        // Then
        verify(smsRepository).deleteVerificationStatus(validCommand.phone());
    }

    @Test
    @DisplayName("Должен корректно обработать пользователя без email")
    void shouldHandleUserWithoutEmail() {
        // Given
        RegisterUserCommand commandWithoutEmail = RegisterUserCommand.builder()
                .email(null)  // ← email = null
                .phone("79991234567")
                .rawPassword("Password123!")
                .firstName("John")
                .lastName("Doe")
                .middleName(null)
                .ipAddress("192.168.1.1")
                .userAgent("Mozilla/5.0")
                .build();

        User userWithoutEmail = User.builder()
                .id(1L)
                .email(null)
                .phone("79991234567")
                .passwordHash("encodedPass")
                .firstName("John")
                .lastName("Doe")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        when(smsRepository.isPhoneVerified(commandWithoutEmail.phone())).thenReturn(true);
        when(passwordEncoder.encode(commandWithoutEmail.rawPassword())).thenReturn("encodedPass");
        when(userRepository.save(any(User.class))).thenReturn(userWithoutEmail);
        when(tokenGenerator.generateAccessToken(any())).thenReturn("access-token");
        when(createRefreshTokenUseCase.create(any())).thenReturn("refresh-token");

        // When
        JwtAuthenticationResponse response = service.register(commandWithoutEmail);

        // Then
        assertThat(response).isNotNull();
        verify(userRepository).save(argThat(user -> user.getEmail() == null));
    }
}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/application/JwtTokenProviderTest.java ===
package com.logistics.userauth.auth.jwt.application;


import com.logistics.userauth.auth.jwt.adapter.out.JwtTokenProvider;
import com.logistics.userauth.user.domain.User;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

@DisplayName("JwtTokenProvider: юнит‑тесты")
public class JwtTokenProviderTest {

    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setUp() {
        jwtTokenProvider = new JwtTokenProvider();
        TestReflection.setField(jwtTokenProvider, "secret", "test-secret-key-test-secret-key-123456");
        TestReflection.setField(jwtTokenProvider, "accessTokenTtlSeconds", 3600_000L);
    }

    private User buildUser() {
        return User.builder()
                .id(42L)
                .email("test@example.com")
                .phone("79991234567")
                .passwordHash("HASH")
                .firstName("Иван")
                .lastName("Иванов")
                .middleName("Иванович")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .createdTime(LocalDateTime.now())
                .lastAccessedTime(LocalDateTime.now())
                .build();
    }

    @Test
    @DisplayName("Должен генерировать и валидировать JWT и извлекать userId")
    void shouldGenerateAndValidateToken() {
        User user = buildUser();

        String token = jwtTokenProvider.generateAccessToken(user);

        assertThat(token).isNotBlank();
        assertThat(jwtTokenProvider.isTokenValid(token)).isTrue();

        Long userId = jwtTokenProvider.extractUserId(token);
        assertThat(userId).isEqualTo(42L);
    }

    /**
     * Вспомогательный класс для установки приватных полей через reflection,
     * чтобы не тянуть Spring в юнит‑тест.
     */
    static class TestReflection {
        static void setField(Object target, String fieldName, Object value) {
            try {
                var field = target.getClass().getDeclaredField(fieldName);
                field.setAccessible(true);
                field.set(target, value);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/jwt/adapter/in/web/AuthControllerIntegrationTest.java ===
package com.logistics.userauth.auth.jwt.adapter.in.web;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.auth.jwt.adapter.in.web.dto.RefreshTokenRequest;
import com.logistics.userauth.sms.application.port.out.SendSmsPort;
import com.logistics.userauth.sms.application.port.out.SmsRepository;
import com.logistics.userauth.user.adapter.in.web.dto.SignInRequest;
import com.logistics.userauth.user.adapter.in.web.dto.SignUpRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

import static org.hamcrest.Matchers.notNullValue;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@IntegrationTest
@AutoConfigureMockMvc
@DisplayName("AuthController - интеграционный тест")
class AuthControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private SendSmsPort sendSmsPort;

    @Autowired
    private SmsRepository smsRepository;

    @BeforeEach
    void setUp() {
        // Mock SMS отправки
        when(sendSmsPort.sendVerificationCode(anyString(), anyString())).thenReturn(true);
    }

    @Test
    @DisplayName("Должен успешно зарегистрировать пользователя и вернуть JWT токены")
    void shouldRegisterUserAndReturnTokens() throws Exception {
        // Given - верифицируем телефон
        String phone = "+79991111111";  // ← ИСПРАВИЛ: правильный формат!

        smsRepository.markPhoneAsVerified(phone, 10L);

        // When
        var signUpRequest = new SignUpRequest(
                "test@example.com",
                phone,
                "Password123!",
                "John",
                "Doe",
                "Smith"
        );

        // Then
        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andDo(print())  // ← Для отладки
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен вернуть 400 если телефон не верифицирован")
    void shouldReturn400WhenPhoneNotVerified() throws Exception {
        // Given
        var signUpRequest = new SignUpRequest(
                "notverified@example.com",
                "+79992222222",  // ← ИСПРАВИЛ: правильный формат!
                "Password123!",
                "Jane",
                "Doe",
                null
        );

        // When & Then
        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andDo(print())
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("PHONE_NOT_VERIFIED"));
    }

    @Test
    @DisplayName("Должен аутентифицировать пользователя и вернуть токены")
    void shouldAuthenticateUserAndReturnTokens() throws Exception {
        // Given - регистрируем пользователя
        String phone = "+79997654321";  // ← ИСПРАВИЛ: правильный формат!
        String password = "Password123!";

        // Верифицируем телефон
        smsRepository.markPhoneAsVerified(phone, 10L);

        var signUpRequest = new SignUpRequest(
                "login@example.com",
                phone,
                password,
                "Jane",
                "Doe",
                "Smith"
        );

        mockMvc.perform(post("/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(signUpRequest)));

        // When - логинимся
        var signInRequest = new SignInRequest(phone, null, password);

        // Then
        mockMvc.perform(post("/auth/sign-in")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signInRequest)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен обновить access token используя refresh token")
    void shouldRefreshAccessToken() throws Exception {
        // Given - регистрируем пользователя
        String phone = "+79995555555";  // ← ИСПРАВИЛ: правильный формат!

        smsRepository.markPhoneAsVerified(phone, 10L);

        var signUpRequest = new SignUpRequest(
                "refresh@example.com",
                phone,
                "Password123!",
                "Refresh",
                "Test",
                "User"
        );

        MvcResult registerResult = mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andExpect(status().isCreated())  // ← ПРОВЕРЯЕМ статус сразу!
                .andReturn();

        String responseBody = registerResult.getResponse().getContentAsString();
        var authResponse = objectMapper.readTree(responseBody);

        // ← ПРОВЕРКА на null!
        if (authResponse.get("refreshToken") == null) {
            throw new AssertionError("refreshToken не найден в ответе: " + responseBody);
        }

        String refreshToken = authResponse.get("refreshToken").asText();

        // When - обновляем токен
        var refreshRequest = new RefreshTokenRequest(refreshToken);

        // Then
        mockMvc.perform(post("/auth/refresh")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(refreshRequest)))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").value(notNullValue()))
                .andExpect(jsonPath("$.refreshToken").value(notNullValue()));
    }

    @Test
    @DisplayName("Должен успешно выполнить logout и отозвать refresh token")
    void shouldRevokeRefreshTokenOnLogout() throws Exception {
        // Given - регистрируем пользователя
        String phone = "+79996666666";  // ← ИСПРАВИЛ: правильный формат!

        smsRepository.markPhoneAsVerified(phone, 10L);

        var signUpRequest = new SignUpRequest(
                "logout@example.com",
                phone,
                "Password123!",
                "Logout",
                "Test",
                "User"
        );

        MvcResult registerResult = mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andExpect(status().isCreated())
                .andReturn();

        String responseBody = registerResult.getResponse().getContentAsString();
        var authResponse = objectMapper.readTree(responseBody);
        String refreshToken = authResponse.get("refreshToken").asText();

        // When - делаем logout
        var logoutRequest = new RefreshTokenRequest(refreshToken);

        mockMvc.perform(post("/auth/logout")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(logoutRequest)))
                .andDo(print())
                .andExpect(status().isNoContent());

        // Then - токен больше не работает
        mockMvc.perform(post("/auth/refresh")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(logoutRequest)))
                .andDo(print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Должен вернуть 401 при неверном пароле")
    void shouldReturn401ForInvalidPassword() throws Exception {
        // Given - регистрируем пользователя
        String phone = "+79993333333";

        smsRepository.markPhoneAsVerified(phone, 10L);

        var signUpRequest = new SignUpRequest(
                "invalid@example.com",
                phone,
                "Password123!",
                "Invalid",
                "Test",
                null
        );

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signUpRequest)))
                .andExpect(status().isCreated());

        // When - логинимся с неверным, но валидным паролем
        var signInRequest = new SignInRequest(phone, null, "WrongPassword1!");

        // Then
        mockMvc.perform(post("/auth/sign-in")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signInRequest)))
                .andDo(print())
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.error").value("INVALID_CREDENTIALS"));
    }


    @Test
    @DisplayName("Должен вернуть 409 при дублировании телефона")
    void shouldReturn409ForDuplicatePhone() throws Exception {
        // Given - регистрируем первого пользователя
        String phone = "+79994444444";

        smsRepository.markPhoneAsVerified(phone, 10L); // 1) верификация для 1-й регистрации

        var firstRequest = new SignUpRequest(
                "first@example.com",
                phone,
                "Password123!",
                "First",
                "User",
                null
        );

        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(firstRequest)))
                .andExpect(status().isCreated());

        // ВАЖНО: после успешной регистрации сервис удаляет verification status
        smsRepository.markPhoneAsVerified(phone, 10L); // 2) верификация для 2-й регистрации

        var secondRequest = new SignUpRequest(
                "second@example.com",
                phone,
                "Password456!",
                "Second",
                "User",
                null
        );

        // Then
        mockMvc.perform(post("/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(secondRequest)))
                .andDo(print())
                .andExpect(status().isConflict())
                .andExpect(jsonPath("$.error").value("CONFLICT"));
    }

}



=== backend/user-auth-service/src/test/java/com/logistics/userauth/auth/session/adapter/out/persistence/UserSessionJpaRepositoryIntegrationTest.java ===
package com.logistics.userauth.auth.session.adapter.out.persistence;

import com.logistics.userauth.IntegrationTest;
import com.logistics.userauth.user.adapter.out.persistence.UserEntity;
import com.logistics.userauth.user.adapter.out.persistence.UserJpaRepository;
import com.logistics.userauth.user.domain.UserRole;
import com.logistics.userauth.user.domain.UserStatus;
import io.hypersistence.utils.hibernate.type.basic.Inet;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.LocalDateTime;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@IntegrationTest
@DisplayName("UserSessionJpaRepository: интеграционные тесты")
class UserSessionJpaRepositoryIntegrationTest {

    @Autowired
    private UserSessionJpaRepository repository;

    @Autowired
    private UserJpaRepository userRepository;

    private UserEntity testUser;

    @BeforeEach
    void setUp() {
        // Создаём и сохраняем тестового пользователя
        testUser = UserEntity.builder()
                .phone("+79992222222")
                .firstName("Session")
                .lastName("User")
                .role(UserRole.CLIENT)
                .status(UserStatus.ACTIVE)
                .build();

        testUser = userRepository.save(testUser);
    }

    @Test
    @Transactional
    @DisplayName("Должен сохранить и найти сессию по токену")
    void shouldSaveAndFindByRefreshToken() {

        Inet in = new Inet("192.168.1.10");
        // Given
        UserSessionEntity session = UserSessionEntity.builder()
                .user(testUser)
                .refreshToken("unique-token-12345")
                .expiresAt(LocalDateTime.now().plusHours(2))
                .createdAt(LocalDateTime.now())
                .ipAddress(in)
                .userAgent("Mozilla/5.0")
                .build();

        // When
        repository.save(session);

        // Then
        Optional<UserSessionEntity> found = repository.findByRefreshToken("unique-token-12345");

        assertThat(found).isPresent();
        assertThat(found.get().getUser()).isEqualTo(testUser);
        assertThat(found.get().getIpAddress()).isEqualTo(in);
        assertThat(found.get().getUserAgent()).isEqualTo("Mozilla/5.0");
    }

    @Test
    @Transactional
    @DisplayName("Должен вернуть пустой Optional для несуществующего токена")
    void shouldReturnEmptyForNonExistentToken() {
        // When
        Optional<UserSessionEntity> found = repository.findByRefreshToken("non-existent-token");

        // Then
        assertThat(found).isEmpty();
    }
}


